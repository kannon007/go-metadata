
# SQL 数据血缘解析组件

## 1. 背景与目标
SQL 数据血缘（Data Lineage）用于追踪数据从源头字段，经由算子、转换逻辑，一直到目标字段的完整流向。本系统的目标：

- 支持多类型 SQL（SELECT、INSERT…SELECT、CTE、子查询、JOIN 等）
- 支持字段级血缘（column-level lineage）
- 支持表达式解析（函数、算术表达式、CASE WHEN、聚合、窗口等）
- 可插拔 schema 适配（MySQL / PG / Doris / Spark SQL 等）
- 支撑数据治理：质量、ETL 监控、影响分析（Impact Analysis）

---

## 2. 系统整体架构

### 2.1 目录结构
```
internal/lineage/
├── grammar/                # ANTLR 语法文件
│   ├── SQLLexer.g4         # 词法规则
│   ├── SQLParser.g4        # 语法规则
│   └── generate.sh         # 生成脚本
├── parser/                 # ANTLR 生成的 Go 代码
│   ├── sqllexer.go         # 词法分析器
│   ├── sqlparser.go        # 语法分析器
│   ├── sqlparser_base_listener.go
│   └── sqlparser_listener.go
├── ast/                    # AST 节点定义
│   ├── node.go             # 基础节点接口
│   ├── expr.go             # 表达式节点
│   ├── stmt.go             # 语句节点
│   └── visitor.go          # Visitor 模式接口
├── types.go                # 核心数据类型 (ColumnRef, ColumnLineage, LineageResult)
├── catalog.go              # Catalog 接口和 TableSchema
├── errors.go               # 错误定义
├── lineage.go              # 血缘解析器主入口
├── resolver.go             # 血缘解析核心逻辑
├── extractor.go            # 字段依赖提取器
├── tests/                  # 测试代码
│   ├── mock_catalog.go     # Mock Catalog 实现
│   ├── parser_test.go      # 基础测试
│   ├── mysql_test.go       # MySQL 语法测试
│   ├── pgsql_test.go       # PostgreSQL 语法测试
│   ├── sqlserver_test.go   # SQL Server 语法测试
│   ├── spark_test.go       # Spark SQL 语法测试
│   ├── flink_test.go       # Flink SQL 语法测试
│   └── doris_test.go       # Doris 语法测试
├── testdata/               # 测试用例数据
│   ├── mysql/              # MySQL 测试 SQL
│   ├── pgsql/              # PostgreSQL 测试 SQL
│   ├── sqlserver/          # SQL Server 测试 SQL
│   ├── spark/              # Spark SQL 测试 SQL
│   ├── flink/              # Flink SQL 测试 SQL
│   └── doris/              # Doris 测试 SQL
└── doc/                    # 文档
    └── 数据血缘解析.md
```


### 2.2 模块结构
```
+--------------------------------------------------+
|              SQL Lineage Engine (ANTLR + Go)     |
+--------------------------------------------------+
|  ┌────────────────────────────────────────────┐  |
|  │  1. ANTLR Lexer/Parser (词法/语法分析)       │  |
|  │     - SQLLexer.g4 / SQLParser.g4           │  |
|  │     - antlr4-go-runtime                    │  |
|  └────────────────────────────────────────────┘  |
|                      ↓                           |
|  ┌────────────────────────────────────────────┐  |
|  │  2. AST Builder (抽象语法树构建)              │  |
|  │     - Listener/Visitor 模式                 │  |
|  │     - 自定义 AST 节点结构                    │  |
|  └────────────────────────────────────────────┘  |
|                      ↓                           |
|  ┌────────────────────────────────────────────┐  |
|  │  3. Lineage Resolver (血缘解析器)            │  |
|  │     - 字段依赖提取                          │  |
|  │     - 别名解析 / 作用域管理                  │  |
|  │     - 表达式递归分析                        │  |
|  └────────────────────────────────────────────┘  |
|                      ↓                           |
|  ┌────────────────────────────────────────────┐  |
|  │  4. Catalog Service (元数据服务)             │  |
|  │     - 表结构查询                            │  |
|  │     - SELECT * 展开                         │  |
|  └────────────────────────────────────────────┘  |
|                      ↓                           |
|  ┌────────────────────────────────────────────┐  |
|  │  5. Lineage Graph Builder (血缘图构建)       │  |
|  │     - 字段级 DAG 生成                       │  |
|  │     - JSON / OpenLineage 输出              │  |
|  └────────────────────────────────────────────┘  |
+--------------------------------------------------+
```

### 2.3 技术栈
| 组件 | 技术选型 | 说明 |
|------|---------|------|
| 词法/语法分析 | ANTLR4 | 自研语法文件，支持多方言 |
| 运行时 | antlr4-go-runtime | Go 语言运行时 |
| AST 遍历 | Listener/Visitor | 灵活的树遍历模式 |
| 元数据 | Catalog 接口 | 可插拔的 schema 服务 |

### 2.4 流程
1. **词法分析**：ANTLR Lexer 将 SQL 分解为 Token 流
2. **语法分析**：ANTLR Parser 构建 Parse Tree
3. **AST 构建**：Listener 遍历 Parse Tree，生成自定义 AST
4. **血缘解析**：Visitor 递归遍历 AST，提取字段依赖
5. **元数据绑定**：从 Catalog 获取表结构，展开 `*`
6. **输出生成**：构建字段级血缘 DAG

---

## 3. 核心接口设计

### 3.1 ColumnRef 结构（字段引用）
```go
type ColumnRef struct {
    Database string `json:"database,omitempty"`
    Table    string `json:"table"`
    Column   string `json:"column"`
}
```

### 3.2 TableSchema 结构（表元数据）
```go
type TableSchema struct {
    Database string   `json:"database"`
    Table    string   `json:"table"`
    Columns  []string `json:"columns"`
}
```

### 3.3 Catalog 接口（获取 schema）
```go
type Catalog interface {
    GetTableSchema(db, table string) (*TableSchema, error)
}
```

### 3.4 Lineage Parser 接口
```go
type LineageParser interface {
    Parse(sql string) (*LineageResult, error)
}
```


### 3.5 LineageResult 数据结构
```go
type ColumnLineage struct {
    Target     ColumnRef     `json:"target"`
    Sources    []ColumnRef   `json:"sources"`
    Operators  []string      `json:"operators"`
}

type LineageResult struct {
    Columns []ColumnLineage `json:"columns"`
}
```

### 3.6 错误处理
```go
var (
    ErrUnsupportedSQL   = errors.New("unsupported SQL syntax")
    ErrTableNotFound    = errors.New("table not found in catalog")
    ErrColumnNotFound   = errors.New("column not found in table")
)
```
- **解析失败**：返回 `ErrUnsupportedSQL`，附带具体位置信息
- **Catalog 缺失**：降级为不展开 `*`，仅解析显式列
- **列不存在**：记录警告，继续解析其他字段

---

## 4. 血缘推导逻辑（核心算法）

### 4.1 字段解析流程
```
1. Scan SelectField
2. 如果是简单列引用：table.col → target
3. 如果是表达式：
   • 递归解析所有依赖列
   • 收集所有算子（函数名、表达式类型等）
4. JOIN 场景：为每个表维护 alias → table 映射
5. 子查询 / CTE：按作用域递归构建 lineage context
```

### 4.2 `SELECT *` 展开
- 依赖 Catalog 获取列列表  
- 根据上下文表别名展开（如 `a.*`、`b.*`）

### 4.3 支持的表达式类型
- `FuncCall`：如 `substr(a,1,3)` → operator: `substr`
- 算术表达式：`a + b * 2`
- 聚合：`sum(x)`
- CASE WHEN：递归收集依赖字段
- 窗口函数：`row_number() over()`

---

## 5. 使用示例

### 5.1 基本调用
```go
// 初始化 Catalog
catalog := NewMySQLCatalog(db)

// 创建解析器
parser := NewLineageParser(catalog)

// 解析 SQL
sql := "INSERT INTO t1(a, b) SELECT x, y FROM t2"
result, err := parser.Parse(sql)
if err != nil {
    log.Fatal(err)
}

// 输出血缘
for _, col := range result.Columns {
    fmt.Printf("%s.%s <- %v\n", col.Target.Table, col.Target.Column, col.Sources)
}
```


### 5.2 SELECT 输出示例
```json
{
  "columns": [
    {
      "target": {"table":"users_clean","column":"id"},
      "sources":[{"table":"users","column":"user_id"}],
      "operators":["identity"]
    },
    {
      "target":{"table":"users_clean","column":"name_lower"},
      "sources":[{"table":"users","column":"name"}],
      "operators":["lower"]
    }
  ]
}
```
> **说明**：`identity` 表示直接映射，无转换操作

### 5.3 INSERT...SELECT 输出示例
```sql
INSERT INTO report(total_amount, user_count)
SELECT SUM(amount), COUNT(DISTINCT user_id) FROM orders
```
```json
{
  "columns": [
    {
      "target": {"table":"report","column":"total_amount"},
      "sources":[{"table":"orders","column":"amount"}],
      "operators":["sum"]
    },
    {
      "target":{"table":"report","column":"user_count"},
      "sources":[{"table":"orders","column":"user_id"}],
      "operators":["count","distinct"]
    }
  ]
}
```

---

## 6. 性能与扩展性设计

### 6.1 性能优化
- AST 节点复用  
- 缓存 catalog（表结构元数据）  
- 多 SQL 并行解析（goroutine pool）  

### 6.2 扩展性
- Parser 层可切换 MySQL / SQLServer / SparkSQL  
- 算子解析器可注册自定义函数  
- 输出端可扩展 OpenLineage、DataHub、Atlas

---

## 7. 适配多引擎

### 7.1 ANTLR 语法文件策略
```
grammar/
├── common/
│   ├── SQLLexerBase.g4      # 公共词法规则
│   └── SQLParserBase.g4     # 公共语法规则
├── mysql/
│   ├── MySQLLexer.g4        # MySQL 词法
│   └── MySQLParser.g4       # MySQL 语法
├── pgsql/
│   ├── PostgreSQLLexer.g4
│   └── PostgreSQLParser.g4
├── spark/
│   ├── SparkSQLLexer.g4
│   └── SparkSQLParser.g4
├── flink/
│   ├── FlinkSQLLexer.g4
│   └── FlinkSQLParser.g4
└── doris/
    ├── DorisLexer.g4
    └── DorisParser.g4
```


### 7.2 引擎适配矩阵
| 引擎类型 | 语法文件 | 特殊语法支持 |
|---------|----------|-------------|
| MySQL | MySQLParser.g4 | STRAIGHT_JOIN, USE INDEX |
| PostgreSQL | PostgreSQLParser.g4 | CTE, Window, LATERAL |
| Spark SQL | SparkSQLParser.g4 | TRANSFORM, LATERAL VIEW |
| Flink SQL | FlinkSQLParser.g4 | TUMBLE, HOP, SESSION |
| Doris | DorisParser.g4 | BITMAP, HLL, ROLLUP |
| SQL Server | SQLServerParser.g4 | TOP, CROSS APPLY, PIVOT |

---

## 8. 测试体系
- SQL 单元测试（每条语句有输入 SQL → 输出 JSON）  
- 覆盖率：  
  - JOIN（inner / left / right / cross）  
  - 嵌套子查询  
  - CTE  
  - 聚合 + 分组  
  - 窗口函数  
  - union / union all  
  - insert…select  

---

## 9. ANTLR 开发环境

### 9.1 环境准备
```bash
# 安装 ANTLR4
# Windows (使用 Chocolatey)
choco install antlr4

# 或下载 jar 包
curl -O https://www.antlr.org/download/antlr-4.13.1-complete.jar

# 安装 Go runtime
go get github.com/antlr4-go/antlr/v4
```

### 9.2 生成 Go 代码
```bash
# 进入语法目录
cd internal/lineage/grammar

# 生成 Go 代码
antlr4 -Dlanguage=Go -visitor -listener -o ../parser SQLLexer.g4 SQLParser.g4

# 或使用 generate.sh
./generate.sh
```

### 9.3 语法文件示例 (SQLParser.g4)
```antlr
grammar SQLParser;

options {
    tokenVocab = SQLLexer;
}

// 入口规则
sqlStatement
    : selectStatement
    | insertStatement
    | EOF
    ;

// SELECT 语句
selectStatement
    : SELECT selectElements fromClause? whereClause? groupByClause? orderByClause?
    ;

selectElements
    : selectElement (COMMA selectElement)*
    ;

selectElement
    : STAR                                          # selectAll
    | tableName DOT STAR                            # selectTableAll
    | expression (AS? alias)?                       # selectExpr
    ;

// 表达式
expression
    : columnRef                                     # columnExpr
    | functionCall                                  # funcExpr
    | expression op=(PLUS|MINUS|STAR|DIV) expression # binaryExpr
    | LPAREN expression RPAREN                      # parenExpr
    | caseExpression                                # caseExpr
    ;

columnRef
    : (tableName DOT)? columnName
    ;

functionCall
    : functionName LPAREN (expression (COMMA expression)*)? RPAREN
      (OVER windowSpec)?
    ;
```

---

## 10. 附录：未来增强方向
- 自动识别数据质量规则（schema-based）
- 血缘 + 数据流执行图（runtime lineage）
- 可视化拓扑图（web dag 强制布局）
- 表级 → 字段级 → 任务级 lineage 整合
