// Code generated from C:/Users/pxl/IdeaProjects/go-metadata/core/lineage/grammar/SQLParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // SQLParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SQLParser struct {
	*antlr.BaseParser
}

var SQLParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func sqlparserParserInit() {
	staticData := &SQLParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "'='", "", "'<'", "'<='", "'>'", "'>='", "'+'",
		"'-'", "'*'", "'/'", "'%'", "'||'", "'&'", "'|'", "'^'", "'~'", "'::'",
		"'->'", "'->>'", "'@'", "'#'", "'$'", "'('", "')'", "'['", "']'", "'{'",
		"'}'", "','", "'.'", "';'", "':'", "'?'",
	}
	staticData.SymbolicNames = []string{
		"", "SELECT", "FROM", "WHERE", "AND", "OR", "NOT", "AS", "ON", "JOIN",
		"INNER", "LEFT", "RIGHT", "OUTER", "CROSS", "FULL", "NATURAL", "SEMI_JOIN",
		"ANTI", "INSERT", "INTO", "VALUES", "UPDATE", "SET", "DELETE", "TRUNCATE",
		"CREATE", "TABLE", "VIEW", "DATABASE", "SCHEMA", "DROP", "ALTER", "INDEX",
		"ADD", "COLUMN", "RENAME", "TO", "MODIFY", "CHANGE", "CONSTRAINT", "PRIMARY",
		"KEY", "FOREIGN", "REFERENCES", "UNIQUE", "CHECK", "DEFAULT", "AUTO_INCREMENT",
		"COMMENT", "IF_P", "TEMPORARY", "TEMP", "EXTERNAL", "LOCATION", "STORED",
		"FORMAT", "TBLPROPERTIES", "ROW_FORMAT", "FIELDS", "TERMINATED", "LINES",
		"COLLECTION", "ITEMS", "KEYS", "ESCAPED", "SERDE", "SERDEPROPERTIES",
		"CLUSTERED", "SORTED", "BUCKETS", "SKEWED", "PARTITIONED", "WATERMARK",
		"FOR", "SYSTEM_TIME", "SYSTEM", "ENFORCED", "METADATA", "VIRTUAL", "CONNECTOR",
		"OPTIONS", "WITHOUT", "PERIOD", "VERSIONING", "GENERATED", "ALWAYS",
		"IDENTITY", "START", "INCREMENT", "MINVALUE", "MAXVALUE", "CYCLE", "CACHE",
		"MERGE", "USING", "MATCHED", "UPSERT", "OVERWRITE", "REPLACE", "IGNORE",
		"DUPLICATE", "LATERAL", "UNNEST", "EXPLODE", "POSEXPLODE", "INLINE",
		"STACK", "TABLESAMPLE", "PERCENT", "BUCKET", "OUT", "OF", "DISTRIBUTED",
		"HASH", "RANDOM", "BROADCAST", "REPLICATED", "PROPERTIES", "ENGINE",
		"CHARSET", "CHARACTER", "COLLATE", "TABLESPACE", "INHERITS", "FILEGROUP",
		"CLUSTERED_INDEX", "ON_COMMIT", "PRESERVE", "GLOBAL", "LOCAL", "UNLOGGED",
		"TTL", "LIFECYCLE", "AUTO", "INCR", "RESTRICT", "CASCADE", "ACTION",
		"OVER", "PARTITION", "ROWS", "RANGE", "GROUPS", "UNBOUNDED", "PRECEDING",
		"FOLLOWING", "CURRENT", "ROW", "FIRST", "LAST", "NULLS", "EXCLUDE",
		"TIES", "NO", "OTHERS", "GROUP", "BY", "ORDER", "ASC", "DESC", "HAVING",
		"LIMIT", "OFFSET", "FETCH", "NEXT", "ONLY", "TOP", "UNION", "INTERSECT",
		"EXCEPT", "MINUS_SET", "ALL", "DISTINCT", "WITH", "WITHIN", "RECURSIVE",
		"CASE", "WHEN", "THEN", "ELSE", "END", "NULL", "IS", "IN", "BETWEEN",
		"LIKE", "ILIKE", "RLIKE", "REGEXP", "SIMILAR", "ESCAPE", "EXISTS", "TRUE",
		"FALSE", "UNKNOWN", "CAST", "CONVERT", "TRY_CAST", "EXTRACT", "INTERVAL",
		"AT", "ZONE", "TIME", "TIMESTAMP", "DATE", "YEAR", "MONTH", "DAY", "HOUR",
		"MINUTE", "SECOND", "SOME", "ANY", "ARRAY", "MAP", "STRUCT", "NAMED_STRUCT",
		"INT", "INTEGER", "TINYINT", "SMALLINT", "BIGINT", "FLOAT", "DOUBLE",
		"DECIMAL", "NUMERIC", "REAL", "BOOLEAN", "BOOL", "STRING", "VARCHAR",
		"CHAR", "TEXT", "BINARY", "VARBINARY", "BLOB", "CLOB", "JSON", "XML",
		"BYTES", "MULTISET", "RAW", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS",
		"MINUS", "STAR", "DIV", "MOD", "CONCAT", "AMPERSAND", "PIPE", "CARET",
		"TILDE", "DOUBLE_COLON", "ARROW", "DOUBLE_ARROW", "AT_SIGN", "HASH_SIGN",
		"DOLLAR", "LPAREN", "RPAREN", "LBRACKET", "RBRACKET", "LBRACE", "RBRACE",
		"COMMA", "DOT", "SEMI", "COLON", "QUESTION", "STRING_LITERAL", "DOUBLE_QUOTED_STRING",
		"NUMBER", "HEX_NUMBER", "BIT_STRING", "IDENTIFIER", "BACKTICK_IDENTIFIER",
		"BRACKET_IDENTIFIER", "VARIABLE", "SYSTEM_VARIABLE", "WS", "LINE_COMMENT",
		"BLOCK_COMMENT", "HINT_COMMENT",
	}
	staticData.RuleNames = []string{
		"sqlStatements", "sqlStatement", "dmlStatement", "ddlStatement", "selectStatement",
		"queryExpression", "queryTerm", "withClause", "cteDefinition", "selectClause",
		"selectElements", "selectElement", "fromClause", "tableReferences",
		"tableReference", "tableFactor", "tableSample", "joinPart", "temporalJoinClause",
		"joinType", "whereClause", "groupByClause", "groupByElements", "groupByElement",
		"havingClause", "orderByClause", "orderByElement", "limitClause", "insertStatement",
		"partitionSpec", "partitionElement", "columnList", "valuesClause", "valueRow",
		"onDuplicateKeyUpdate", "updateStatement", "updateElement", "deleteStatement",
		"truncateStatement", "mergeStatement", "mergeClause", "mergeUpdateClause",
		"mergeInsertClause", "createStatement", "createTableStatement", "tableElementList",
		"tableElement", "watermarkDefinition", "columnDefinition", "dataType",
		"primitiveType", "structField", "columnConstraint", "identityOptions",
		"referentialAction", "referentialActionType", "notEnforced", "tableConstraint",
		"partitionedByClause", "clusteredByClause", "distributedByClause", "sortedByClause",
		"tableInheritsClause", "engineClause", "charsetClause", "collateClause",
		"tablespaceClause", "ttlClause", "lifecycleClause", "rowFormatClause",
		"storedAsClause", "locationClause", "tablePropertiesClause", "withOptionsClause",
		"propertyList", "property", "createViewStatement", "createDatabaseStatement",
		"createIndexStatement", "indexColumn", "dropStatement", "alterStatement",
		"alterTableAction", "expression", "castExpression", "extractExpression",
		"intervalExpression", "caseExpression", "arrayConstructor", "mapConstructor",
		"structConstructor", "functionCall", "overClause", "partitionByClause",
		"windowFrame", "windowFrameBound", "columnRef", "expressionList", "tableName",
		"databaseName", "columnName", "functionName", "alias", "identifier",
		"nonReservedKeyword", "literal",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 289, 1923, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 1, 0, 1, 0, 1, 0, 5, 0, 216, 8, 0, 10, 0,
		12, 0, 219, 9, 0, 1, 0, 3, 0, 222, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1,
		228, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 236, 8, 2, 1, 3, 1,
		3, 1, 3, 3, 3, 241, 8, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 3, 5, 248, 8, 5,
		1, 5, 5, 5, 251, 8, 5, 10, 5, 12, 5, 254, 9, 5, 1, 6, 3, 6, 257, 8, 6,
		1, 6, 1, 6, 3, 6, 261, 8, 6, 1, 6, 3, 6, 264, 8, 6, 1, 6, 3, 6, 267, 8,
		6, 1, 6, 3, 6, 270, 8, 6, 1, 6, 3, 6, 273, 8, 6, 1, 6, 3, 6, 276, 8, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 282, 8, 6, 1, 7, 1, 7, 3, 7, 286, 8, 7, 1,
		7, 1, 7, 1, 7, 5, 7, 291, 8, 7, 10, 7, 12, 7, 294, 9, 7, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 5, 8, 301, 8, 8, 10, 8, 12, 8, 304, 9, 8, 1, 8, 1, 8, 3,
		8, 308, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 3, 9, 317, 8, 9,
		1, 9, 1, 9, 3, 9, 321, 8, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 5, 10, 328,
		8, 10, 10, 10, 12, 10, 331, 9, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 3, 11, 340, 8, 11, 1, 11, 3, 11, 343, 8, 11, 3, 11, 345, 8,
		11, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 5, 13, 353, 8, 13, 10, 13,
		12, 13, 356, 9, 13, 1, 14, 1, 14, 5, 14, 360, 8, 14, 10, 14, 12, 14, 363,
		9, 14, 1, 15, 1, 15, 3, 15, 367, 8, 15, 1, 15, 3, 15, 370, 8, 15, 1, 15,
		3, 15, 373, 8, 15, 1, 15, 3, 15, 376, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		3, 15, 382, 8, 15, 1, 15, 3, 15, 385, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 3, 15, 392, 8, 15, 1, 15, 3, 15, 395, 8, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 3, 15, 402, 8, 15, 1, 15, 3, 15, 405, 8, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 3, 15, 412, 8, 15, 1, 15, 3, 15, 415, 8, 15, 3, 15,
		417, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 3, 16, 430, 8, 16, 1, 16, 1, 16, 1, 17, 3, 17, 435, 8,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17,
		446, 8, 17, 10, 17, 12, 17, 449, 9, 17, 1, 17, 1, 17, 3, 17, 453, 8, 17,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 3, 18, 466, 8, 18, 1, 19, 1, 19, 1, 19, 3, 19, 471, 8, 19, 1, 19, 1,
		19, 3, 19, 475, 8, 19, 1, 19, 1, 19, 3, 19, 479, 8, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 3, 19, 487, 8, 19, 1, 20, 1, 20, 1, 20, 1, 21,
		1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 5, 22, 499, 8, 22, 10, 22, 12,
		22, 502, 9, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23,
		511, 8, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5,
		25, 521, 8, 25, 10, 25, 12, 25, 524, 9, 25, 1, 26, 1, 26, 3, 26, 528, 8,
		26, 1, 26, 1, 26, 3, 26, 532, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27,
		538, 8, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3,
		27, 548, 8, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 556, 8,
		27, 3, 27, 558, 8, 27, 1, 28, 1, 28, 3, 28, 562, 8, 28, 1, 28, 3, 28, 565,
		8, 28, 1, 28, 1, 28, 3, 28, 569, 8, 28, 1, 28, 3, 28, 572, 8, 28, 1, 28,
		1, 28, 3, 28, 576, 8, 28, 1, 28, 3, 28, 579, 8, 28, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 5, 29, 586, 8, 29, 10, 29, 12, 29, 589, 9, 29, 1, 29, 1,
		29, 1, 30, 1, 30, 1, 30, 3, 30, 596, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31,
		5, 31, 602, 8, 31, 10, 31, 12, 31, 605, 9, 31, 1, 31, 1, 31, 1, 32, 1,
		32, 1, 32, 1, 32, 5, 32, 613, 8, 32, 10, 32, 12, 32, 616, 9, 32, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 5,
		34, 629, 8, 34, 10, 34, 12, 34, 632, 9, 34, 1, 35, 1, 35, 1, 35, 3, 35,
		637, 8, 35, 1, 35, 3, 35, 640, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35,
		646, 8, 35, 10, 35, 12, 35, 649, 9, 35, 1, 35, 3, 35, 652, 8, 35, 1, 35,
		3, 35, 655, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1,
		37, 3, 37, 665, 8, 37, 1, 37, 3, 37, 668, 8, 37, 1, 37, 3, 37, 671, 8,
		37, 1, 38, 1, 38, 3, 38, 675, 8, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39,
		1, 39, 3, 39, 683, 8, 39, 1, 39, 3, 39, 686, 8, 39, 1, 39, 1, 39, 1, 39,
		3, 39, 691, 8, 39, 1, 39, 3, 39, 694, 8, 39, 1, 39, 1, 39, 1, 39, 4, 39,
		699, 8, 39, 11, 39, 12, 39, 700, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 707,
		8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 715, 8, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 724, 8, 40, 1, 40,
		1, 40, 3, 40, 728, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 735,
		8, 41, 10, 41, 12, 41, 738, 9, 41, 1, 42, 1, 42, 3, 42, 742, 8, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 753,
		8, 43, 1, 44, 1, 44, 3, 44, 757, 8, 44, 1, 44, 3, 44, 760, 8, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 3, 44, 766, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 3, 44, 773, 8, 44, 1, 44, 3, 44, 776, 8, 44, 1, 44, 3, 44, 779, 8,
		44, 1, 44, 3, 44, 782, 8, 44, 1, 44, 3, 44, 785, 8, 44, 1, 44, 3, 44, 788,
		8, 44, 1, 44, 3, 44, 791, 8, 44, 1, 44, 3, 44, 794, 8, 44, 1, 44, 3, 44,
		797, 8, 44, 1, 44, 3, 44, 800, 8, 44, 1, 44, 3, 44, 803, 8, 44, 1, 44,
		3, 44, 806, 8, 44, 1, 44, 3, 44, 809, 8, 44, 1, 44, 3, 44, 812, 8, 44,
		1, 44, 3, 44, 815, 8, 44, 1, 44, 1, 44, 3, 44, 819, 8, 44, 1, 44, 3, 44,
		822, 8, 44, 1, 44, 3, 44, 825, 8, 44, 1, 44, 1, 44, 3, 44, 829, 8, 44,
		1, 45, 1, 45, 1, 45, 5, 45, 834, 8, 45, 10, 45, 12, 45, 837, 9, 45, 1,
		46, 1, 46, 1, 46, 3, 46, 842, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 48, 1, 48, 1, 48, 5, 48, 853, 8, 48, 10, 48, 12, 48, 856, 9,
		48, 1, 48, 1, 48, 3, 48, 860, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 5, 49, 880, 8, 49, 10, 49, 12, 49, 883, 9, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 892, 8, 49, 10, 49, 12,
		49, 895, 9, 49, 1, 49, 1, 49, 3, 49, 899, 8, 49, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 3, 50, 908, 8, 50, 1, 50, 3, 50, 911, 8, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 918, 8, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 3, 50, 925, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 3, 50, 933, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 946, 8, 50, 1, 50, 3, 50, 949, 8, 50,
		3, 50, 951, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3,
		51, 960, 8, 51, 1, 52, 3, 52, 963, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 3, 52, 971, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 977, 8,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 983, 8, 52, 1, 52, 1, 52, 1, 52,
		3, 52, 988, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 994, 8, 52, 3, 52,
		996, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1004, 8, 52,
		1, 52, 5, 52, 1007, 8, 52, 10, 52, 12, 52, 1010, 9, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1020, 8, 52, 1, 52, 3, 52,
		1023, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1030, 8, 52, 1,
		53, 1, 53, 1, 53, 3, 53, 1035, 8, 53, 1, 53, 3, 53, 1038, 8, 53, 1, 53,
		1, 53, 3, 53, 1042, 8, 53, 1, 53, 3, 53, 1045, 8, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 3, 53, 1051, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1057,
		8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1062, 8, 53, 1, 53, 1, 53, 3, 53, 1066,
		8, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1076,
		8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1086,
		8, 55, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5,
		57, 1097, 8, 57, 10, 57, 12, 57, 1100, 9, 57, 1, 57, 1, 57, 3, 57, 1104,
		8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57, 1111, 8, 57, 10, 57, 12,
		57, 1114, 9, 57, 1, 57, 1, 57, 3, 57, 1118, 8, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 5, 57, 1126, 8, 57, 10, 57, 12, 57, 1129, 9, 57, 1,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57, 1138, 8, 57, 10, 57,
		12, 57, 1141, 9, 57, 1, 57, 1, 57, 3, 57, 1145, 8, 57, 1, 57, 3, 57, 1148,
		8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3,
		57, 1159, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 1167,
		8, 58, 10, 58, 12, 58, 1170, 9, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 5, 58, 1180, 8, 58, 10, 58, 12, 58, 1183, 9, 58, 1,
		58, 1, 58, 3, 58, 1187, 8, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		5, 59, 1195, 8, 59, 10, 59, 12, 59, 1198, 9, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 5, 59, 1207, 8, 59, 10, 59, 12, 59, 1210, 9, 59,
		1, 59, 1, 59, 3, 59, 1214, 8, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1219, 8,
		59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 1228, 8, 60,
		10, 60, 12, 60, 1231, 9, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1237, 8,
		60, 1, 60, 1, 60, 3, 60, 1241, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 5, 61, 1249, 8, 61, 10, 61, 12, 61, 1252, 9, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 3, 61, 1259, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		5, 62, 1266, 8, 62, 10, 62, 12, 62, 1269, 9, 62, 1, 62, 1, 62, 1, 63, 1,
		63, 3, 63, 1275, 8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1280, 8, 63, 1, 63,
		3, 63, 1283, 8, 63, 1, 64, 3, 64, 1286, 8, 64, 1, 64, 1, 64, 1, 64, 3,
		64, 1291, 8, 64, 1, 64, 3, 64, 1294, 8, 64, 1, 64, 1, 64, 1, 65, 3, 65,
		1299, 8, 65, 1, 65, 1, 65, 3, 65, 1303, 8, 65, 1, 65, 1, 65, 1, 66, 1,
		66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 1314, 8, 67, 10, 67, 12,
		67, 1317, 9, 67, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1331, 8, 69, 1, 69, 1, 69, 3, 69, 1335,
		8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1345,
		8, 70, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 5, 74, 1363, 8, 74, 10, 74,
		12, 74, 1366, 9, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3,
		75, 1375, 8, 75, 1, 76, 1, 76, 1, 76, 3, 76, 1380, 8, 76, 1, 76, 3, 76,
		1383, 8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1389, 8, 76, 1, 76, 1,
		76, 1, 76, 1, 76, 1, 76, 5, 76, 1396, 8, 76, 10, 76, 12, 76, 1399, 9, 76,
		1, 76, 1, 76, 3, 76, 1403, 8, 76, 1, 76, 1, 76, 3, 76, 1407, 8, 76, 1,
		76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1417, 8, 77,
		1, 77, 1, 77, 1, 77, 3, 77, 1422, 8, 77, 1, 77, 3, 77, 1425, 8, 77, 1,
		77, 1, 77, 3, 77, 1429, 8, 77, 1, 78, 1, 78, 3, 78, 1433, 8, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 3, 78, 1439, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
		78, 1, 78, 1, 78, 5, 78, 1448, 8, 78, 10, 78, 12, 78, 1451, 9, 78, 1, 78,
		1, 78, 1, 79, 1, 79, 3, 79, 1457, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 3,
		80, 1463, 8, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1470, 8, 80,
		1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1477, 8, 80, 1, 80, 1, 80, 1,
		80, 1, 80, 1, 80, 3, 80, 1484, 8, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1489,
		8, 80, 3, 80, 1491, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 5,
		81, 1499, 8, 81, 10, 81, 12, 81, 1502, 9, 81, 1, 81, 1, 81, 1, 81, 1, 81,
		1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1516, 8,
		81, 1, 82, 1, 82, 3, 82, 1520, 8, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1525,
		8, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1530, 8, 82, 1, 82, 1, 82, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1541, 8, 82, 1, 82, 1, 82,
		1, 82, 3, 82, 1546, 8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82,
		3, 82, 1565, 8, 82, 1, 82, 1, 82, 3, 82, 1569, 8, 82, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 3, 83, 1606, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		3, 83, 1625, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 3, 83, 1659, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		3, 83, 1665, 8, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1670, 8, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 3, 83, 1676, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83,
		1682, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1690, 8,
		83, 1, 83, 1, 83, 1, 83, 3, 83, 1695, 8, 83, 5, 83, 1697, 8, 83, 10, 83,
		12, 83, 1700, 9, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1716, 8, 84, 1, 85,
		1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 1, 86, 3, 86, 1731, 8, 86, 1, 87, 1, 87, 3, 87, 1735, 8, 87, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 4, 87, 1742, 8, 87, 11, 87, 12, 87, 1743, 1,
		87, 1, 87, 3, 87, 1748, 8, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 3, 88,
		1755, 8, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1763, 8,
		88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89,
		5, 89, 1775, 8, 89, 10, 89, 12, 89, 1778, 9, 89, 3, 89, 1780, 8, 89, 1,
		89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1799, 8, 90, 1, 91, 1,
		91, 1, 91, 3, 91, 1804, 8, 91, 1, 91, 1, 91, 3, 91, 1808, 8, 91, 1, 91,
		1, 91, 3, 91, 1812, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1,
		91, 1, 91, 1, 91, 1, 91, 3, 91, 1824, 8, 91, 1, 92, 1, 92, 1, 92, 3, 92,
		1829, 8, 92, 1, 92, 3, 92, 1832, 8, 92, 1, 92, 3, 92, 1835, 8, 92, 1, 92,
		1, 92, 1, 92, 3, 92, 1840, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1,
		94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1854, 8, 94, 1, 95,
		1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1,
		95, 3, 95, 1868, 8, 95, 1, 96, 1, 96, 1, 96, 3, 96, 1873, 8, 96, 1, 96,
		1, 96, 1, 97, 1, 97, 1, 97, 5, 97, 1880, 8, 97, 10, 97, 12, 97, 1883, 9,
		97, 1, 98, 1, 98, 1, 98, 3, 98, 1888, 8, 98, 1, 98, 1, 98, 1, 99, 1, 99,
		1, 100, 1, 100, 1, 101, 1, 101, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103,
		1, 103, 1, 103, 3, 103, 1905, 8, 103, 1, 104, 1, 104, 1, 105, 1, 105, 1,
		105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 1919,
		8, 105, 3, 105, 1921, 8, 105, 1, 105, 0, 1, 166, 106, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
		206, 208, 210, 0, 28, 1, 0, 168, 171, 1, 0, 172, 173, 1, 0, 159, 160, 1,
		0, 149, 150, 2, 0, 141, 141, 148, 148, 2, 0, 149, 149, 165, 165, 2, 0,
		20, 20, 98, 98, 1, 0, 129, 130, 2, 0, 51, 53, 131, 131, 1, 0, 218, 222,
		2, 0, 223, 224, 227, 227, 1, 0, 225, 226, 1, 0, 228, 229, 1, 0, 230, 233,
		2, 0, 234, 236, 240, 240, 1, 0, 203, 205, 2, 0, 238, 239, 242, 242, 1,
		0, 51, 52, 1, 0, 29, 30, 1, 0, 251, 253, 1, 0, 249, 250, 1, 0, 255, 257,
		1, 0, 243, 248, 2, 0, 172, 172, 212, 213, 1, 0, 193, 195, 2, 0, 196, 196,
		198, 198, 1, 0, 141, 143, 12, 0, 1, 16, 19, 47, 49, 49, 51, 58, 66, 70,
		72, 79, 82, 82, 85, 104, 108, 125, 129, 134, 136, 174, 176, 242, 2184,
		0, 212, 1, 0, 0, 0, 2, 227, 1, 0, 0, 0, 4, 235, 1, 0, 0, 0, 6, 240, 1,
		0, 0, 0, 8, 242, 1, 0, 0, 0, 10, 244, 1, 0, 0, 0, 12, 281, 1, 0, 0, 0,
		14, 283, 1, 0, 0, 0, 16, 295, 1, 0, 0, 0, 18, 314, 1, 0, 0, 0, 20, 324,
		1, 0, 0, 0, 22, 344, 1, 0, 0, 0, 24, 346, 1, 0, 0, 0, 26, 349, 1, 0, 0,
		0, 28, 357, 1, 0, 0, 0, 30, 416, 1, 0, 0, 0, 32, 418, 1, 0, 0, 0, 34, 434,
		1, 0, 0, 0, 36, 465, 1, 0, 0, 0, 38, 486, 1, 0, 0, 0, 40, 488, 1, 0, 0,
		0, 42, 491, 1, 0, 0, 0, 44, 495, 1, 0, 0, 0, 46, 510, 1, 0, 0, 0, 48, 512,
		1, 0, 0, 0, 50, 515, 1, 0, 0, 0, 52, 525, 1, 0, 0, 0, 54, 557, 1, 0, 0,
		0, 56, 559, 1, 0, 0, 0, 58, 580, 1, 0, 0, 0, 60, 592, 1, 0, 0, 0, 62, 597,
		1, 0, 0, 0, 64, 608, 1, 0, 0, 0, 66, 617, 1, 0, 0, 0, 68, 621, 1, 0, 0,
		0, 70, 633, 1, 0, 0, 0, 72, 656, 1, 0, 0, 0, 74, 660, 1, 0, 0, 0, 76, 672,
		1, 0, 0, 0, 78, 678, 1, 0, 0, 0, 80, 727, 1, 0, 0, 0, 82, 729, 1, 0, 0,
		0, 84, 739, 1, 0, 0, 0, 86, 752, 1, 0, 0, 0, 88, 754, 1, 0, 0, 0, 90, 830,
		1, 0, 0, 0, 92, 841, 1, 0, 0, 0, 94, 843, 1, 0, 0, 0, 96, 849, 1, 0, 0,
		0, 98, 898, 1, 0, 0, 0, 100, 950, 1, 0, 0, 0, 102, 959, 1, 0, 0, 0, 104,
		1029, 1, 0, 0, 0, 106, 1031, 1, 0, 0, 0, 108, 1075, 1, 0, 0, 0, 110, 1085,
		1, 0, 0, 0, 112, 1087, 1, 0, 0, 0, 114, 1158, 1, 0, 0, 0, 116, 1186, 1,
		0, 0, 0, 118, 1188, 1, 0, 0, 0, 120, 1220, 1, 0, 0, 0, 122, 1258, 1, 0,
		0, 0, 124, 1260, 1, 0, 0, 0, 126, 1272, 1, 0, 0, 0, 128, 1285, 1, 0, 0,
		0, 130, 1298, 1, 0, 0, 0, 132, 1306, 1, 0, 0, 0, 134, 1309, 1, 0, 0, 0,
		136, 1318, 1, 0, 0, 0, 138, 1334, 1, 0, 0, 0, 140, 1344, 1, 0, 0, 0, 142,
		1346, 1, 0, 0, 0, 144, 1349, 1, 0, 0, 0, 146, 1354, 1, 0, 0, 0, 148, 1359,
		1, 0, 0, 0, 150, 1374, 1, 0, 0, 0, 152, 1376, 1, 0, 0, 0, 154, 1411, 1,
		0, 0, 0, 156, 1430, 1, 0, 0, 0, 158, 1454, 1, 0, 0, 0, 160, 1490, 1, 0,
		0, 0, 162, 1515, 1, 0, 0, 0, 164, 1568, 1, 0, 0, 0, 166, 1605, 1, 0, 0,
		0, 168, 1715, 1, 0, 0, 0, 170, 1717, 1, 0, 0, 0, 172, 1730, 1, 0, 0, 0,
		174, 1732, 1, 0, 0, 0, 176, 1762, 1, 0, 0, 0, 178, 1764, 1, 0, 0, 0, 180,
		1798, 1, 0, 0, 0, 182, 1823, 1, 0, 0, 0, 184, 1839, 1, 0, 0, 0, 186, 1841,
		1, 0, 0, 0, 188, 1853, 1, 0, 0, 0, 190, 1867, 1, 0, 0, 0, 192, 1872, 1,
		0, 0, 0, 194, 1876, 1, 0, 0, 0, 196, 1887, 1, 0, 0, 0, 198, 1891, 1, 0,
		0, 0, 200, 1893, 1, 0, 0, 0, 202, 1895, 1, 0, 0, 0, 204, 1897, 1, 0, 0,
		0, 206, 1904, 1, 0, 0, 0, 208, 1906, 1, 0, 0, 0, 210, 1920, 1, 0, 0, 0,
		212, 217, 3, 2, 1, 0, 213, 214, 5, 273, 0, 0, 214, 216, 3, 2, 1, 0, 215,
		213, 1, 0, 0, 0, 216, 219, 1, 0, 0, 0, 217, 215, 1, 0, 0, 0, 217, 218,
		1, 0, 0, 0, 218, 221, 1, 0, 0, 0, 219, 217, 1, 0, 0, 0, 220, 222, 5, 273,
		0, 0, 221, 220, 1, 0, 0, 0, 221, 222, 1, 0, 0, 0, 222, 223, 1, 0, 0, 0,
		223, 224, 5, 0, 0, 1, 224, 1, 1, 0, 0, 0, 225, 228, 3, 4, 2, 0, 226, 228,
		3, 6, 3, 0, 227, 225, 1, 0, 0, 0, 227, 226, 1, 0, 0, 0, 228, 3, 1, 0, 0,
		0, 229, 236, 3, 8, 4, 0, 230, 236, 3, 56, 28, 0, 231, 236, 3, 70, 35, 0,
		232, 236, 3, 74, 37, 0, 233, 236, 3, 78, 39, 0, 234, 236, 3, 76, 38, 0,
		235, 229, 1, 0, 0, 0, 235, 230, 1, 0, 0, 0, 235, 231, 1, 0, 0, 0, 235,
		232, 1, 0, 0, 0, 235, 233, 1, 0, 0, 0, 235, 234, 1, 0, 0, 0, 236, 5, 1,
		0, 0, 0, 237, 241, 3, 86, 43, 0, 238, 241, 3, 160, 80, 0, 239, 241, 3,
		162, 81, 0, 240, 237, 1, 0, 0, 0, 240, 238, 1, 0, 0, 0, 240, 239, 1, 0,
		0, 0, 241, 7, 1, 0, 0, 0, 242, 243, 3, 10, 5, 0, 243, 9, 1, 0, 0, 0, 244,
		252, 3, 12, 6, 0, 245, 247, 7, 0, 0, 0, 246, 248, 5, 172, 0, 0, 247, 246,
		1, 0, 0, 0, 247, 248, 1, 0, 0, 0, 248, 249, 1, 0, 0, 0, 249, 251, 3, 12,
		6, 0, 250, 245, 1, 0, 0, 0, 251, 254, 1, 0, 0, 0, 252, 250, 1, 0, 0, 0,
		252, 253, 1, 0, 0, 0, 253, 11, 1, 0, 0, 0, 254, 252, 1, 0, 0, 0, 255, 257,
		3, 14, 7, 0, 256, 255, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 258, 1, 0,
		0, 0, 258, 260, 3, 18, 9, 0, 259, 261, 3, 24, 12, 0, 260, 259, 1, 0, 0,
		0, 260, 261, 1, 0, 0, 0, 261, 263, 1, 0, 0, 0, 262, 264, 3, 40, 20, 0,
		263, 262, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 266, 1, 0, 0, 0, 265,
		267, 3, 42, 21, 0, 266, 265, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 269,
		1, 0, 0, 0, 268, 270, 3, 48, 24, 0, 269, 268, 1, 0, 0, 0, 269, 270, 1,
		0, 0, 0, 270, 272, 1, 0, 0, 0, 271, 273, 3, 50, 25, 0, 272, 271, 1, 0,
		0, 0, 272, 273, 1, 0, 0, 0, 273, 275, 1, 0, 0, 0, 274, 276, 3, 54, 27,
		0, 275, 274, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 282, 1, 0, 0, 0, 277,
		278, 5, 265, 0, 0, 278, 279, 3, 10, 5, 0, 279, 280, 5, 266, 0, 0, 280,
		282, 1, 0, 0, 0, 281, 256, 1, 0, 0, 0, 281, 277, 1, 0, 0, 0, 282, 13, 1,
		0, 0, 0, 283, 285, 5, 174, 0, 0, 284, 286, 5, 176, 0, 0, 285, 284, 1, 0,
		0, 0, 285, 286, 1, 0, 0, 0, 286, 287, 1, 0, 0, 0, 287, 292, 3, 16, 8, 0,
		288, 289, 5, 271, 0, 0, 289, 291, 3, 16, 8, 0, 290, 288, 1, 0, 0, 0, 291,
		294, 1, 0, 0, 0, 292, 290, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0, 293, 15, 1,
		0, 0, 0, 294, 292, 1, 0, 0, 0, 295, 307, 3, 206, 103, 0, 296, 297, 5, 265,
		0, 0, 297, 302, 3, 206, 103, 0, 298, 299, 5, 271, 0, 0, 299, 301, 3, 206,
		103, 0, 300, 298, 1, 0, 0, 0, 301, 304, 1, 0, 0, 0, 302, 300, 1, 0, 0,
		0, 302, 303, 1, 0, 0, 0, 303, 305, 1, 0, 0, 0, 304, 302, 1, 0, 0, 0, 305,
		306, 5, 266, 0, 0, 306, 308, 1, 0, 0, 0, 307, 296, 1, 0, 0, 0, 307, 308,
		1, 0, 0, 0, 308, 309, 1, 0, 0, 0, 309, 310, 5, 7, 0, 0, 310, 311, 5, 265,
		0, 0, 311, 312, 3, 8, 4, 0, 312, 313, 5, 266, 0, 0, 313, 17, 1, 0, 0, 0,
		314, 316, 5, 1, 0, 0, 315, 317, 7, 1, 0, 0, 316, 315, 1, 0, 0, 0, 316,
		317, 1, 0, 0, 0, 317, 320, 1, 0, 0, 0, 318, 319, 5, 167, 0, 0, 319, 321,
		3, 166, 83, 0, 320, 318, 1, 0, 0, 0, 320, 321, 1, 0, 0, 0, 321, 322, 1,
		0, 0, 0, 322, 323, 3, 20, 10, 0, 323, 19, 1, 0, 0, 0, 324, 329, 3, 22,
		11, 0, 325, 326, 5, 271, 0, 0, 326, 328, 3, 22, 11, 0, 327, 325, 1, 0,
		0, 0, 328, 331, 1, 0, 0, 0, 329, 327, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0,
		330, 21, 1, 0, 0, 0, 331, 329, 1, 0, 0, 0, 332, 345, 5, 251, 0, 0, 333,
		334, 3, 196, 98, 0, 334, 335, 5, 272, 0, 0, 335, 336, 5, 251, 0, 0, 336,
		345, 1, 0, 0, 0, 337, 342, 3, 166, 83, 0, 338, 340, 5, 7, 0, 0, 339, 338,
		1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 341, 1, 0, 0, 0, 341, 343, 3, 204,
		102, 0, 342, 339, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 345, 1, 0, 0,
		0, 344, 332, 1, 0, 0, 0, 344, 333, 1, 0, 0, 0, 344, 337, 1, 0, 0, 0, 345,
		23, 1, 0, 0, 0, 346, 347, 5, 2, 0, 0, 347, 348, 3, 26, 13, 0, 348, 25,
		1, 0, 0, 0, 349, 354, 3, 28, 14, 0, 350, 351, 5, 271, 0, 0, 351, 353, 3,
		28, 14, 0, 352, 350, 1, 0, 0, 0, 353, 356, 1, 0, 0, 0, 354, 352, 1, 0,
		0, 0, 354, 355, 1, 0, 0, 0, 355, 27, 1, 0, 0, 0, 356, 354, 1, 0, 0, 0,
		357, 361, 3, 30, 15, 0, 358, 360, 3, 34, 17, 0, 359, 358, 1, 0, 0, 0, 360,
		363, 1, 0, 0, 0, 361, 359, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0, 362, 29, 1,
		0, 0, 0, 363, 361, 1, 0, 0, 0, 364, 366, 3, 196, 98, 0, 365, 367, 3, 36,
		18, 0, 366, 365, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 372, 1, 0, 0, 0,
		368, 370, 5, 7, 0, 0, 369, 368, 1, 0, 0, 0, 369, 370, 1, 0, 0, 0, 370,
		371, 1, 0, 0, 0, 371, 373, 3, 204, 102, 0, 372, 369, 1, 0, 0, 0, 372, 373,
		1, 0, 0, 0, 373, 375, 1, 0, 0, 0, 374, 376, 3, 32, 16, 0, 375, 374, 1,
		0, 0, 0, 375, 376, 1, 0, 0, 0, 376, 417, 1, 0, 0, 0, 377, 378, 5, 265,
		0, 0, 378, 379, 3, 8, 4, 0, 379, 384, 5, 266, 0, 0, 380, 382, 5, 7, 0,
		0, 381, 380, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383,
		385, 3, 204, 102, 0, 384, 381, 1, 0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 417,
		1, 0, 0, 0, 386, 387, 5, 102, 0, 0, 387, 388, 5, 265, 0, 0, 388, 389, 3,
		8, 4, 0, 389, 394, 5, 266, 0, 0, 390, 392, 5, 7, 0, 0, 391, 390, 1, 0,
		0, 0, 391, 392, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 395, 3, 204, 102,
		0, 394, 391, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 417, 1, 0, 0, 0, 396,
		397, 5, 103, 0, 0, 397, 398, 5, 265, 0, 0, 398, 399, 3, 166, 83, 0, 399,
		404, 5, 266, 0, 0, 400, 402, 5, 7, 0, 0, 401, 400, 1, 0, 0, 0, 401, 402,
		1, 0, 0, 0, 402, 403, 1, 0, 0, 0, 403, 405, 3, 204, 102, 0, 404, 401, 1,
		0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 417, 1, 0, 0, 0, 406, 407, 3, 196,
		98, 0, 407, 408, 5, 265, 0, 0, 408, 409, 3, 194, 97, 0, 409, 414, 5, 266,
		0, 0, 410, 412, 5, 7, 0, 0, 411, 410, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0,
		412, 413, 1, 0, 0, 0, 413, 415, 3, 204, 102, 0, 414, 411, 1, 0, 0, 0, 414,
		415, 1, 0, 0, 0, 415, 417, 1, 0, 0, 0, 416, 364, 1, 0, 0, 0, 416, 377,
		1, 0, 0, 0, 416, 386, 1, 0, 0, 0, 416, 396, 1, 0, 0, 0, 416, 406, 1, 0,
		0, 0, 417, 31, 1, 0, 0, 0, 418, 419, 5, 108, 0, 0, 419, 429, 5, 265, 0,
		0, 420, 421, 5, 278, 0, 0, 421, 430, 5, 109, 0, 0, 422, 423, 5, 278, 0,
		0, 423, 430, 5, 141, 0, 0, 424, 425, 5, 110, 0, 0, 425, 426, 5, 278, 0,
		0, 426, 427, 5, 111, 0, 0, 427, 428, 5, 112, 0, 0, 428, 430, 5, 278, 0,
		0, 429, 420, 1, 0, 0, 0, 429, 422, 1, 0, 0, 0, 429, 424, 1, 0, 0, 0, 430,
		431, 1, 0, 0, 0, 431, 432, 5, 266, 0, 0, 432, 33, 1, 0, 0, 0, 433, 435,
		3, 38, 19, 0, 434, 433, 1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435, 436, 1,
		0, 0, 0, 436, 437, 5, 9, 0, 0, 437, 452, 3, 30, 15, 0, 438, 439, 5, 8,
		0, 0, 439, 453, 3, 166, 83, 0, 440, 441, 5, 95, 0, 0, 441, 442, 5, 265,
		0, 0, 442, 447, 3, 206, 103, 0, 443, 444, 5, 271, 0, 0, 444, 446, 3, 206,
		103, 0, 445, 443, 1, 0, 0, 0, 446, 449, 1, 0, 0, 0, 447, 445, 1, 0, 0,
		0, 447, 448, 1, 0, 0, 0, 448, 450, 1, 0, 0, 0, 449, 447, 1, 0, 0, 0, 450,
		451, 5, 266, 0, 0, 451, 453, 1, 0, 0, 0, 452, 438, 1, 0, 0, 0, 452, 440,
		1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 35, 1, 0, 0, 0, 454, 455, 5, 74,
		0, 0, 455, 456, 5, 75, 0, 0, 456, 457, 5, 7, 0, 0, 457, 458, 5, 112, 0,
		0, 458, 466, 3, 166, 83, 0, 459, 460, 5, 74, 0, 0, 460, 461, 5, 76, 0,
		0, 461, 462, 5, 203, 0, 0, 462, 463, 5, 7, 0, 0, 463, 464, 5, 112, 0, 0,
		464, 466, 3, 166, 83, 0, 465, 454, 1, 0, 0, 0, 465, 459, 1, 0, 0, 0, 466,
		37, 1, 0, 0, 0, 467, 487, 5, 10, 0, 0, 468, 470, 5, 11, 0, 0, 469, 471,
		5, 13, 0, 0, 470, 469, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471, 487, 1, 0,
		0, 0, 472, 474, 5, 12, 0, 0, 473, 475, 5, 13, 0, 0, 474, 473, 1, 0, 0,
		0, 474, 475, 1, 0, 0, 0, 475, 487, 1, 0, 0, 0, 476, 478, 5, 15, 0, 0, 477,
		479, 5, 13, 0, 0, 478, 477, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 487,
		1, 0, 0, 0, 480, 487, 5, 14, 0, 0, 481, 487, 5, 16, 0, 0, 482, 483, 5,
		11, 0, 0, 483, 487, 5, 17, 0, 0, 484, 485, 5, 11, 0, 0, 485, 487, 5, 18,
		0, 0, 486, 467, 1, 0, 0, 0, 486, 468, 1, 0, 0, 0, 486, 472, 1, 0, 0, 0,
		486, 476, 1, 0, 0, 0, 486, 480, 1, 0, 0, 0, 486, 481, 1, 0, 0, 0, 486,
		482, 1, 0, 0, 0, 486, 484, 1, 0, 0, 0, 487, 39, 1, 0, 0, 0, 488, 489, 5,
		3, 0, 0, 489, 490, 3, 166, 83, 0, 490, 41, 1, 0, 0, 0, 491, 492, 5, 156,
		0, 0, 492, 493, 5, 157, 0, 0, 493, 494, 3, 44, 22, 0, 494, 43, 1, 0, 0,
		0, 495, 500, 3, 46, 23, 0, 496, 497, 5, 271, 0, 0, 497, 499, 3, 46, 23,
		0, 498, 496, 1, 0, 0, 0, 499, 502, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 500,
		501, 1, 0, 0, 0, 501, 45, 1, 0, 0, 0, 502, 500, 1, 0, 0, 0, 503, 511, 3,
		166, 83, 0, 504, 505, 5, 265, 0, 0, 505, 511, 5, 266, 0, 0, 506, 507, 5,
		265, 0, 0, 507, 508, 3, 194, 97, 0, 508, 509, 5, 266, 0, 0, 509, 511, 1,
		0, 0, 0, 510, 503, 1, 0, 0, 0, 510, 504, 1, 0, 0, 0, 510, 506, 1, 0, 0,
		0, 511, 47, 1, 0, 0, 0, 512, 513, 5, 161, 0, 0, 513, 514, 3, 166, 83, 0,
		514, 49, 1, 0, 0, 0, 515, 516, 5, 158, 0, 0, 516, 517, 5, 157, 0, 0, 517,
		522, 3, 52, 26, 0, 518, 519, 5, 271, 0, 0, 519, 521, 3, 52, 26, 0, 520,
		518, 1, 0, 0, 0, 521, 524, 1, 0, 0, 0, 522, 520, 1, 0, 0, 0, 522, 523,
		1, 0, 0, 0, 523, 51, 1, 0, 0, 0, 524, 522, 1, 0, 0, 0, 525, 527, 3, 166,
		83, 0, 526, 528, 7, 2, 0, 0, 527, 526, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0,
		528, 531, 1, 0, 0, 0, 529, 530, 5, 151, 0, 0, 530, 532, 7, 3, 0, 0, 531,
		529, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 53, 1, 0, 0, 0, 533, 534, 5,
		162, 0, 0, 534, 537, 3, 166, 83, 0, 535, 536, 5, 163, 0, 0, 536, 538, 3,
		166, 83, 0, 537, 535, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 558, 1, 0,
		0, 0, 539, 540, 5, 162, 0, 0, 540, 541, 3, 166, 83, 0, 541, 542, 5, 271,
		0, 0, 542, 543, 3, 166, 83, 0, 543, 558, 1, 0, 0, 0, 544, 545, 5, 163,
		0, 0, 545, 547, 3, 166, 83, 0, 546, 548, 7, 4, 0, 0, 547, 546, 1, 0, 0,
		0, 547, 548, 1, 0, 0, 0, 548, 555, 1, 0, 0, 0, 549, 550, 5, 164, 0, 0,
		550, 551, 7, 5, 0, 0, 551, 552, 3, 166, 83, 0, 552, 553, 7, 4, 0, 0, 553,
		554, 5, 166, 0, 0, 554, 556, 1, 0, 0, 0, 555, 549, 1, 0, 0, 0, 555, 556,
		1, 0, 0, 0, 556, 558, 1, 0, 0, 0, 557, 533, 1, 0, 0, 0, 557, 539, 1, 0,
		0, 0, 557, 544, 1, 0, 0, 0, 558, 55, 1, 0, 0, 0, 559, 561, 5, 19, 0, 0,
		560, 562, 7, 6, 0, 0, 561, 560, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562,
		564, 1, 0, 0, 0, 563, 565, 5, 27, 0, 0, 564, 563, 1, 0, 0, 0, 564, 565,
		1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 568, 3, 196, 98, 0, 567, 569, 3,
		58, 29, 0, 568, 567, 1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569, 571, 1, 0,
		0, 0, 570, 572, 3, 62, 31, 0, 571, 570, 1, 0, 0, 0, 571, 572, 1, 0, 0,
		0, 572, 575, 1, 0, 0, 0, 573, 576, 3, 8, 4, 0, 574, 576, 3, 64, 32, 0,
		575, 573, 1, 0, 0, 0, 575, 574, 1, 0, 0, 0, 576, 578, 1, 0, 0, 0, 577,
		579, 3, 68, 34, 0, 578, 577, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 57,
		1, 0, 0, 0, 580, 581, 5, 140, 0, 0, 581, 582, 5, 265, 0, 0, 582, 587, 3,
		60, 30, 0, 583, 584, 5, 271, 0, 0, 584, 586, 3, 60, 30, 0, 585, 583, 1,
		0, 0, 0, 586, 589, 1, 0, 0, 0, 587, 585, 1, 0, 0, 0, 587, 588, 1, 0, 0,
		0, 588, 590, 1, 0, 0, 0, 589, 587, 1, 0, 0, 0, 590, 591, 5, 266, 0, 0,
		591, 59, 1, 0, 0, 0, 592, 595, 3, 206, 103, 0, 593, 594, 5, 243, 0, 0,
		594, 596, 3, 166, 83, 0, 595, 593, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596,
		61, 1, 0, 0, 0, 597, 598, 5, 265, 0, 0, 598, 603, 3, 206, 103, 0, 599,
		600, 5, 271, 0, 0, 600, 602, 3, 206, 103, 0, 601, 599, 1, 0, 0, 0, 602,
		605, 1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 606,
		1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 606, 607, 5, 266, 0, 0, 607, 63, 1, 0,
		0, 0, 608, 609, 5, 21, 0, 0, 609, 614, 3, 66, 33, 0, 610, 611, 5, 271,
		0, 0, 611, 613, 3, 66, 33, 0, 612, 610, 1, 0, 0, 0, 613, 616, 1, 0, 0,
		0, 614, 612, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615, 65, 1, 0, 0, 0, 616,
		614, 1, 0, 0, 0, 617, 618, 5, 265, 0, 0, 618, 619, 3, 194, 97, 0, 619,
		620, 5, 266, 0, 0, 620, 67, 1, 0, 0, 0, 621, 622, 5, 8, 0, 0, 622, 623,
		5, 101, 0, 0, 623, 624, 5, 42, 0, 0, 624, 625, 5, 22, 0, 0, 625, 630, 3,
		72, 36, 0, 626, 627, 5, 271, 0, 0, 627, 629, 3, 72, 36, 0, 628, 626, 1,
		0, 0, 0, 629, 632, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630, 631, 1, 0, 0,
		0, 631, 69, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 633, 634, 5, 22, 0, 0, 634,
		639, 3, 196, 98, 0, 635, 637, 5, 7, 0, 0, 636, 635, 1, 0, 0, 0, 636, 637,
		1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638, 640, 3, 204, 102, 0, 639, 636, 1,
		0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 642, 5, 23, 0,
		0, 642, 647, 3, 72, 36, 0, 643, 644, 5, 271, 0, 0, 644, 646, 3, 72, 36,
		0, 645, 643, 1, 0, 0, 0, 646, 649, 1, 0, 0, 0, 647, 645, 1, 0, 0, 0, 647,
		648, 1, 0, 0, 0, 648, 651, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 650, 652,
		3, 24, 12, 0, 651, 650, 1, 0, 0, 0, 651, 652, 1, 0, 0, 0, 652, 654, 1,
		0, 0, 0, 653, 655, 3, 40, 20, 0, 654, 653, 1, 0, 0, 0, 654, 655, 1, 0,
		0, 0, 655, 71, 1, 0, 0, 0, 656, 657, 3, 192, 96, 0, 657, 658, 5, 243, 0,
		0, 658, 659, 3, 166, 83, 0, 659, 73, 1, 0, 0, 0, 660, 661, 5, 24, 0, 0,
		661, 662, 5, 2, 0, 0, 662, 667, 3, 196, 98, 0, 663, 665, 5, 7, 0, 0, 664,
		663, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666, 668,
		3, 204, 102, 0, 667, 664, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 670, 1,
		0, 0, 0, 669, 671, 3, 40, 20, 0, 670, 669, 1, 0, 0, 0, 670, 671, 1, 0,
		0, 0, 671, 75, 1, 0, 0, 0, 672, 674, 5, 25, 0, 0, 673, 675, 5, 27, 0, 0,
		674, 673, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676,
		677, 3, 196, 98, 0, 677, 77, 1, 0, 0, 0, 678, 679, 5, 94, 0, 0, 679, 680,
		5, 20, 0, 0, 680, 685, 3, 196, 98, 0, 681, 683, 5, 7, 0, 0, 682, 681, 1,
		0, 0, 0, 682, 683, 1, 0, 0, 0, 683, 684, 1, 0, 0, 0, 684, 686, 3, 204,
		102, 0, 685, 682, 1, 0, 0, 0, 685, 686, 1, 0, 0, 0, 686, 687, 1, 0, 0,
		0, 687, 688, 5, 95, 0, 0, 688, 693, 3, 28, 14, 0, 689, 691, 5, 7, 0, 0,
		690, 689, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 692, 1, 0, 0, 0, 692,
		694, 3, 204, 102, 0, 693, 690, 1, 0, 0, 0, 693, 694, 1, 0, 0, 0, 694, 695,
		1, 0, 0, 0, 695, 696, 5, 8, 0, 0, 696, 698, 3, 166, 83, 0, 697, 699, 3,
		80, 40, 0, 698, 697, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 698, 1, 0,
		0, 0, 700, 701, 1, 0, 0, 0, 701, 79, 1, 0, 0, 0, 702, 703, 5, 178, 0, 0,
		703, 706, 5, 96, 0, 0, 704, 705, 5, 4, 0, 0, 705, 707, 3, 166, 83, 0, 706,
		704, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 708, 1, 0, 0, 0, 708, 709,
		5, 179, 0, 0, 709, 728, 3, 82, 41, 0, 710, 711, 5, 178, 0, 0, 711, 714,
		5, 96, 0, 0, 712, 713, 5, 4, 0, 0, 713, 715, 3, 166, 83, 0, 714, 712, 1,
		0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 717, 5, 179,
		0, 0, 717, 728, 5, 24, 0, 0, 718, 719, 5, 178, 0, 0, 719, 720, 5, 6, 0,
		0, 720, 723, 5, 96, 0, 0, 721, 722, 5, 4, 0, 0, 722, 724, 3, 166, 83, 0,
		723, 721, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725,
		726, 5, 179, 0, 0, 726, 728, 3, 84, 42, 0, 727, 702, 1, 0, 0, 0, 727, 710,
		1, 0, 0, 0, 727, 718, 1, 0, 0, 0, 728, 81, 1, 0, 0, 0, 729, 730, 5, 22,
		0, 0, 730, 731, 5, 23, 0, 0, 731, 736, 3, 72, 36, 0, 732, 733, 5, 271,
		0, 0, 733, 735, 3, 72, 36, 0, 734, 732, 1, 0, 0, 0, 735, 738, 1, 0, 0,
		0, 736, 734, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 83, 1, 0, 0, 0, 738,
		736, 1, 0, 0, 0, 739, 741, 5, 19, 0, 0, 740, 742, 3, 62, 31, 0, 741, 740,
		1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 744, 5, 21,
		0, 0, 744, 745, 5, 265, 0, 0, 745, 746, 3, 194, 97, 0, 746, 747, 5, 266,
		0, 0, 747, 85, 1, 0, 0, 0, 748, 753, 3, 88, 44, 0, 749, 753, 3, 152, 76,
		0, 750, 753, 3, 154, 77, 0, 751, 753, 3, 156, 78, 0, 752, 748, 1, 0, 0,
		0, 752, 749, 1, 0, 0, 0, 752, 750, 1, 0, 0, 0, 752, 751, 1, 0, 0, 0, 753,
		87, 1, 0, 0, 0, 754, 756, 5, 26, 0, 0, 755, 757, 7, 7, 0, 0, 756, 755,
		1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 759, 1, 0, 0, 0, 758, 760, 7, 8,
		0, 0, 759, 758, 1, 0, 0, 0, 759, 760, 1, 0, 0, 0, 760, 761, 1, 0, 0, 0,
		761, 765, 5, 27, 0, 0, 762, 763, 5, 50, 0, 0, 763, 764, 5, 6, 0, 0, 764,
		766, 5, 192, 0, 0, 765, 762, 1, 0, 0, 0, 765, 766, 1, 0, 0, 0, 766, 767,
		1, 0, 0, 0, 767, 772, 3, 196, 98, 0, 768, 769, 5, 265, 0, 0, 769, 770,
		3, 90, 45, 0, 770, 771, 5, 266, 0, 0, 771, 773, 1, 0, 0, 0, 772, 768, 1,
		0, 0, 0, 772, 773, 1, 0, 0, 0, 773, 775, 1, 0, 0, 0, 774, 776, 3, 124,
		62, 0, 775, 774, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 778, 1, 0, 0, 0,
		777, 779, 3, 116, 58, 0, 778, 777, 1, 0, 0, 0, 778, 779, 1, 0, 0, 0, 779,
		781, 1, 0, 0, 0, 780, 782, 3, 120, 60, 0, 781, 780, 1, 0, 0, 0, 781, 782,
		1, 0, 0, 0, 782, 784, 1, 0, 0, 0, 783, 785, 3, 118, 59, 0, 784, 783, 1,
		0, 0, 0, 784, 785, 1, 0, 0, 0, 785, 787, 1, 0, 0, 0, 786, 788, 3, 122,
		61, 0, 787, 786, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0, 788, 790, 1, 0, 0, 0,
		789, 791, 3, 138, 69, 0, 790, 789, 1, 0, 0, 0, 790, 791, 1, 0, 0, 0, 791,
		793, 1, 0, 0, 0, 792, 794, 3, 140, 70, 0, 793, 792, 1, 0, 0, 0, 793, 794,
		1, 0, 0, 0, 794, 796, 1, 0, 0, 0, 795, 797, 3, 142, 71, 0, 796, 795, 1,
		0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 799, 1, 0, 0, 0, 798, 800, 3, 126,
		63, 0, 799, 798, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 802, 1, 0, 0, 0,
		801, 803, 3, 144, 72, 0, 802, 801, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 803,
		805, 1, 0, 0, 0, 804, 806, 3, 146, 73, 0, 805, 804, 1, 0, 0, 0, 805, 806,
		1, 0, 0, 0, 806, 808, 1, 0, 0, 0, 807, 809, 3, 128, 64, 0, 808, 807, 1,
		0, 0, 0, 808, 809, 1, 0, 0, 0, 809, 811, 1, 0, 0, 0, 810, 812, 3, 130,
		65, 0, 811, 810, 1, 0, 0, 0, 811, 812, 1, 0, 0, 0, 812, 814, 1, 0, 0, 0,
		813, 815, 3, 132, 66, 0, 814, 813, 1, 0, 0, 0, 814, 815, 1, 0, 0, 0, 815,
		818, 1, 0, 0, 0, 816, 817, 5, 49, 0, 0, 817, 819, 5, 276, 0, 0, 818, 816,
		1, 0, 0, 0, 818, 819, 1, 0, 0, 0, 819, 821, 1, 0, 0, 0, 820, 822, 3, 134,
		67, 0, 821, 820, 1, 0, 0, 0, 821, 822, 1, 0, 0, 0, 822, 824, 1, 0, 0, 0,
		823, 825, 3, 136, 68, 0, 824, 823, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825,
		828, 1, 0, 0, 0, 826, 827, 5, 7, 0, 0, 827, 829, 3, 8, 4, 0, 828, 826,
		1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 89, 1, 0, 0, 0, 830, 835, 3, 92,
		46, 0, 831, 832, 5, 271, 0, 0, 832, 834, 3, 92, 46, 0, 833, 831, 1, 0,
		0, 0, 834, 837, 1, 0, 0, 0, 835, 833, 1, 0, 0, 0, 835, 836, 1, 0, 0, 0,
		836, 91, 1, 0, 0, 0, 837, 835, 1, 0, 0, 0, 838, 842, 3, 94, 47, 0, 839,
		842, 3, 114, 57, 0, 840, 842, 3, 96, 48, 0, 841, 838, 1, 0, 0, 0, 841,
		839, 1, 0, 0, 0, 841, 840, 1, 0, 0, 0, 842, 93, 1, 0, 0, 0, 843, 844, 5,
		73, 0, 0, 844, 845, 5, 74, 0, 0, 845, 846, 3, 206, 103, 0, 846, 847, 5,
		7, 0, 0, 847, 848, 3, 166, 83, 0, 848, 95, 1, 0, 0, 0, 849, 850, 3, 206,
		103, 0, 850, 854, 3, 98, 49, 0, 851, 853, 3, 104, 52, 0, 852, 851, 1, 0,
		0, 0, 853, 856, 1, 0, 0, 0, 854, 852, 1, 0, 0, 0, 854, 855, 1, 0, 0, 0,
		855, 859, 1, 0, 0, 0, 856, 854, 1, 0, 0, 0, 857, 858, 5, 49, 0, 0, 858,
		860, 5, 276, 0, 0, 859, 857, 1, 0, 0, 0, 859, 860, 1, 0, 0, 0, 860, 97,
		1, 0, 0, 0, 861, 899, 3, 100, 50, 0, 862, 863, 5, 214, 0, 0, 863, 864,
		5, 245, 0, 0, 864, 865, 3, 98, 49, 0, 865, 866, 5, 247, 0, 0, 866, 899,
		1, 0, 0, 0, 867, 868, 5, 215, 0, 0, 868, 869, 5, 245, 0, 0, 869, 870, 3,
		98, 49, 0, 870, 871, 5, 271, 0, 0, 871, 872, 3, 98, 49, 0, 872, 873, 5,
		247, 0, 0, 873, 899, 1, 0, 0, 0, 874, 875, 5, 216, 0, 0, 875, 876, 5, 245,
		0, 0, 876, 881, 3, 102, 51, 0, 877, 878, 5, 271, 0, 0, 878, 880, 3, 102,
		51, 0, 879, 877, 1, 0, 0, 0, 880, 883, 1, 0, 0, 0, 881, 879, 1, 0, 0, 0,
		881, 882, 1, 0, 0, 0, 882, 884, 1, 0, 0, 0, 883, 881, 1, 0, 0, 0, 884,
		885, 5, 247, 0, 0, 885, 899, 1, 0, 0, 0, 886, 887, 5, 148, 0, 0, 887, 888,
		5, 265, 0, 0, 888, 893, 3, 102, 51, 0, 889, 890, 5, 271, 0, 0, 890, 892,
		3, 102, 51, 0, 891, 889, 1, 0, 0, 0, 892, 895, 1, 0, 0, 0, 893, 891, 1,
		0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 896, 1, 0, 0, 0, 895, 893, 1, 0, 0,
		0, 896, 897, 5, 266, 0, 0, 897, 899, 1, 0, 0, 0, 898, 861, 1, 0, 0, 0,
		898, 862, 1, 0, 0, 0, 898, 867, 1, 0, 0, 0, 898, 874, 1, 0, 0, 0, 898,
		886, 1, 0, 0, 0, 899, 99, 1, 0, 0, 0, 900, 951, 7, 9, 0, 0, 901, 951, 7,
		10, 0, 0, 902, 910, 7, 11, 0, 0, 903, 904, 5, 265, 0, 0, 904, 907, 5, 278,
		0, 0, 905, 906, 5, 271, 0, 0, 906, 908, 5, 278, 0, 0, 907, 905, 1, 0, 0,
		0, 907, 908, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 911, 5, 266, 0, 0,
		910, 903, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 951, 1, 0, 0, 0, 912,
		951, 7, 12, 0, 0, 913, 917, 7, 13, 0, 0, 914, 915, 5, 265, 0, 0, 915, 916,
		5, 278, 0, 0, 916, 918, 5, 266, 0, 0, 917, 914, 1, 0, 0, 0, 917, 918, 1,
		0, 0, 0, 918, 951, 1, 0, 0, 0, 919, 951, 7, 14, 0, 0, 920, 924, 7, 15,
		0, 0, 921, 922, 5, 265, 0, 0, 922, 923, 5, 278, 0, 0, 923, 925, 5, 266,
		0, 0, 924, 921, 1, 0, 0, 0, 924, 925, 1, 0, 0, 0, 925, 932, 1, 0, 0, 0,
		926, 927, 5, 174, 0, 0, 927, 928, 5, 203, 0, 0, 928, 933, 5, 202, 0, 0,
		929, 930, 5, 82, 0, 0, 930, 931, 5, 203, 0, 0, 931, 933, 5, 202, 0, 0,
		932, 926, 1, 0, 0, 0, 932, 929, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933,
		951, 1, 0, 0, 0, 934, 951, 7, 16, 0, 0, 935, 936, 5, 241, 0, 0, 936, 937,
		5, 245, 0, 0, 937, 938, 3, 98, 49, 0, 938, 939, 5, 247, 0, 0, 939, 951,
		1, 0, 0, 0, 940, 948, 3, 206, 103, 0, 941, 942, 5, 265, 0, 0, 942, 945,
		5, 278, 0, 0, 943, 944, 5, 271, 0, 0, 944, 946, 5, 278, 0, 0, 945, 943,
		1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 949, 5, 266,
		0, 0, 948, 941, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 951, 1, 0, 0, 0,
		950, 900, 1, 0, 0, 0, 950, 901, 1, 0, 0, 0, 950, 902, 1, 0, 0, 0, 950,
		912, 1, 0, 0, 0, 950, 913, 1, 0, 0, 0, 950, 919, 1, 0, 0, 0, 950, 920,
		1, 0, 0, 0, 950, 934, 1, 0, 0, 0, 950, 935, 1, 0, 0, 0, 950, 940, 1, 0,
		0, 0, 951, 101, 1, 0, 0, 0, 952, 953, 3, 206, 103, 0, 953, 954, 5, 274,
		0, 0, 954, 955, 3, 98, 49, 0, 955, 960, 1, 0, 0, 0, 956, 957, 3, 206, 103,
		0, 957, 958, 3, 98, 49, 0, 958, 960, 1, 0, 0, 0, 959, 952, 1, 0, 0, 0,
		959, 956, 1, 0, 0, 0, 960, 103, 1, 0, 0, 0, 961, 963, 5, 6, 0, 0, 962,
		961, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0, 964, 1030,
		5, 182, 0, 0, 965, 966, 5, 47, 0, 0, 966, 1030, 3, 166, 83, 0, 967, 968,
		5, 41, 0, 0, 968, 970, 5, 42, 0, 0, 969, 971, 3, 112, 56, 0, 970, 969,
		1, 0, 0, 0, 970, 971, 1, 0, 0, 0, 971, 1030, 1, 0, 0, 0, 972, 1030, 5,
		45, 0, 0, 973, 1030, 5, 48, 0, 0, 974, 976, 5, 87, 0, 0, 975, 977, 3, 106,
		53, 0, 976, 975, 1, 0, 0, 0, 976, 977, 1, 0, 0, 0, 977, 1030, 1, 0, 0,
		0, 978, 982, 5, 85, 0, 0, 979, 983, 5, 86, 0, 0, 980, 981, 5, 157, 0, 0,
		981, 983, 5, 47, 0, 0, 982, 979, 1, 0, 0, 0, 982, 980, 1, 0, 0, 0, 983,
		984, 1, 0, 0, 0, 984, 995, 5, 7, 0, 0, 985, 987, 5, 87, 0, 0, 986, 988,
		3, 106, 53, 0, 987, 986, 1, 0, 0, 0, 987, 988, 1, 0, 0, 0, 988, 996, 1,
		0, 0, 0, 989, 990, 5, 265, 0, 0, 990, 991, 3, 166, 83, 0, 991, 993, 5,
		266, 0, 0, 992, 994, 5, 55, 0, 0, 993, 992, 1, 0, 0, 0, 993, 994, 1, 0,
		0, 0, 994, 996, 1, 0, 0, 0, 995, 985, 1, 0, 0, 0, 995, 989, 1, 0, 0, 0,
		996, 1030, 1, 0, 0, 0, 997, 998, 5, 44, 0, 0, 998, 1003, 3, 196, 98, 0,
		999, 1000, 5, 265, 0, 0, 1000, 1001, 3, 206, 103, 0, 1001, 1002, 5, 266,
		0, 0, 1002, 1004, 1, 0, 0, 0, 1003, 999, 1, 0, 0, 0, 1003, 1004, 1, 0,
		0, 0, 1004, 1008, 1, 0, 0, 0, 1005, 1007, 3, 108, 54, 0, 1006, 1005, 1,
		0, 0, 0, 1007, 1010, 1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1008, 1009, 1,
		0, 0, 0, 1009, 1030, 1, 0, 0, 0, 1010, 1008, 1, 0, 0, 0, 1011, 1012, 5,
		46, 0, 0, 1012, 1013, 5, 265, 0, 0, 1013, 1014, 3, 166, 83, 0, 1014, 1015,
		5, 266, 0, 0, 1015, 1030, 1, 0, 0, 0, 1016, 1019, 5, 78, 0, 0, 1017, 1018,
		5, 2, 0, 0, 1018, 1020, 5, 276, 0, 0, 1019, 1017, 1, 0, 0, 0, 1019, 1020,
		1, 0, 0, 0, 1020, 1022, 1, 0, 0, 0, 1021, 1023, 5, 79, 0, 0, 1022, 1021,
		1, 0, 0, 0, 1022, 1023, 1, 0, 0, 0, 1023, 1030, 1, 0, 0, 0, 1024, 1025,
		5, 122, 0, 0, 1025, 1030, 3, 206, 103, 0, 1026, 1027, 5, 121, 0, 0, 1027,
		1028, 5, 23, 0, 0, 1028, 1030, 3, 206, 103, 0, 1029, 962, 1, 0, 0, 0, 1029,
		965, 1, 0, 0, 0, 1029, 967, 1, 0, 0, 0, 1029, 972, 1, 0, 0, 0, 1029, 973,
		1, 0, 0, 0, 1029, 974, 1, 0, 0, 0, 1029, 978, 1, 0, 0, 0, 1029, 997, 1,
		0, 0, 0, 1029, 1011, 1, 0, 0, 0, 1029, 1016, 1, 0, 0, 0, 1029, 1024, 1,
		0, 0, 0, 1029, 1026, 1, 0, 0, 0, 1030, 105, 1, 0, 0, 0, 1031, 1037, 5,
		265, 0, 0, 1032, 1034, 5, 88, 0, 0, 1033, 1035, 5, 174, 0, 0, 1034, 1033,
		1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1038,
		5, 278, 0, 0, 1037, 1032, 1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038, 1044,
		1, 0, 0, 0, 1039, 1041, 5, 89, 0, 0, 1040, 1042, 5, 157, 0, 0, 1041, 1040,
		1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 1045,
		5, 278, 0, 0, 1044, 1039, 1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045, 1050,
		1, 0, 0, 0, 1046, 1047, 5, 90, 0, 0, 1047, 1051, 5, 278, 0, 0, 1048, 1049,
		5, 154, 0, 0, 1049, 1051, 5, 90, 0, 0, 1050, 1046, 1, 0, 0, 0, 1050, 1048,
		1, 0, 0, 0, 1050, 1051, 1, 0, 0, 0, 1051, 1056, 1, 0, 0, 0, 1052, 1053,
		5, 91, 0, 0, 1053, 1057, 5, 278, 0, 0, 1054, 1055, 5, 154, 0, 0, 1055,
		1057, 5, 91, 0, 0, 1056, 1052, 1, 0, 0, 0, 1056, 1054, 1, 0, 0, 0, 1056,
		1057, 1, 0, 0, 0, 1057, 1061, 1, 0, 0, 0, 1058, 1062, 5, 92, 0, 0, 1059,
		1060, 5, 154, 0, 0, 1060, 1062, 5, 92, 0, 0, 1061, 1058, 1, 0, 0, 0, 1061,
		1059, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1065, 1, 0, 0, 0, 1063,
		1064, 5, 93, 0, 0, 1064, 1066, 5, 278, 0, 0, 1065, 1063, 1, 0, 0, 0, 1065,
		1066, 1, 0, 0, 0, 1066, 1067, 1, 0, 0, 0, 1067, 1068, 5, 266, 0, 0, 1068,
		107, 1, 0, 0, 0, 1069, 1070, 5, 8, 0, 0, 1070, 1071, 5, 24, 0, 0, 1071,
		1076, 3, 110, 55, 0, 1072, 1073, 5, 8, 0, 0, 1073, 1074, 5, 22, 0, 0, 1074,
		1076, 3, 110, 55, 0, 1075, 1069, 1, 0, 0, 0, 1075, 1072, 1, 0, 0, 0, 1076,
		109, 1, 0, 0, 0, 1077, 1086, 5, 137, 0, 0, 1078, 1079, 5, 23, 0, 0, 1079,
		1086, 5, 182, 0, 0, 1080, 1081, 5, 23, 0, 0, 1081, 1086, 5, 47, 0, 0, 1082,
		1086, 5, 136, 0, 0, 1083, 1084, 5, 154, 0, 0, 1084, 1086, 5, 138, 0, 0,
		1085, 1077, 1, 0, 0, 0, 1085, 1078, 1, 0, 0, 0, 1085, 1080, 1, 0, 0, 0,
		1085, 1082, 1, 0, 0, 0, 1085, 1083, 1, 0, 0, 0, 1086, 111, 1, 0, 0, 0,
		1087, 1088, 5, 6, 0, 0, 1088, 1089, 5, 77, 0, 0, 1089, 113, 1, 0, 0, 0,
		1090, 1091, 5, 41, 0, 0, 1091, 1092, 5, 42, 0, 0, 1092, 1093, 5, 265, 0,
		0, 1093, 1098, 3, 206, 103, 0, 1094, 1095, 5, 271, 0, 0, 1095, 1097, 3,
		206, 103, 0, 1096, 1094, 1, 0, 0, 0, 1097, 1100, 1, 0, 0, 0, 1098, 1096,
		1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1101, 1, 0, 0, 0, 1100, 1098,
		1, 0, 0, 0, 1101, 1103, 5, 266, 0, 0, 1102, 1104, 3, 112, 56, 0, 1103,
		1102, 1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 1159, 1, 0, 0, 0, 1105,
		1106, 5, 45, 0, 0, 1106, 1107, 5, 265, 0, 0, 1107, 1112, 3, 206, 103, 0,
		1108, 1109, 5, 271, 0, 0, 1109, 1111, 3, 206, 103, 0, 1110, 1108, 1, 0,
		0, 0, 1111, 1114, 1, 0, 0, 0, 1112, 1110, 1, 0, 0, 0, 1112, 1113, 1, 0,
		0, 0, 1113, 1115, 1, 0, 0, 0, 1114, 1112, 1, 0, 0, 0, 1115, 1117, 5, 266,
		0, 0, 1116, 1118, 3, 112, 56, 0, 1117, 1116, 1, 0, 0, 0, 1117, 1118, 1,
		0, 0, 0, 1118, 1159, 1, 0, 0, 0, 1119, 1120, 5, 43, 0, 0, 1120, 1121, 5,
		42, 0, 0, 1121, 1122, 5, 265, 0, 0, 1122, 1127, 3, 206, 103, 0, 1123, 1124,
		5, 271, 0, 0, 1124, 1126, 3, 206, 103, 0, 1125, 1123, 1, 0, 0, 0, 1126,
		1129, 1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0, 1127, 1128, 1, 0, 0, 0, 1128,
		1130, 1, 0, 0, 0, 1129, 1127, 1, 0, 0, 0, 1130, 1131, 5, 266, 0, 0, 1131,
		1132, 5, 44, 0, 0, 1132, 1144, 3, 196, 98, 0, 1133, 1134, 5, 265, 0, 0,
		1134, 1139, 3, 206, 103, 0, 1135, 1136, 5, 271, 0, 0, 1136, 1138, 3, 206,
		103, 0, 1137, 1135, 1, 0, 0, 0, 1138, 1141, 1, 0, 0, 0, 1139, 1137, 1,
		0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1142, 1, 0, 0, 0, 1141, 1139, 1,
		0, 0, 0, 1142, 1143, 5, 266, 0, 0, 1143, 1145, 1, 0, 0, 0, 1144, 1133,
		1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145, 1147, 1, 0, 0, 0, 1146, 1148,
		3, 112, 56, 0, 1147, 1146, 1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148, 1159,
		1, 0, 0, 0, 1149, 1150, 5, 46, 0, 0, 1150, 1151, 5, 265, 0, 0, 1151, 1152,
		3, 166, 83, 0, 1152, 1153, 5, 266, 0, 0, 1153, 1159, 1, 0, 0, 0, 1154,
		1155, 5, 40, 0, 0, 1155, 1156, 3, 206, 103, 0, 1156, 1157, 3, 114, 57,
		0, 1157, 1159, 1, 0, 0, 0, 1158, 1090, 1, 0, 0, 0, 1158, 1105, 1, 0, 0,
		0, 1158, 1119, 1, 0, 0, 0, 1158, 1149, 1, 0, 0, 0, 1158, 1154, 1, 0, 0,
		0, 1159, 115, 1, 0, 0, 0, 1160, 1161, 5, 72, 0, 0, 1161, 1162, 5, 157,
		0, 0, 1162, 1163, 5, 265, 0, 0, 1163, 1168, 3, 96, 48, 0, 1164, 1165, 5,
		271, 0, 0, 1165, 1167, 3, 96, 48, 0, 1166, 1164, 1, 0, 0, 0, 1167, 1170,
		1, 0, 0, 0, 1168, 1166, 1, 0, 0, 0, 1168, 1169, 1, 0, 0, 0, 1169, 1171,
		1, 0, 0, 0, 1170, 1168, 1, 0, 0, 0, 1171, 1172, 5, 266, 0, 0, 1172, 1187,
		1, 0, 0, 0, 1173, 1174, 5, 72, 0, 0, 1174, 1175, 5, 157, 0, 0, 1175, 1176,
		5, 265, 0, 0, 1176, 1181, 3, 206, 103, 0, 1177, 1178, 5, 271, 0, 0, 1178,
		1180, 3, 206, 103, 0, 1179, 1177, 1, 0, 0, 0, 1180, 1183, 1, 0, 0, 0, 1181,
		1179, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0, 1182, 1184, 1, 0, 0, 0, 1183,
		1181, 1, 0, 0, 0, 1184, 1185, 5, 266, 0, 0, 1185, 1187, 1, 0, 0, 0, 1186,
		1160, 1, 0, 0, 0, 1186, 1173, 1, 0, 0, 0, 1187, 117, 1, 0, 0, 0, 1188,
		1189, 5, 68, 0, 0, 1189, 1190, 5, 157, 0, 0, 1190, 1191, 5, 265, 0, 0,
		1191, 1196, 3, 206, 103, 0, 1192, 1193, 5, 271, 0, 0, 1193, 1195, 3, 206,
		103, 0, 1194, 1192, 1, 0, 0, 0, 1195, 1198, 1, 0, 0, 0, 1196, 1194, 1,
		0, 0, 0, 1196, 1197, 1, 0, 0, 0, 1197, 1199, 1, 0, 0, 0, 1198, 1196, 1,
		0, 0, 0, 1199, 1213, 5, 266, 0, 0, 1200, 1201, 5, 69, 0, 0, 1201, 1202,
		5, 157, 0, 0, 1202, 1203, 5, 265, 0, 0, 1203, 1208, 3, 52, 26, 0, 1204,
		1205, 5, 271, 0, 0, 1205, 1207, 3, 52, 26, 0, 1206, 1204, 1, 0, 0, 0, 1207,
		1210, 1, 0, 0, 0, 1208, 1206, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209,
		1211, 1, 0, 0, 0, 1210, 1208, 1, 0, 0, 0, 1211, 1212, 5, 266, 0, 0, 1212,
		1214, 1, 0, 0, 0, 1213, 1200, 1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214,
		1218, 1, 0, 0, 0, 1215, 1216, 5, 20, 0, 0, 1216, 1217, 5, 278, 0, 0, 1217,
		1219, 5, 70, 0, 0, 1218, 1215, 1, 0, 0, 0, 1218, 1219, 1, 0, 0, 0, 1219,
		119, 1, 0, 0, 0, 1220, 1221, 5, 113, 0, 0, 1221, 1236, 5, 157, 0, 0, 1222,
		1223, 5, 114, 0, 0, 1223, 1224, 5, 265, 0, 0, 1224, 1229, 3, 206, 103,
		0, 1225, 1226, 5, 271, 0, 0, 1226, 1228, 3, 206, 103, 0, 1227, 1225, 1,
		0, 0, 0, 1228, 1231, 1, 0, 0, 0, 1229, 1227, 1, 0, 0, 0, 1229, 1230, 1,
		0, 0, 0, 1230, 1232, 1, 0, 0, 0, 1231, 1229, 1, 0, 0, 0, 1232, 1233, 5,
		266, 0, 0, 1233, 1237, 1, 0, 0, 0, 1234, 1237, 5, 115, 0, 0, 1235, 1237,
		5, 116, 0, 0, 1236, 1222, 1, 0, 0, 0, 1236, 1234, 1, 0, 0, 0, 1236, 1235,
		1, 0, 0, 0, 1237, 1240, 1, 0, 0, 0, 1238, 1239, 5, 70, 0, 0, 1239, 1241,
		5, 278, 0, 0, 1240, 1238, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241, 121,
		1, 0, 0, 0, 1242, 1243, 5, 158, 0, 0, 1243, 1244, 5, 157, 0, 0, 1244, 1245,
		5, 265, 0, 0, 1245, 1250, 3, 206, 103, 0, 1246, 1247, 5, 271, 0, 0, 1247,
		1249, 3, 206, 103, 0, 1248, 1246, 1, 0, 0, 0, 1249, 1252, 1, 0, 0, 0, 1250,
		1248, 1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251, 1253, 1, 0, 0, 0, 1252,
		1250, 1, 0, 0, 0, 1253, 1254, 5, 266, 0, 0, 1254, 1259, 1, 0, 0, 0, 1255,
		1256, 5, 158, 0, 0, 1256, 1257, 5, 157, 0, 0, 1257, 1259, 3, 206, 103,
		0, 1258, 1242, 1, 0, 0, 0, 1258, 1255, 1, 0, 0, 0, 1259, 123, 1, 0, 0,
		0, 1260, 1261, 5, 124, 0, 0, 1261, 1262, 5, 265, 0, 0, 1262, 1267, 3, 196,
		98, 0, 1263, 1264, 5, 271, 0, 0, 1264, 1266, 3, 196, 98, 0, 1265, 1263,
		1, 0, 0, 0, 1266, 1269, 1, 0, 0, 0, 1267, 1265, 1, 0, 0, 0, 1267, 1268,
		1, 0, 0, 0, 1268, 1270, 1, 0, 0, 0, 1269, 1267, 1, 0, 0, 0, 1270, 1271,
		5, 266, 0, 0, 1271, 125, 1, 0, 0, 0, 1272, 1274, 5, 119, 0, 0, 1273, 1275,
		5, 243, 0, 0, 1274, 1273, 1, 0, 0, 0, 1274, 1275, 1, 0, 0, 0, 1275, 1276,
		1, 0, 0, 0, 1276, 1282, 3, 206, 103, 0, 1277, 1279, 5, 265, 0, 0, 1278,
		1280, 3, 194, 97, 0, 1279, 1278, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280,
		1281, 1, 0, 0, 0, 1281, 1283, 5, 266, 0, 0, 1282, 1277, 1, 0, 0, 0, 1282,
		1283, 1, 0, 0, 0, 1283, 127, 1, 0, 0, 0, 1284, 1286, 5, 47, 0, 0, 1285,
		1284, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1290, 1, 0, 0, 0, 1287,
		1291, 5, 120, 0, 0, 1288, 1289, 5, 121, 0, 0, 1289, 1291, 5, 23, 0, 0,
		1290, 1287, 1, 0, 0, 0, 1290, 1288, 1, 0, 0, 0, 1291, 1293, 1, 0, 0, 0,
		1292, 1294, 5, 243, 0, 0, 1293, 1292, 1, 0, 0, 0, 1293, 1294, 1, 0, 0,
		0, 1294, 1295, 1, 0, 0, 0, 1295, 1296, 3, 206, 103, 0, 1296, 129, 1, 0,
		0, 0, 1297, 1299, 5, 47, 0, 0, 1298, 1297, 1, 0, 0, 0, 1298, 1299, 1, 0,
		0, 0, 1299, 1300, 1, 0, 0, 0, 1300, 1302, 5, 122, 0, 0, 1301, 1303, 5,
		243, 0, 0, 1302, 1301, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303, 1304,
		1, 0, 0, 0, 1304, 1305, 3, 206, 103, 0, 1305, 131, 1, 0, 0, 0, 1306, 1307,
		5, 123, 0, 0, 1307, 1308, 3, 206, 103, 0, 1308, 133, 1, 0, 0, 0, 1309,
		1310, 5, 132, 0, 0, 1310, 1315, 3, 166, 83, 0, 1311, 1312, 5, 271, 0, 0,
		1312, 1314, 3, 166, 83, 0, 1313, 1311, 1, 0, 0, 0, 1314, 1317, 1, 0, 0,
		0, 1315, 1313, 1, 0, 0, 0, 1315, 1316, 1, 0, 0, 0, 1316, 135, 1, 0, 0,
		0, 1317, 1315, 1, 0, 0, 0, 1318, 1319, 5, 133, 0, 0, 1319, 1320, 5, 278,
		0, 0, 1320, 137, 1, 0, 0, 0, 1321, 1322, 5, 58, 0, 0, 1322, 1323, 5, 66,
		0, 0, 1323, 1330, 5, 276, 0, 0, 1324, 1325, 5, 174, 0, 0, 1325, 1326, 5,
		67, 0, 0, 1326, 1327, 5, 265, 0, 0, 1327, 1328, 3, 148, 74, 0, 1328, 1329,
		5, 266, 0, 0, 1329, 1331, 1, 0, 0, 0, 1330, 1324, 1, 0, 0, 0, 1330, 1331,
		1, 0, 0, 0, 1331, 1335, 1, 0, 0, 0, 1332, 1333, 5, 58, 0, 0, 1333, 1335,
		3, 206, 103, 0, 1334, 1321, 1, 0, 0, 0, 1334, 1332, 1, 0, 0, 0, 1335, 139,
		1, 0, 0, 0, 1336, 1337, 5, 55, 0, 0, 1337, 1338, 5, 7, 0, 0, 1338, 1345,
		3, 206, 103, 0, 1339, 1340, 5, 55, 0, 0, 1340, 1341, 5, 7, 0, 0, 1341,
		1342, 3, 206, 103, 0, 1342, 1343, 3, 206, 103, 0, 1343, 1345, 1, 0, 0,
		0, 1344, 1336, 1, 0, 0, 0, 1344, 1339, 1, 0, 0, 0, 1345, 141, 1, 0, 0,
		0, 1346, 1347, 5, 54, 0, 0, 1347, 1348, 5, 276, 0, 0, 1348, 143, 1, 0,
		0, 0, 1349, 1350, 5, 57, 0, 0, 1350, 1351, 5, 265, 0, 0, 1351, 1352, 3,
		148, 74, 0, 1352, 1353, 5, 266, 0, 0, 1353, 145, 1, 0, 0, 0, 1354, 1355,
		5, 174, 0, 0, 1355, 1356, 5, 265, 0, 0, 1356, 1357, 3, 148, 74, 0, 1357,
		1358, 5, 266, 0, 0, 1358, 147, 1, 0, 0, 0, 1359, 1364, 3, 150, 75, 0, 1360,
		1361, 5, 271, 0, 0, 1361, 1363, 3, 150, 75, 0, 1362, 1360, 1, 0, 0, 0,
		1363, 1366, 1, 0, 0, 0, 1364, 1362, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0,
		1365, 149, 1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1367, 1368, 5, 276, 0, 0,
		1368, 1369, 5, 243, 0, 0, 1369, 1375, 5, 276, 0, 0, 1370, 1371, 3, 206,
		103, 0, 1371, 1372, 5, 243, 0, 0, 1372, 1373, 5, 276, 0, 0, 1373, 1375,
		1, 0, 0, 0, 1374, 1367, 1, 0, 0, 0, 1374, 1370, 1, 0, 0, 0, 1375, 151,
		1, 0, 0, 0, 1376, 1379, 5, 26, 0, 0, 1377, 1378, 5, 5, 0, 0, 1378, 1380,
		5, 99, 0, 0, 1379, 1377, 1, 0, 0, 0, 1379, 1380, 1, 0, 0, 0, 1380, 1382,
		1, 0, 0, 0, 1381, 1383, 7, 17, 0, 0, 1382, 1381, 1, 0, 0, 0, 1382, 1383,
		1, 0, 0, 0, 1383, 1384, 1, 0, 0, 0, 1384, 1388, 5, 28, 0, 0, 1385, 1386,
		5, 50, 0, 0, 1386, 1387, 5, 6, 0, 0, 1387, 1389, 5, 192, 0, 0, 1388, 1385,
		1, 0, 0, 0, 1388, 1389, 1, 0, 0, 0, 1389, 1390, 1, 0, 0, 0, 1390, 1402,
		3, 196, 98, 0, 1391, 1392, 5, 265, 0, 0, 1392, 1397, 3, 206, 103, 0, 1393,
		1394, 5, 271, 0, 0, 1394, 1396, 3, 206, 103, 0, 1395, 1393, 1, 0, 0, 0,
		1396, 1399, 1, 0, 0, 0, 1397, 1395, 1, 0, 0, 0, 1397, 1398, 1, 0, 0, 0,
		1398, 1400, 1, 0, 0, 0, 1399, 1397, 1, 0, 0, 0, 1400, 1401, 5, 266, 0,
		0, 1401, 1403, 1, 0, 0, 0, 1402, 1391, 1, 0, 0, 0, 1402, 1403, 1, 0, 0,
		0, 1403, 1406, 1, 0, 0, 0, 1404, 1405, 5, 49, 0, 0, 1405, 1407, 5, 276,
		0, 0, 1406, 1404, 1, 0, 0, 0, 1406, 1407, 1, 0, 0, 0, 1407, 1408, 1, 0,
		0, 0, 1408, 1409, 5, 7, 0, 0, 1409, 1410, 3, 8, 4, 0, 1410, 153, 1, 0,
		0, 0, 1411, 1412, 5, 26, 0, 0, 1412, 1416, 7, 18, 0, 0, 1413, 1414, 5,
		50, 0, 0, 1414, 1415, 5, 6, 0, 0, 1415, 1417, 5, 192, 0, 0, 1416, 1413,
		1, 0, 0, 0, 1416, 1417, 1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 1421,
		3, 206, 103, 0, 1419, 1420, 5, 49, 0, 0, 1420, 1422, 5, 276, 0, 0, 1421,
		1419, 1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422, 1424, 1, 0, 0, 0, 1423,
		1425, 3, 142, 71, 0, 1424, 1423, 1, 0, 0, 0, 1424, 1425, 1, 0, 0, 0, 1425,
		1428, 1, 0, 0, 0, 1426, 1427, 5, 174, 0, 0, 1427, 1429, 3, 148, 74, 0,
		1428, 1426, 1, 0, 0, 0, 1428, 1429, 1, 0, 0, 0, 1429, 155, 1, 0, 0, 0,
		1430, 1432, 5, 26, 0, 0, 1431, 1433, 5, 45, 0, 0, 1432, 1431, 1, 0, 0,
		0, 1432, 1433, 1, 0, 0, 0, 1433, 1434, 1, 0, 0, 0, 1434, 1438, 5, 33, 0,
		0, 1435, 1436, 5, 50, 0, 0, 1436, 1437, 5, 6, 0, 0, 1437, 1439, 5, 192,
		0, 0, 1438, 1435, 1, 0, 0, 0, 1438, 1439, 1, 0, 0, 0, 1439, 1440, 1, 0,
		0, 0, 1440, 1441, 3, 206, 103, 0, 1441, 1442, 5, 8, 0, 0, 1442, 1443, 3,
		196, 98, 0, 1443, 1444, 5, 265, 0, 0, 1444, 1449, 3, 158, 79, 0, 1445,
		1446, 5, 271, 0, 0, 1446, 1448, 3, 158, 79, 0, 1447, 1445, 1, 0, 0, 0,
		1448, 1451, 1, 0, 0, 0, 1449, 1447, 1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0,
		1450, 1452, 1, 0, 0, 0, 1451, 1449, 1, 0, 0, 0, 1452, 1453, 5, 266, 0,
		0, 1453, 157, 1, 0, 0, 0, 1454, 1456, 3, 206, 103, 0, 1455, 1457, 7, 2,
		0, 0, 1456, 1455, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 159, 1, 0,
		0, 0, 1458, 1459, 5, 31, 0, 0, 1459, 1462, 5, 27, 0, 0, 1460, 1461, 5,
		50, 0, 0, 1461, 1463, 5, 192, 0, 0, 1462, 1460, 1, 0, 0, 0, 1462, 1463,
		1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 1491, 3, 196, 98, 0, 1465, 1466,
		5, 31, 0, 0, 1466, 1469, 5, 28, 0, 0, 1467, 1468, 5, 50, 0, 0, 1468, 1470,
		5, 192, 0, 0, 1469, 1467, 1, 0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470, 1471,
		1, 0, 0, 0, 1471, 1491, 3, 196, 98, 0, 1472, 1473, 5, 31, 0, 0, 1473, 1476,
		7, 18, 0, 0, 1474, 1475, 5, 50, 0, 0, 1475, 1477, 5, 192, 0, 0, 1476, 1474,
		1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1491,
		3, 206, 103, 0, 1479, 1480, 5, 31, 0, 0, 1480, 1483, 5, 33, 0, 0, 1481,
		1482, 5, 50, 0, 0, 1482, 1484, 5, 192, 0, 0, 1483, 1481, 1, 0, 0, 0, 1483,
		1484, 1, 0, 0, 0, 1484, 1485, 1, 0, 0, 0, 1485, 1488, 3, 206, 103, 0, 1486,
		1487, 5, 8, 0, 0, 1487, 1489, 3, 196, 98, 0, 1488, 1486, 1, 0, 0, 0, 1488,
		1489, 1, 0, 0, 0, 1489, 1491, 1, 0, 0, 0, 1490, 1458, 1, 0, 0, 0, 1490,
		1465, 1, 0, 0, 0, 1490, 1472, 1, 0, 0, 0, 1490, 1479, 1, 0, 0, 0, 1491,
		161, 1, 0, 0, 0, 1492, 1493, 5, 32, 0, 0, 1493, 1494, 5, 27, 0, 0, 1494,
		1495, 3, 196, 98, 0, 1495, 1500, 3, 164, 82, 0, 1496, 1497, 5, 271, 0,
		0, 1497, 1499, 3, 164, 82, 0, 1498, 1496, 1, 0, 0, 0, 1499, 1502, 1, 0,
		0, 0, 1500, 1498, 1, 0, 0, 0, 1500, 1501, 1, 0, 0, 0, 1501, 1516, 1, 0,
		0, 0, 1502, 1500, 1, 0, 0, 0, 1503, 1504, 5, 32, 0, 0, 1504, 1505, 5, 28,
		0, 0, 1505, 1506, 3, 196, 98, 0, 1506, 1507, 5, 7, 0, 0, 1507, 1508, 3,
		8, 4, 0, 1508, 1516, 1, 0, 0, 0, 1509, 1510, 5, 32, 0, 0, 1510, 1511, 7,
		18, 0, 0, 1511, 1512, 3, 206, 103, 0, 1512, 1513, 5, 23, 0, 0, 1513, 1514,
		3, 148, 74, 0, 1514, 1516, 1, 0, 0, 0, 1515, 1492, 1, 0, 0, 0, 1515, 1503,
		1, 0, 0, 0, 1515, 1509, 1, 0, 0, 0, 1516, 163, 1, 0, 0, 0, 1517, 1519,
		5, 34, 0, 0, 1518, 1520, 5, 35, 0, 0, 1519, 1518, 1, 0, 0, 0, 1519, 1520,
		1, 0, 0, 0, 1520, 1521, 1, 0, 0, 0, 1521, 1569, 3, 96, 48, 0, 1522, 1524,
		5, 31, 0, 0, 1523, 1525, 5, 35, 0, 0, 1524, 1523, 1, 0, 0, 0, 1524, 1525,
		1, 0, 0, 0, 1525, 1526, 1, 0, 0, 0, 1526, 1569, 3, 206, 103, 0, 1527, 1529,
		5, 36, 0, 0, 1528, 1530, 5, 35, 0, 0, 1529, 1528, 1, 0, 0, 0, 1529, 1530,
		1, 0, 0, 0, 1530, 1531, 1, 0, 0, 0, 1531, 1532, 3, 206, 103, 0, 1532, 1533,
		5, 37, 0, 0, 1533, 1534, 3, 206, 103, 0, 1534, 1569, 1, 0, 0, 0, 1535,
		1536, 5, 36, 0, 0, 1536, 1537, 5, 37, 0, 0, 1537, 1569, 3, 196, 98, 0,
		1538, 1540, 5, 38, 0, 0, 1539, 1541, 5, 35, 0, 0, 1540, 1539, 1, 0, 0,
		0, 1540, 1541, 1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1569, 3, 96, 48,
		0, 1543, 1545, 5, 39, 0, 0, 1544, 1546, 5, 35, 0, 0, 1545, 1544, 1, 0,
		0, 0, 1545, 1546, 1, 0, 0, 0, 1546, 1547, 1, 0, 0, 0, 1547, 1548, 3, 206,
		103, 0, 1548, 1549, 3, 96, 48, 0, 1549, 1569, 1, 0, 0, 0, 1550, 1551, 5,
		34, 0, 0, 1551, 1569, 3, 114, 57, 0, 1552, 1553, 5, 31, 0, 0, 1553, 1554,
		5, 40, 0, 0, 1554, 1569, 3, 206, 103, 0, 1555, 1556, 5, 23, 0, 0, 1556,
		1557, 5, 57, 0, 0, 1557, 1558, 5, 265, 0, 0, 1558, 1559, 3, 148, 74, 0,
		1559, 1560, 5, 266, 0, 0, 1560, 1569, 1, 0, 0, 0, 1561, 1562, 5, 34, 0,
		0, 1562, 1564, 3, 58, 29, 0, 1563, 1565, 3, 142, 71, 0, 1564, 1563, 1,
		0, 0, 0, 1564, 1565, 1, 0, 0, 0, 1565, 1569, 1, 0, 0, 0, 1566, 1567, 5,
		31, 0, 0, 1567, 1569, 3, 58, 29, 0, 1568, 1517, 1, 0, 0, 0, 1568, 1522,
		1, 0, 0, 0, 1568, 1527, 1, 0, 0, 0, 1568, 1535, 1, 0, 0, 0, 1568, 1538,
		1, 0, 0, 0, 1568, 1543, 1, 0, 0, 0, 1568, 1550, 1, 0, 0, 0, 1568, 1552,
		1, 0, 0, 0, 1568, 1555, 1, 0, 0, 0, 1568, 1561, 1, 0, 0, 0, 1568, 1566,
		1, 0, 0, 0, 1569, 165, 1, 0, 0, 0, 1570, 1571, 6, 83, -1, 0, 1571, 1572,
		5, 265, 0, 0, 1572, 1573, 3, 166, 83, 0, 1573, 1574, 5, 266, 0, 0, 1574,
		1606, 1, 0, 0, 0, 1575, 1576, 5, 265, 0, 0, 1576, 1577, 3, 8, 4, 0, 1577,
		1578, 5, 266, 0, 0, 1578, 1606, 1, 0, 0, 0, 1579, 1606, 3, 182, 91, 0,
		1580, 1606, 3, 168, 84, 0, 1581, 1606, 3, 170, 85, 0, 1582, 1606, 3, 172,
		86, 0, 1583, 1584, 5, 250, 0, 0, 1584, 1606, 3, 166, 83, 27, 1585, 1586,
		5, 249, 0, 0, 1586, 1606, 3, 166, 83, 26, 1587, 1588, 5, 258, 0, 0, 1588,
		1606, 3, 166, 83, 25, 1589, 1590, 5, 6, 0, 0, 1590, 1606, 3, 166, 83, 13,
		1591, 1592, 5, 192, 0, 0, 1592, 1593, 5, 265, 0, 0, 1593, 1594, 3, 8, 4,
		0, 1594, 1595, 5, 266, 0, 0, 1595, 1606, 1, 0, 0, 0, 1596, 1606, 3, 174,
		87, 0, 1597, 1606, 3, 176, 88, 0, 1598, 1606, 3, 178, 89, 0, 1599, 1606,
		3, 180, 90, 0, 1600, 1606, 3, 192, 96, 0, 1601, 1606, 3, 210, 105, 0, 1602,
		1606, 5, 284, 0, 0, 1603, 1606, 5, 285, 0, 0, 1604, 1606, 5, 275, 0, 0,
		1605, 1570, 1, 0, 0, 0, 1605, 1575, 1, 0, 0, 0, 1605, 1579, 1, 0, 0, 0,
		1605, 1580, 1, 0, 0, 0, 1605, 1581, 1, 0, 0, 0, 1605, 1582, 1, 0, 0, 0,
		1605, 1583, 1, 0, 0, 0, 1605, 1585, 1, 0, 0, 0, 1605, 1587, 1, 0, 0, 0,
		1605, 1589, 1, 0, 0, 0, 1605, 1591, 1, 0, 0, 0, 1605, 1596, 1, 0, 0, 0,
		1605, 1597, 1, 0, 0, 0, 1605, 1598, 1, 0, 0, 0, 1605, 1599, 1, 0, 0, 0,
		1605, 1600, 1, 0, 0, 0, 1605, 1601, 1, 0, 0, 0, 1605, 1602, 1, 0, 0, 0,
		1605, 1603, 1, 0, 0, 0, 1605, 1604, 1, 0, 0, 0, 1606, 1698, 1, 0, 0, 0,
		1607, 1608, 10, 24, 0, 0, 1608, 1609, 7, 19, 0, 0, 1609, 1697, 3, 166,
		83, 25, 1610, 1611, 10, 23, 0, 0, 1611, 1612, 7, 20, 0, 0, 1612, 1697,
		3, 166, 83, 24, 1613, 1614, 10, 22, 0, 0, 1614, 1615, 5, 254, 0, 0, 1615,
		1697, 3, 166, 83, 23, 1616, 1617, 10, 21, 0, 0, 1617, 1618, 7, 21, 0, 0,
		1618, 1697, 3, 166, 83, 22, 1619, 1620, 10, 20, 0, 0, 1620, 1621, 7, 22,
		0, 0, 1621, 1697, 3, 166, 83, 21, 1622, 1624, 10, 15, 0, 0, 1623, 1625,
		5, 6, 0, 0, 1624, 1623, 1, 0, 0, 0, 1624, 1625, 1, 0, 0, 0, 1625, 1626,
		1, 0, 0, 0, 1626, 1627, 5, 185, 0, 0, 1627, 1628, 3, 166, 83, 0, 1628,
		1629, 5, 4, 0, 0, 1629, 1630, 3, 166, 83, 16, 1630, 1697, 1, 0, 0, 0, 1631,
		1632, 10, 12, 0, 0, 1632, 1633, 5, 4, 0, 0, 1633, 1697, 3, 166, 83, 13,
		1634, 1635, 10, 11, 0, 0, 1635, 1636, 5, 5, 0, 0, 1636, 1697, 3, 166, 83,
		12, 1637, 1638, 10, 34, 0, 0, 1638, 1639, 5, 267, 0, 0, 1639, 1640, 3,
		166, 83, 0, 1640, 1641, 5, 268, 0, 0, 1641, 1697, 1, 0, 0, 0, 1642, 1643,
		10, 33, 0, 0, 1643, 1644, 5, 272, 0, 0, 1644, 1697, 3, 206, 103, 0, 1645,
		1646, 10, 28, 0, 0, 1646, 1647, 5, 259, 0, 0, 1647, 1697, 3, 98, 49, 0,
		1648, 1649, 10, 19, 0, 0, 1649, 1650, 7, 22, 0, 0, 1650, 1651, 7, 23, 0,
		0, 1651, 1652, 5, 265, 0, 0, 1652, 1653, 3, 8, 4, 0, 1653, 1654, 5, 266,
		0, 0, 1654, 1697, 1, 0, 0, 0, 1655, 1656, 10, 18, 0, 0, 1656, 1658, 5,
		183, 0, 0, 1657, 1659, 5, 6, 0, 0, 1658, 1657, 1, 0, 0, 0, 1658, 1659,
		1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1697, 5, 182, 0, 0, 1661, 1662,
		10, 17, 0, 0, 1662, 1664, 5, 183, 0, 0, 1663, 1665, 5, 6, 0, 0, 1664, 1663,
		1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 1697,
		7, 24, 0, 0, 1667, 1669, 10, 16, 0, 0, 1668, 1670, 5, 6, 0, 0, 1669, 1668,
		1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 1671, 1, 0, 0, 0, 1671, 1672,
		5, 184, 0, 0, 1672, 1675, 5, 265, 0, 0, 1673, 1676, 3, 8, 4, 0, 1674, 1676,
		3, 194, 97, 0, 1675, 1673, 1, 0, 0, 0, 1675, 1674, 1, 0, 0, 0, 1676, 1677,
		1, 0, 0, 0, 1677, 1678, 5, 266, 0, 0, 1678, 1697, 1, 0, 0, 0, 1679, 1681,
		10, 14, 0, 0, 1680, 1682, 5, 6, 0, 0, 1681, 1680, 1, 0, 0, 0, 1681, 1682,
		1, 0, 0, 0, 1682, 1689, 1, 0, 0, 0, 1683, 1690, 5, 186, 0, 0, 1684, 1690,
		5, 187, 0, 0, 1685, 1690, 5, 188, 0, 0, 1686, 1690, 5, 189, 0, 0, 1687,
		1688, 5, 190, 0, 0, 1688, 1690, 5, 37, 0, 0, 1689, 1683, 1, 0, 0, 0, 1689,
		1684, 1, 0, 0, 0, 1689, 1685, 1, 0, 0, 0, 1689, 1686, 1, 0, 0, 0, 1689,
		1687, 1, 0, 0, 0, 1690, 1691, 1, 0, 0, 0, 1691, 1694, 3, 166, 83, 0, 1692,
		1693, 5, 191, 0, 0, 1693, 1695, 3, 166, 83, 0, 1694, 1692, 1, 0, 0, 0,
		1694, 1695, 1, 0, 0, 0, 1695, 1697, 1, 0, 0, 0, 1696, 1607, 1, 0, 0, 0,
		1696, 1610, 1, 0, 0, 0, 1696, 1613, 1, 0, 0, 0, 1696, 1616, 1, 0, 0, 0,
		1696, 1619, 1, 0, 0, 0, 1696, 1622, 1, 0, 0, 0, 1696, 1631, 1, 0, 0, 0,
		1696, 1634, 1, 0, 0, 0, 1696, 1637, 1, 0, 0, 0, 1696, 1642, 1, 0, 0, 0,
		1696, 1645, 1, 0, 0, 0, 1696, 1648, 1, 0, 0, 0, 1696, 1655, 1, 0, 0, 0,
		1696, 1661, 1, 0, 0, 0, 1696, 1667, 1, 0, 0, 0, 1696, 1679, 1, 0, 0, 0,
		1697, 1700, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0, 1698, 1699, 1, 0, 0, 0,
		1699, 167, 1, 0, 0, 0, 1700, 1698, 1, 0, 0, 0, 1701, 1702, 7, 25, 0, 0,
		1702, 1703, 5, 265, 0, 0, 1703, 1704, 3, 166, 83, 0, 1704, 1705, 5, 7,
		0, 0, 1705, 1706, 3, 98, 49, 0, 1706, 1707, 5, 266, 0, 0, 1707, 1716, 1,
		0, 0, 0, 1708, 1709, 5, 197, 0, 0, 1709, 1710, 5, 265, 0, 0, 1710, 1711,
		3, 166, 83, 0, 1711, 1712, 5, 271, 0, 0, 1712, 1713, 3, 98, 49, 0, 1713,
		1714, 5, 266, 0, 0, 1714, 1716, 1, 0, 0, 0, 1715, 1701, 1, 0, 0, 0, 1715,
		1708, 1, 0, 0, 0, 1716, 169, 1, 0, 0, 0, 1717, 1718, 5, 199, 0, 0, 1718,
		1719, 5, 265, 0, 0, 1719, 1720, 3, 206, 103, 0, 1720, 1721, 5, 2, 0, 0,
		1721, 1722, 3, 166, 83, 0, 1722, 1723, 5, 266, 0, 0, 1723, 171, 1, 0, 0,
		0, 1724, 1725, 5, 200, 0, 0, 1725, 1726, 3, 166, 83, 0, 1726, 1727, 3,
		206, 103, 0, 1727, 1731, 1, 0, 0, 0, 1728, 1729, 5, 200, 0, 0, 1729, 1731,
		5, 276, 0, 0, 1730, 1724, 1, 0, 0, 0, 1730, 1728, 1, 0, 0, 0, 1731, 173,
		1, 0, 0, 0, 1732, 1734, 5, 177, 0, 0, 1733, 1735, 3, 166, 83, 0, 1734,
		1733, 1, 0, 0, 0, 1734, 1735, 1, 0, 0, 0, 1735, 1741, 1, 0, 0, 0, 1736,
		1737, 5, 178, 0, 0, 1737, 1738, 3, 166, 83, 0, 1738, 1739, 5, 179, 0, 0,
		1739, 1740, 3, 166, 83, 0, 1740, 1742, 1, 0, 0, 0, 1741, 1736, 1, 0, 0,
		0, 1742, 1743, 1, 0, 0, 0, 1743, 1741, 1, 0, 0, 0, 1743, 1744, 1, 0, 0,
		0, 1744, 1747, 1, 0, 0, 0, 1745, 1746, 5, 180, 0, 0, 1746, 1748, 3, 166,
		83, 0, 1747, 1745, 1, 0, 0, 0, 1747, 1748, 1, 0, 0, 0, 1748, 1749, 1, 0,
		0, 0, 1749, 1750, 5, 181, 0, 0, 1750, 175, 1, 0, 0, 0, 1751, 1752, 5, 214,
		0, 0, 1752, 1754, 5, 267, 0, 0, 1753, 1755, 3, 194, 97, 0, 1754, 1753,
		1, 0, 0, 0, 1754, 1755, 1, 0, 0, 0, 1755, 1756, 1, 0, 0, 0, 1756, 1763,
		5, 268, 0, 0, 1757, 1758, 5, 214, 0, 0, 1758, 1759, 5, 265, 0, 0, 1759,
		1760, 3, 8, 4, 0, 1760, 1761, 5, 266, 0, 0, 1761, 1763, 1, 0, 0, 0, 1762,
		1751, 1, 0, 0, 0, 1762, 1757, 1, 0, 0, 0, 1763, 177, 1, 0, 0, 0, 1764,
		1765, 5, 215, 0, 0, 1765, 1779, 5, 267, 0, 0, 1766, 1767, 3, 166, 83, 0,
		1767, 1768, 5, 271, 0, 0, 1768, 1776, 3, 166, 83, 0, 1769, 1770, 5, 271,
		0, 0, 1770, 1771, 3, 166, 83, 0, 1771, 1772, 5, 271, 0, 0, 1772, 1773,
		3, 166, 83, 0, 1773, 1775, 1, 0, 0, 0, 1774, 1769, 1, 0, 0, 0, 1775, 1778,
		1, 0, 0, 0, 1776, 1774, 1, 0, 0, 0, 1776, 1777, 1, 0, 0, 0, 1777, 1780,
		1, 0, 0, 0, 1778, 1776, 1, 0, 0, 0, 1779, 1766, 1, 0, 0, 0, 1779, 1780,
		1, 0, 0, 0, 1780, 1781, 1, 0, 0, 0, 1781, 1782, 5, 268, 0, 0, 1782, 179,
		1, 0, 0, 0, 1783, 1784, 5, 216, 0, 0, 1784, 1785, 5, 265, 0, 0, 1785, 1786,
		3, 194, 97, 0, 1786, 1787, 5, 266, 0, 0, 1787, 1799, 1, 0, 0, 0, 1788,
		1789, 5, 217, 0, 0, 1789, 1790, 5, 265, 0, 0, 1790, 1791, 3, 194, 97, 0,
		1791, 1792, 5, 266, 0, 0, 1792, 1799, 1, 0, 0, 0, 1793, 1794, 5, 148, 0,
		0, 1794, 1795, 5, 265, 0, 0, 1795, 1796, 3, 194, 97, 0, 1796, 1797, 5,
		266, 0, 0, 1797, 1799, 1, 0, 0, 0, 1798, 1783, 1, 0, 0, 0, 1798, 1788,
		1, 0, 0, 0, 1798, 1793, 1, 0, 0, 0, 1799, 181, 1, 0, 0, 0, 1800, 1801,
		3, 202, 101, 0, 1801, 1807, 5, 265, 0, 0, 1802, 1804, 5, 173, 0, 0, 1803,
		1802, 1, 0, 0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805,
		1808, 3, 194, 97, 0, 1806, 1808, 5, 251, 0, 0, 1807, 1803, 1, 0, 0, 0,
		1807, 1806, 1, 0, 0, 0, 1807, 1808, 1, 0, 0, 0, 1808, 1809, 1, 0, 0, 0,
		1809, 1811, 5, 266, 0, 0, 1810, 1812, 3, 184, 92, 0, 1811, 1810, 1, 0,
		0, 0, 1811, 1812, 1, 0, 0, 0, 1812, 1824, 1, 0, 0, 0, 1813, 1814, 3, 202,
		101, 0, 1814, 1815, 5, 265, 0, 0, 1815, 1816, 3, 194, 97, 0, 1816, 1817,
		5, 266, 0, 0, 1817, 1818, 5, 175, 0, 0, 1818, 1819, 5, 156, 0, 0, 1819,
		1820, 5, 265, 0, 0, 1820, 1821, 3, 50, 25, 0, 1821, 1822, 5, 266, 0, 0,
		1822, 1824, 1, 0, 0, 0, 1823, 1800, 1, 0, 0, 0, 1823, 1813, 1, 0, 0, 0,
		1824, 183, 1, 0, 0, 0, 1825, 1826, 5, 139, 0, 0, 1826, 1828, 5, 265, 0,
		0, 1827, 1829, 3, 186, 93, 0, 1828, 1827, 1, 0, 0, 0, 1828, 1829, 1, 0,
		0, 0, 1829, 1831, 1, 0, 0, 0, 1830, 1832, 3, 50, 25, 0, 1831, 1830, 1,
		0, 0, 0, 1831, 1832, 1, 0, 0, 0, 1832, 1834, 1, 0, 0, 0, 1833, 1835, 3,
		188, 94, 0, 1834, 1833, 1, 0, 0, 0, 1834, 1835, 1, 0, 0, 0, 1835, 1836,
		1, 0, 0, 0, 1836, 1840, 5, 266, 0, 0, 1837, 1838, 5, 139, 0, 0, 1838, 1840,
		3, 206, 103, 0, 1839, 1825, 1, 0, 0, 0, 1839, 1837, 1, 0, 0, 0, 1840, 185,
		1, 0, 0, 0, 1841, 1842, 5, 140, 0, 0, 1842, 1843, 5, 157, 0, 0, 1843, 1844,
		3, 194, 97, 0, 1844, 187, 1, 0, 0, 0, 1845, 1846, 7, 26, 0, 0, 1846, 1854,
		3, 190, 95, 0, 1847, 1848, 7, 26, 0, 0, 1848, 1849, 5, 185, 0, 0, 1849,
		1850, 3, 190, 95, 0, 1850, 1851, 5, 4, 0, 0, 1851, 1852, 3, 190, 95, 0,
		1852, 1854, 1, 0, 0, 0, 1853, 1845, 1, 0, 0, 0, 1853, 1847, 1, 0, 0, 0,
		1854, 189, 1, 0, 0, 0, 1855, 1856, 5, 144, 0, 0, 1856, 1868, 5, 145, 0,
		0, 1857, 1858, 5, 144, 0, 0, 1858, 1868, 5, 146, 0, 0, 1859, 1860, 5, 147,
		0, 0, 1860, 1868, 5, 148, 0, 0, 1861, 1862, 3, 166, 83, 0, 1862, 1863,
		5, 145, 0, 0, 1863, 1868, 1, 0, 0, 0, 1864, 1865, 3, 166, 83, 0, 1865,
		1866, 5, 146, 0, 0, 1866, 1868, 1, 0, 0, 0, 1867, 1855, 1, 0, 0, 0, 1867,
		1857, 1, 0, 0, 0, 1867, 1859, 1, 0, 0, 0, 1867, 1861, 1, 0, 0, 0, 1867,
		1864, 1, 0, 0, 0, 1868, 191, 1, 0, 0, 0, 1869, 1870, 3, 196, 98, 0, 1870,
		1871, 5, 272, 0, 0, 1871, 1873, 1, 0, 0, 0, 1872, 1869, 1, 0, 0, 0, 1872,
		1873, 1, 0, 0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 1875, 3, 200, 100, 0, 1875,
		193, 1, 0, 0, 0, 1876, 1881, 3, 166, 83, 0, 1877, 1878, 5, 271, 0, 0, 1878,
		1880, 3, 166, 83, 0, 1879, 1877, 1, 0, 0, 0, 1880, 1883, 1, 0, 0, 0, 1881,
		1879, 1, 0, 0, 0, 1881, 1882, 1, 0, 0, 0, 1882, 195, 1, 0, 0, 0, 1883,
		1881, 1, 0, 0, 0, 1884, 1885, 3, 198, 99, 0, 1885, 1886, 5, 272, 0, 0,
		1886, 1888, 1, 0, 0, 0, 1887, 1884, 1, 0, 0, 0, 1887, 1888, 1, 0, 0, 0,
		1888, 1889, 1, 0, 0, 0, 1889, 1890, 3, 206, 103, 0, 1890, 197, 1, 0, 0,
		0, 1891, 1892, 3, 206, 103, 0, 1892, 199, 1, 0, 0, 0, 1893, 1894, 3, 206,
		103, 0, 1894, 201, 1, 0, 0, 0, 1895, 1896, 3, 206, 103, 0, 1896, 203, 1,
		0, 0, 0, 1897, 1898, 3, 206, 103, 0, 1898, 205, 1, 0, 0, 0, 1899, 1905,
		5, 281, 0, 0, 1900, 1905, 5, 282, 0, 0, 1901, 1905, 5, 283, 0, 0, 1902,
		1905, 5, 277, 0, 0, 1903, 1905, 3, 208, 104, 0, 1904, 1899, 1, 0, 0, 0,
		1904, 1900, 1, 0, 0, 0, 1904, 1901, 1, 0, 0, 0, 1904, 1902, 1, 0, 0, 0,
		1904, 1903, 1, 0, 0, 0, 1905, 207, 1, 0, 0, 0, 1906, 1907, 7, 27, 0, 0,
		1907, 209, 1, 0, 0, 0, 1908, 1921, 5, 276, 0, 0, 1909, 1921, 5, 278, 0,
		0, 1910, 1921, 5, 279, 0, 0, 1911, 1921, 5, 280, 0, 0, 1912, 1921, 5, 193,
		0, 0, 1913, 1921, 5, 194, 0, 0, 1914, 1921, 5, 182, 0, 0, 1915, 1916, 5,
		200, 0, 0, 1916, 1918, 5, 276, 0, 0, 1917, 1919, 3, 206, 103, 0, 1918,
		1917, 1, 0, 0, 0, 1918, 1919, 1, 0, 0, 0, 1919, 1921, 1, 0, 0, 0, 1920,
		1908, 1, 0, 0, 0, 1920, 1909, 1, 0, 0, 0, 1920, 1910, 1, 0, 0, 0, 1920,
		1911, 1, 0, 0, 0, 1920, 1912, 1, 0, 0, 0, 1920, 1913, 1, 0, 0, 0, 1920,
		1914, 1, 0, 0, 0, 1920, 1915, 1, 0, 0, 0, 1921, 211, 1, 0, 0, 0, 252, 217,
		221, 227, 235, 240, 247, 252, 256, 260, 263, 266, 269, 272, 275, 281, 285,
		292, 302, 307, 316, 320, 329, 339, 342, 344, 354, 361, 366, 369, 372, 375,
		381, 384, 391, 394, 401, 404, 411, 414, 416, 429, 434, 447, 452, 465, 470,
		474, 478, 486, 500, 510, 522, 527, 531, 537, 547, 555, 557, 561, 564, 568,
		571, 575, 578, 587, 595, 603, 614, 630, 636, 639, 647, 651, 654, 664, 667,
		670, 674, 682, 685, 690, 693, 700, 706, 714, 723, 727, 736, 741, 752, 756,
		759, 765, 772, 775, 778, 781, 784, 787, 790, 793, 796, 799, 802, 805, 808,
		811, 814, 818, 821, 824, 828, 835, 841, 854, 859, 881, 893, 898, 907, 910,
		917, 924, 932, 945, 948, 950, 959, 962, 970, 976, 982, 987, 993, 995, 1003,
		1008, 1019, 1022, 1029, 1034, 1037, 1041, 1044, 1050, 1056, 1061, 1065,
		1075, 1085, 1098, 1103, 1112, 1117, 1127, 1139, 1144, 1147, 1158, 1168,
		1181, 1186, 1196, 1208, 1213, 1218, 1229, 1236, 1240, 1250, 1258, 1267,
		1274, 1279, 1282, 1285, 1290, 1293, 1298, 1302, 1315, 1330, 1334, 1344,
		1364, 1374, 1379, 1382, 1388, 1397, 1402, 1406, 1416, 1421, 1424, 1428,
		1432, 1438, 1449, 1456, 1462, 1469, 1476, 1483, 1488, 1490, 1500, 1515,
		1519, 1524, 1529, 1540, 1545, 1564, 1568, 1605, 1624, 1658, 1664, 1669,
		1675, 1681, 1689, 1694, 1696, 1698, 1715, 1730, 1734, 1743, 1747, 1754,
		1762, 1776, 1779, 1798, 1803, 1807, 1811, 1823, 1828, 1831, 1834, 1839,
		1853, 1867, 1872, 1881, 1887, 1904, 1918, 1920,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SQLParserInit initializes any static state used to implement SQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SQLParserInit() {
	staticData := &SQLParserParserStaticData
	staticData.once.Do(sqlparserParserInit)
}

// NewSQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSQLParser(input antlr.TokenStream) *SQLParser {
	SQLParserInit()
	this := new(SQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SQLParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SQLParser.g4"

	return this
}

// SQLParser tokens.
const (
	SQLParserEOF                  = antlr.TokenEOF
	SQLParserSELECT               = 1
	SQLParserFROM                 = 2
	SQLParserWHERE                = 3
	SQLParserAND                  = 4
	SQLParserOR                   = 5
	SQLParserNOT                  = 6
	SQLParserAS                   = 7
	SQLParserON                   = 8
	SQLParserJOIN                 = 9
	SQLParserINNER                = 10
	SQLParserLEFT                 = 11
	SQLParserRIGHT                = 12
	SQLParserOUTER                = 13
	SQLParserCROSS                = 14
	SQLParserFULL                 = 15
	SQLParserNATURAL              = 16
	SQLParserSEMI_JOIN            = 17
	SQLParserANTI                 = 18
	SQLParserINSERT               = 19
	SQLParserINTO                 = 20
	SQLParserVALUES               = 21
	SQLParserUPDATE               = 22
	SQLParserSET                  = 23
	SQLParserDELETE               = 24
	SQLParserTRUNCATE             = 25
	SQLParserCREATE               = 26
	SQLParserTABLE                = 27
	SQLParserVIEW                 = 28
	SQLParserDATABASE             = 29
	SQLParserSCHEMA               = 30
	SQLParserDROP                 = 31
	SQLParserALTER                = 32
	SQLParserINDEX                = 33
	SQLParserADD                  = 34
	SQLParserCOLUMN               = 35
	SQLParserRENAME               = 36
	SQLParserTO                   = 37
	SQLParserMODIFY               = 38
	SQLParserCHANGE               = 39
	SQLParserCONSTRAINT           = 40
	SQLParserPRIMARY              = 41
	SQLParserKEY                  = 42
	SQLParserFOREIGN              = 43
	SQLParserREFERENCES           = 44
	SQLParserUNIQUE               = 45
	SQLParserCHECK                = 46
	SQLParserDEFAULT              = 47
	SQLParserAUTO_INCREMENT       = 48
	SQLParserCOMMENT              = 49
	SQLParserIF_P                 = 50
	SQLParserTEMPORARY            = 51
	SQLParserTEMP                 = 52
	SQLParserEXTERNAL             = 53
	SQLParserLOCATION             = 54
	SQLParserSTORED               = 55
	SQLParserFORMAT               = 56
	SQLParserTBLPROPERTIES        = 57
	SQLParserROW_FORMAT           = 58
	SQLParserFIELDS               = 59
	SQLParserTERMINATED           = 60
	SQLParserLINES                = 61
	SQLParserCOLLECTION           = 62
	SQLParserITEMS                = 63
	SQLParserKEYS                 = 64
	SQLParserESCAPED              = 65
	SQLParserSERDE                = 66
	SQLParserSERDEPROPERTIES      = 67
	SQLParserCLUSTERED            = 68
	SQLParserSORTED               = 69
	SQLParserBUCKETS              = 70
	SQLParserSKEWED               = 71
	SQLParserPARTITIONED          = 72
	SQLParserWATERMARK            = 73
	SQLParserFOR                  = 74
	SQLParserSYSTEM_TIME          = 75
	SQLParserSYSTEM               = 76
	SQLParserENFORCED             = 77
	SQLParserMETADATA             = 78
	SQLParserVIRTUAL              = 79
	SQLParserCONNECTOR            = 80
	SQLParserOPTIONS              = 81
	SQLParserWITHOUT              = 82
	SQLParserPERIOD               = 83
	SQLParserVERSIONING           = 84
	SQLParserGENERATED            = 85
	SQLParserALWAYS               = 86
	SQLParserIDENTITY             = 87
	SQLParserSTART                = 88
	SQLParserINCREMENT            = 89
	SQLParserMINVALUE             = 90
	SQLParserMAXVALUE             = 91
	SQLParserCYCLE                = 92
	SQLParserCACHE                = 93
	SQLParserMERGE                = 94
	SQLParserUSING                = 95
	SQLParserMATCHED              = 96
	SQLParserUPSERT               = 97
	SQLParserOVERWRITE            = 98
	SQLParserREPLACE              = 99
	SQLParserIGNORE               = 100
	SQLParserDUPLICATE            = 101
	SQLParserLATERAL              = 102
	SQLParserUNNEST               = 103
	SQLParserEXPLODE              = 104
	SQLParserPOSEXPLODE           = 105
	SQLParserINLINE               = 106
	SQLParserSTACK                = 107
	SQLParserTABLESAMPLE          = 108
	SQLParserPERCENT              = 109
	SQLParserBUCKET               = 110
	SQLParserOUT                  = 111
	SQLParserOF                   = 112
	SQLParserDISTRIBUTED          = 113
	SQLParserHASH                 = 114
	SQLParserRANDOM               = 115
	SQLParserBROADCAST            = 116
	SQLParserREPLICATED           = 117
	SQLParserPROPERTIES           = 118
	SQLParserENGINE               = 119
	SQLParserCHARSET              = 120
	SQLParserCHARACTER            = 121
	SQLParserCOLLATE              = 122
	SQLParserTABLESPACE           = 123
	SQLParserINHERITS             = 124
	SQLParserFILEGROUP            = 125
	SQLParserCLUSTERED_INDEX      = 126
	SQLParserON_COMMIT            = 127
	SQLParserPRESERVE             = 128
	SQLParserGLOBAL               = 129
	SQLParserLOCAL                = 130
	SQLParserUNLOGGED             = 131
	SQLParserTTL                  = 132
	SQLParserLIFECYCLE            = 133
	SQLParserAUTO                 = 134
	SQLParserINCR                 = 135
	SQLParserRESTRICT             = 136
	SQLParserCASCADE              = 137
	SQLParserACTION               = 138
	SQLParserOVER                 = 139
	SQLParserPARTITION            = 140
	SQLParserROWS                 = 141
	SQLParserRANGE                = 142
	SQLParserGROUPS               = 143
	SQLParserUNBOUNDED            = 144
	SQLParserPRECEDING            = 145
	SQLParserFOLLOWING            = 146
	SQLParserCURRENT              = 147
	SQLParserROW                  = 148
	SQLParserFIRST                = 149
	SQLParserLAST                 = 150
	SQLParserNULLS                = 151
	SQLParserEXCLUDE              = 152
	SQLParserTIES                 = 153
	SQLParserNO                   = 154
	SQLParserOTHERS               = 155
	SQLParserGROUP                = 156
	SQLParserBY                   = 157
	SQLParserORDER                = 158
	SQLParserASC                  = 159
	SQLParserDESC                 = 160
	SQLParserHAVING               = 161
	SQLParserLIMIT                = 162
	SQLParserOFFSET               = 163
	SQLParserFETCH                = 164
	SQLParserNEXT                 = 165
	SQLParserONLY                 = 166
	SQLParserTOP                  = 167
	SQLParserUNION                = 168
	SQLParserINTERSECT            = 169
	SQLParserEXCEPT               = 170
	SQLParserMINUS_SET            = 171
	SQLParserALL                  = 172
	SQLParserDISTINCT             = 173
	SQLParserWITH                 = 174
	SQLParserWITHIN               = 175
	SQLParserRECURSIVE            = 176
	SQLParserCASE                 = 177
	SQLParserWHEN                 = 178
	SQLParserTHEN                 = 179
	SQLParserELSE                 = 180
	SQLParserEND                  = 181
	SQLParserNULL                 = 182
	SQLParserIS                   = 183
	SQLParserIN                   = 184
	SQLParserBETWEEN              = 185
	SQLParserLIKE                 = 186
	SQLParserILIKE                = 187
	SQLParserRLIKE                = 188
	SQLParserREGEXP               = 189
	SQLParserSIMILAR              = 190
	SQLParserESCAPE               = 191
	SQLParserEXISTS               = 192
	SQLParserTRUE                 = 193
	SQLParserFALSE                = 194
	SQLParserUNKNOWN              = 195
	SQLParserCAST                 = 196
	SQLParserCONVERT              = 197
	SQLParserTRY_CAST             = 198
	SQLParserEXTRACT              = 199
	SQLParserINTERVAL             = 200
	SQLParserAT                   = 201
	SQLParserZONE                 = 202
	SQLParserTIME                 = 203
	SQLParserTIMESTAMP            = 204
	SQLParserDATE                 = 205
	SQLParserYEAR                 = 206
	SQLParserMONTH                = 207
	SQLParserDAY                  = 208
	SQLParserHOUR                 = 209
	SQLParserMINUTE               = 210
	SQLParserSECOND               = 211
	SQLParserSOME                 = 212
	SQLParserANY                  = 213
	SQLParserARRAY                = 214
	SQLParserMAP                  = 215
	SQLParserSTRUCT               = 216
	SQLParserNAMED_STRUCT         = 217
	SQLParserINT                  = 218
	SQLParserINTEGER              = 219
	SQLParserTINYINT              = 220
	SQLParserSMALLINT             = 221
	SQLParserBIGINT               = 222
	SQLParserFLOAT                = 223
	SQLParserDOUBLE               = 224
	SQLParserDECIMAL              = 225
	SQLParserNUMERIC              = 226
	SQLParserREAL                 = 227
	SQLParserBOOLEAN              = 228
	SQLParserBOOL                 = 229
	SQLParserSTRING               = 230
	SQLParserVARCHAR              = 231
	SQLParserCHAR                 = 232
	SQLParserTEXT                 = 233
	SQLParserBINARY               = 234
	SQLParserVARBINARY            = 235
	SQLParserBLOB                 = 236
	SQLParserCLOB                 = 237
	SQLParserJSON                 = 238
	SQLParserXML                  = 239
	SQLParserBYTES                = 240
	SQLParserMULTISET             = 241
	SQLParserRAW                  = 242
	SQLParserEQ                   = 243
	SQLParserNEQ                  = 244
	SQLParserLT                   = 245
	SQLParserLTE                  = 246
	SQLParserGT                   = 247
	SQLParserGTE                  = 248
	SQLParserPLUS                 = 249
	SQLParserMINUS                = 250
	SQLParserSTAR                 = 251
	SQLParserDIV                  = 252
	SQLParserMOD                  = 253
	SQLParserCONCAT               = 254
	SQLParserAMPERSAND            = 255
	SQLParserPIPE                 = 256
	SQLParserCARET                = 257
	SQLParserTILDE                = 258
	SQLParserDOUBLE_COLON         = 259
	SQLParserARROW                = 260
	SQLParserDOUBLE_ARROW         = 261
	SQLParserAT_SIGN              = 262
	SQLParserHASH_SIGN            = 263
	SQLParserDOLLAR               = 264
	SQLParserLPAREN               = 265
	SQLParserRPAREN               = 266
	SQLParserLBRACKET             = 267
	SQLParserRBRACKET             = 268
	SQLParserLBRACE               = 269
	SQLParserRBRACE               = 270
	SQLParserCOMMA                = 271
	SQLParserDOT                  = 272
	SQLParserSEMI                 = 273
	SQLParserCOLON                = 274
	SQLParserQUESTION             = 275
	SQLParserSTRING_LITERAL       = 276
	SQLParserDOUBLE_QUOTED_STRING = 277
	SQLParserNUMBER               = 278
	SQLParserHEX_NUMBER           = 279
	SQLParserBIT_STRING           = 280
	SQLParserIDENTIFIER           = 281
	SQLParserBACKTICK_IDENTIFIER  = 282
	SQLParserBRACKET_IDENTIFIER   = 283
	SQLParserVARIABLE             = 284
	SQLParserSYSTEM_VARIABLE      = 285
	SQLParserWS                   = 286
	SQLParserLINE_COMMENT         = 287
	SQLParserBLOCK_COMMENT        = 288
	SQLParserHINT_COMMENT         = 289
)

// SQLParser rules.
const (
	SQLParserRULE_sqlStatements           = 0
	SQLParserRULE_sqlStatement            = 1
	SQLParserRULE_dmlStatement            = 2
	SQLParserRULE_ddlStatement            = 3
	SQLParserRULE_selectStatement         = 4
	SQLParserRULE_queryExpression         = 5
	SQLParserRULE_queryTerm               = 6
	SQLParserRULE_withClause              = 7
	SQLParserRULE_cteDefinition           = 8
	SQLParserRULE_selectClause            = 9
	SQLParserRULE_selectElements          = 10
	SQLParserRULE_selectElement           = 11
	SQLParserRULE_fromClause              = 12
	SQLParserRULE_tableReferences         = 13
	SQLParserRULE_tableReference          = 14
	SQLParserRULE_tableFactor             = 15
	SQLParserRULE_tableSample             = 16
	SQLParserRULE_joinPart                = 17
	SQLParserRULE_temporalJoinClause      = 18
	SQLParserRULE_joinType                = 19
	SQLParserRULE_whereClause             = 20
	SQLParserRULE_groupByClause           = 21
	SQLParserRULE_groupByElements         = 22
	SQLParserRULE_groupByElement          = 23
	SQLParserRULE_havingClause            = 24
	SQLParserRULE_orderByClause           = 25
	SQLParserRULE_orderByElement          = 26
	SQLParserRULE_limitClause             = 27
	SQLParserRULE_insertStatement         = 28
	SQLParserRULE_partitionSpec           = 29
	SQLParserRULE_partitionElement        = 30
	SQLParserRULE_columnList              = 31
	SQLParserRULE_valuesClause            = 32
	SQLParserRULE_valueRow                = 33
	SQLParserRULE_onDuplicateKeyUpdate    = 34
	SQLParserRULE_updateStatement         = 35
	SQLParserRULE_updateElement           = 36
	SQLParserRULE_deleteStatement         = 37
	SQLParserRULE_truncateStatement       = 38
	SQLParserRULE_mergeStatement          = 39
	SQLParserRULE_mergeClause             = 40
	SQLParserRULE_mergeUpdateClause       = 41
	SQLParserRULE_mergeInsertClause       = 42
	SQLParserRULE_createStatement         = 43
	SQLParserRULE_createTableStatement    = 44
	SQLParserRULE_tableElementList        = 45
	SQLParserRULE_tableElement            = 46
	SQLParserRULE_watermarkDefinition     = 47
	SQLParserRULE_columnDefinition        = 48
	SQLParserRULE_dataType                = 49
	SQLParserRULE_primitiveType           = 50
	SQLParserRULE_structField             = 51
	SQLParserRULE_columnConstraint        = 52
	SQLParserRULE_identityOptions         = 53
	SQLParserRULE_referentialAction       = 54
	SQLParserRULE_referentialActionType   = 55
	SQLParserRULE_notEnforced             = 56
	SQLParserRULE_tableConstraint         = 57
	SQLParserRULE_partitionedByClause     = 58
	SQLParserRULE_clusteredByClause       = 59
	SQLParserRULE_distributedByClause     = 60
	SQLParserRULE_sortedByClause          = 61
	SQLParserRULE_tableInheritsClause     = 62
	SQLParserRULE_engineClause            = 63
	SQLParserRULE_charsetClause           = 64
	SQLParserRULE_collateClause           = 65
	SQLParserRULE_tablespaceClause        = 66
	SQLParserRULE_ttlClause               = 67
	SQLParserRULE_lifecycleClause         = 68
	SQLParserRULE_rowFormatClause         = 69
	SQLParserRULE_storedAsClause          = 70
	SQLParserRULE_locationClause          = 71
	SQLParserRULE_tablePropertiesClause   = 72
	SQLParserRULE_withOptionsClause       = 73
	SQLParserRULE_propertyList            = 74
	SQLParserRULE_property                = 75
	SQLParserRULE_createViewStatement     = 76
	SQLParserRULE_createDatabaseStatement = 77
	SQLParserRULE_createIndexStatement    = 78
	SQLParserRULE_indexColumn             = 79
	SQLParserRULE_dropStatement           = 80
	SQLParserRULE_alterStatement          = 81
	SQLParserRULE_alterTableAction        = 82
	SQLParserRULE_expression              = 83
	SQLParserRULE_castExpression          = 84
	SQLParserRULE_extractExpression       = 85
	SQLParserRULE_intervalExpression      = 86
	SQLParserRULE_caseExpression          = 87
	SQLParserRULE_arrayConstructor        = 88
	SQLParserRULE_mapConstructor          = 89
	SQLParserRULE_structConstructor       = 90
	SQLParserRULE_functionCall            = 91
	SQLParserRULE_overClause              = 92
	SQLParserRULE_partitionByClause       = 93
	SQLParserRULE_windowFrame             = 94
	SQLParserRULE_windowFrameBound        = 95
	SQLParserRULE_columnRef               = 96
	SQLParserRULE_expressionList          = 97
	SQLParserRULE_tableName               = 98
	SQLParserRULE_databaseName            = 99
	SQLParserRULE_columnName              = 100
	SQLParserRULE_functionName            = 101
	SQLParserRULE_alias                   = 102
	SQLParserRULE_identifier              = 103
	SQLParserRULE_nonReservedKeyword      = 104
	SQLParserRULE_literal                 = 105
)

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSqlStatement() []ISqlStatementContext
	SqlStatement(i int) ISqlStatementContext
	EOF() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) AllSqlStatement() []ISqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqlStatementContext); ok {
			len++
		}
	}

	tst := make([]ISqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqlStatementContext); ok {
			tst[i] = t.(ISqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SqlStatement(i int) ISqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *SqlStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(SQLParserEOF, 0)
}

func (s *SqlStatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SQLParserSEMI)
}

func (s *SqlStatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserSEMI, i)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SQLParserRULE_sqlStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(212)
		p.SqlStatement()
	}
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(213)
				p.Match(SQLParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(214)
				p.SqlStatement()
			}

		}
		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserSEMI {
		{
			p.SetState(220)
			p.Match(SQLParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(223)
		p.Match(SQLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DmlStatement() IDmlStatementContext
	DdlStatement() IDdlStatementContext

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_sqlStatement
	return p
}

func InitEmptySqlStatementContext(p *SqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_sqlStatement
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *SqlStatementContext) DdlStatement() IDdlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDdlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDdlStatementContext)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSqlStatement(s)
	}
}

func (s *SqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSqlStatement(s)
	}
}

func (s *SqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) SqlStatement() (localctx ISqlStatementContext) {
	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SQLParserRULE_sqlStatement)
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserSELECT, SQLParserINSERT, SQLParserUPDATE, SQLParserDELETE, SQLParserTRUNCATE, SQLParserMERGE, SQLParserWITH, SQLParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(225)
			p.DmlStatement()
		}

	case SQLParserCREATE, SQLParserDROP, SQLParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(226)
			p.DdlStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStatement() ISelectStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	MergeStatement() IMergeStatementContext
	TruncateStatement() ITruncateStatementContext

	// IsDmlStatementContext differentiates from other interfaces.
	IsDmlStatementContext()
}

type DmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext {
	var p = new(DmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_dmlStatement
	return p
}

func InitEmptyDmlStatementContext(p *DmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_dmlStatement
}

func (*DmlStatementContext) IsDmlStatementContext() {}

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext {
	var p = new(DmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_dmlStatement

	return p
}

func (s *DmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DmlStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DmlStatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *DmlStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DmlStatementContext) MergeStatement() IMergeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeStatementContext)
}

func (s *DmlStatementContext) TruncateStatement() ITruncateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateStatementContext)
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterDmlStatement(s)
	}
}

func (s *DmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitDmlStatement(s)
	}
}

func (s *DmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitDmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) DmlStatement() (localctx IDmlStatementContext) {
	localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SQLParserRULE_dmlStatement)
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserSELECT, SQLParserWITH, SQLParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(229)
			p.SelectStatement()
		}

	case SQLParserINSERT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(230)
			p.InsertStatement()
		}

	case SQLParserUPDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(231)
			p.UpdateStatement()
		}

	case SQLParserDELETE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(232)
			p.DeleteStatement()
		}

	case SQLParserMERGE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(233)
			p.MergeStatement()
		}

	case SQLParserTRUNCATE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(234)
			p.TruncateStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDdlStatementContext is an interface to support dynamic dispatch.
type IDdlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateStatement() ICreateStatementContext
	DropStatement() IDropStatementContext
	AlterStatement() IAlterStatementContext

	// IsDdlStatementContext differentiates from other interfaces.
	IsDdlStatementContext()
}

type DdlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDdlStatementContext() *DdlStatementContext {
	var p = new(DdlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_ddlStatement
	return p
}

func InitEmptyDdlStatementContext(p *DdlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_ddlStatement
}

func (*DdlStatementContext) IsDdlStatementContext() {}

func NewDdlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DdlStatementContext {
	var p = new(DdlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_ddlStatement

	return p
}

func (s *DdlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DdlStatementContext) CreateStatement() ICreateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateStatementContext)
}

func (s *DdlStatementContext) DropStatement() IDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStatementContext)
}

func (s *DdlStatementContext) AlterStatement() IAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementContext)
}

func (s *DdlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DdlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DdlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterDdlStatement(s)
	}
}

func (s *DdlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitDdlStatement(s)
	}
}

func (s *DdlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitDdlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) DdlStatement() (localctx IDdlStatementContext) {
	localctx = NewDdlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SQLParserRULE_ddlStatement)
	p.SetState(240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserCREATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(237)
			p.CreateStatement()
		}

	case SQLParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(238)
			p.DropStatement()
		}

	case SQLParserALTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(239)
			p.AlterStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpression() IQueryExpressionContext

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSelectStatement(s)
	}
}

func (s *SelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSelectStatement(s)
	}
}

func (s *SelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SQLParserRULE_selectStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.QueryExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQueryTerm() []IQueryTermContext
	QueryTerm(i int) IQueryTermContext
	AllUNION() []antlr.TerminalNode
	UNION(i int) antlr.TerminalNode
	AllINTERSECT() []antlr.TerminalNode
	INTERSECT(i int) antlr.TerminalNode
	AllEXCEPT() []antlr.TerminalNode
	EXCEPT(i int) antlr.TerminalNode
	AllMINUS_SET() []antlr.TerminalNode
	MINUS_SET(i int) antlr.TerminalNode
	AllALL() []antlr.TerminalNode
	ALL(i int) antlr.TerminalNode

	// IsQueryExpressionContext differentiates from other interfaces.
	IsQueryExpressionContext()
}

type QueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext {
	var p = new(QueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_queryExpression
	return p
}

func InitEmptyQueryExpressionContext(p *QueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_queryExpression
}

func (*QueryExpressionContext) IsQueryExpressionContext() {}

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_queryExpression

	return p
}

func (s *QueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *QueryExpressionContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryExpressionContext) AllUNION() []antlr.TerminalNode {
	return s.GetTokens(SQLParserUNION)
}

func (s *QueryExpressionContext) UNION(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserUNION, i)
}

func (s *QueryExpressionContext) AllINTERSECT() []antlr.TerminalNode {
	return s.GetTokens(SQLParserINTERSECT)
}

func (s *QueryExpressionContext) INTERSECT(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserINTERSECT, i)
}

func (s *QueryExpressionContext) AllEXCEPT() []antlr.TerminalNode {
	return s.GetTokens(SQLParserEXCEPT)
}

func (s *QueryExpressionContext) EXCEPT(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserEXCEPT, i)
}

func (s *QueryExpressionContext) AllMINUS_SET() []antlr.TerminalNode {
	return s.GetTokens(SQLParserMINUS_SET)
}

func (s *QueryExpressionContext) MINUS_SET(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserMINUS_SET, i)
}

func (s *QueryExpressionContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(SQLParserALL)
}

func (s *QueryExpressionContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserALL, i)
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) QueryExpression() (localctx IQueryExpressionContext) {
	localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SQLParserRULE_queryExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(244)
		p.QueryTerm()
	}
	p.SetState(252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-168)) & ^0x3f) == 0 && ((int64(1)<<(_la-168))&15) != 0 {
		{
			p.SetState(245)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-168)) & ^0x3f) == 0 && ((int64(1)<<(_la-168))&15) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserALL {
			{
				p.SetState(246)
				p.Match(SQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(249)
			p.QueryTerm()
		}

		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectClause() ISelectClauseContext
	WithClause() IWithClauseContext
	FromClause() IFromClauseContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	LPAREN() antlr.TerminalNode
	QueryExpression() IQueryExpressionContext
	RPAREN() antlr.TerminalNode

	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *QueryTermContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryTermContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QueryTermContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QueryTermContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QueryTermContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QueryTermContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QueryTermContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryTermContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *QueryTermContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryTermContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterQueryTerm(s)
	}
}

func (s *QueryTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitQueryTerm(s)
	}
}

func (s *QueryTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitQueryTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) QueryTerm() (localctx IQueryTermContext) {
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SQLParserRULE_queryTerm)
	var _la int

	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserSELECT, SQLParserWITH:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserWITH {
			{
				p.SetState(255)
				p.WithClause()
			}

		}
		{
			p.SetState(258)
			p.SelectClause()
		}
		p.SetState(260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserFROM {
			{
				p.SetState(259)
				p.FromClause()
			}

		}
		p.SetState(263)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserWHERE {
			{
				p.SetState(262)
				p.WhereClause()
			}

		}
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserGROUP {
			{
				p.SetState(265)
				p.GroupByClause()
			}

		}
		p.SetState(269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserHAVING {
			{
				p.SetState(268)
				p.HavingClause()
			}

		}
		p.SetState(272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserORDER {
			{
				p.SetState(271)
				p.OrderByClause()
			}

		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserLIMIT || _la == SQLParserOFFSET {
			{
				p.SetState(274)
				p.LimitClause()
			}

		}

	case SQLParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(277)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			p.QueryExpression()
		}
		{
			p.SetState(279)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCteDefinition() []ICteDefinitionContext
	CteDefinition(i int) ICteDefinitionContext
	RECURSIVE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLParserWITH, 0)
}

func (s *WithClauseContext) AllCteDefinition() []ICteDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICteDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICteDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICteDefinitionContext); ok {
			tst[i] = t.(ICteDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) CteDefinition(i int) ICteDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteDefinitionContext)
}

func (s *WithClauseContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SQLParserRECURSIVE, 0)
}

func (s *WithClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *WithClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SQLParserRULE_withClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(SQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(285)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(284)
			p.Match(SQLParserRECURSIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(287)
		p.CteDefinition()
	}
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(288)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(289)
			p.CteDefinition()
		}

		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteDefinitionContext is an interface to support dynamic dispatch.
type ICteDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AS() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCteDefinitionContext differentiates from other interfaces.
	IsCteDefinitionContext()
}

type CteDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteDefinitionContext() *CteDefinitionContext {
	var p = new(CteDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_cteDefinition
	return p
}

func InitEmptyCteDefinitionContext(p *CteDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_cteDefinition
}

func (*CteDefinitionContext) IsCteDefinitionContext() {}

func NewCteDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteDefinitionContext {
	var p = new(CteDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_cteDefinition

	return p
}

func (s *CteDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CteDefinitionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CteDefinitionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CteDefinitionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *CteDefinitionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserLPAREN)
}

func (s *CteDefinitionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, i)
}

func (s *CteDefinitionContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CteDefinitionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserRPAREN)
}

func (s *CteDefinitionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, i)
}

func (s *CteDefinitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *CteDefinitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *CteDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCteDefinition(s)
	}
}

func (s *CteDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCteDefinition(s)
	}
}

func (s *CteDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCteDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CteDefinition() (localctx ICteDefinitionContext) {
	localctx = NewCteDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SQLParserRULE_cteDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.Identifier()
	}
	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserLPAREN {
		{
			p.SetState(296)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(297)
			p.Identifier()
		}
		p.SetState(302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(298)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(299)
				p.Identifier()
			}

			p.SetState(304)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(305)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(309)
		p.Match(SQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(310)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(311)
		p.SelectStatement()
	}
	{
		p.SetState(312)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	TOP() antlr.TerminalNode
	Expression() IExpressionContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLParserSELECT, 0)
}

func (s *SelectClauseContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *SelectClauseContext) TOP() antlr.TerminalNode {
	return s.GetToken(SQLParserTOP, 0)
}

func (s *SelectClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLParserALL, 0)
}

func (s *SelectClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLParserDISTINCT, 0)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SQLParserRULE_selectClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.Match(SQLParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(315)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserALL || _la == SQLParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(318)
			p.Match(SQLParserTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(319)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(322)
		p.SelectElements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectElement() []ISelectElementContext
	SelectElement(i int) ISelectElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_selectElements
	return p
}

func InitEmptySelectElementsContext(p *SelectElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_selectElements
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSelectElements(s)
	}
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSelectElements(s)
	}
}

func (s *SelectElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSelectElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) SelectElements() (localctx ISelectElementsContext) {
	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SQLParserRULE_selectElements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.SelectElement()
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(325)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(326)
			p.SelectElement()
		}

		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_selectElement
	return p
}

func InitEmptySelectElementContext(p *SelectElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_selectElement
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) CopyAll(ctx *SelectElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	SelectElementContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) STAR() antlr.TerminalNode {
	return s.GetToken(SQLParserSTAR, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

func (s *SelectAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSelectAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectExprContext struct {
	SelectElementContext
}

func NewSelectExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectExprContext {
	var p = new(SelectExprContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectExprContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *SelectExprContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *SelectExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSelectExpr(s)
	}
}

func (s *SelectExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSelectExpr(s)
	}
}

func (s *SelectExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSelectExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectTableAllContext struct {
	SelectElementContext
}

func NewSelectTableAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectTableAllContext {
	var p = new(SelectTableAllContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectTableAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectTableAllContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SelectTableAllContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLParserDOT, 0)
}

func (s *SelectTableAllContext) STAR() antlr.TerminalNode {
	return s.GetToken(SQLParserSTAR, 0)
}

func (s *SelectTableAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSelectTableAll(s)
	}
}

func (s *SelectTableAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSelectTableAll(s)
	}
}

func (s *SelectTableAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSelectTableAll(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) SelectElement() (localctx ISelectElementContext) {
	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SQLParserRULE_selectElement)
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(332)
			p.Match(SQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSelectTableAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(333)
			p.TableName()
		}
		{
			p.SetState(334)
			p.Match(SQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(335)
			p.Match(SQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSelectExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(337)
			p.expression(0)
		}
		p.SetState(342)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			p.SetState(339)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(338)
					p.Match(SQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(341)
				p.Alias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	TableReferences() ITableReferencesContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLParserFROM, 0)
}

func (s *FromClauseContext) TableReferences() ITableReferencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferencesContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SQLParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Match(SQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(347)
		p.TableReferences()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferencesContext is an interface to support dynamic dispatch.
type ITableReferencesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableReference() []ITableReferenceContext
	TableReference(i int) ITableReferenceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableReferencesContext differentiates from other interfaces.
	IsTableReferencesContext()
}

type TableReferencesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferencesContext() *TableReferencesContext {
	var p = new(TableReferencesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableReferences
	return p
}

func InitEmptyTableReferencesContext(p *TableReferencesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableReferences
}

func (*TableReferencesContext) IsTableReferencesContext() {}

func NewTableReferencesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferencesContext {
	var p = new(TableReferencesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableReferences

	return p
}

func (s *TableReferencesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferencesContext) AllTableReference() []ITableReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableReferenceContext); ok {
			len++
		}
	}

	tst := make([]ITableReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableReferenceContext); ok {
			tst[i] = t.(ITableReferenceContext)
			i++
		}
	}

	return tst
}

func (s *TableReferencesContext) TableReference(i int) ITableReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *TableReferencesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *TableReferencesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *TableReferencesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferencesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferencesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableReferences(s)
	}
}

func (s *TableReferencesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableReferences(s)
	}
}

func (s *TableReferencesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableReferences(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableReferences() (localctx ITableReferencesContext) {
	localctx = NewTableReferencesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SQLParserRULE_tableReferences)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(349)
		p.TableReference()
	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(350)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(351)
			p.TableReference()
		}

		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferenceContext is an interface to support dynamic dispatch.
type ITableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableFactor() ITableFactorContext
	AllJoinPart() []IJoinPartContext
	JoinPart(i int) IJoinPartContext

	// IsTableReferenceContext differentiates from other interfaces.
	IsTableReferenceContext()
}

type TableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceContext() *TableReferenceContext {
	var p = new(TableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableReference
	return p
}

func InitEmptyTableReferenceContext(p *TableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableReference
}

func (*TableReferenceContext) IsTableReferenceContext() {}

func NewTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceContext {
	var p = new(TableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableReference

	return p
}

func (s *TableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceContext) TableFactor() ITableFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *TableReferenceContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableReferenceContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableReference(s)
	}
}

func (s *TableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableReference(s)
	}
}

func (s *TableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableReference() (localctx ITableReferenceContext) {
	localctx = NewTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SQLParserRULE_tableReference)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(357)
		p.TableFactor()
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(358)
				p.JoinPart()
			}

		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFactorContext is an interface to support dynamic dispatch.
type ITableFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableFactorContext differentiates from other interfaces.
	IsTableFactorContext()
}

type TableFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFactorContext() *TableFactorContext {
	var p = new(TableFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableFactor
	return p
}

func InitEmptyTableFactorContext(p *TableFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableFactor
}

func (*TableFactorContext) IsTableFactorContext() {}

func NewTableFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFactorContext {
	var p = new(TableFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableFactor

	return p
}

func (s *TableFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFactorContext) CopyAll(ctx *TableFactorContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnnestFactorContext struct {
	TableFactorContext
}

func NewUnnestFactorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnnestFactorContext {
	var p = new(UnnestFactorContext)

	InitEmptyTableFactorContext(&p.TableFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableFactorContext))

	return p
}

func (s *UnnestFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnnestFactorContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(SQLParserUNNEST, 0)
}

func (s *UnnestFactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *UnnestFactorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnnestFactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *UnnestFactorContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *UnnestFactorContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *UnnestFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterUnnestFactor(s)
	}
}

func (s *UnnestFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitUnnestFactor(s)
	}
}

func (s *UnnestFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitUnnestFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

type LateralSubqueryFactorContext struct {
	TableFactorContext
}

func NewLateralSubqueryFactorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LateralSubqueryFactorContext {
	var p = new(LateralSubqueryFactorContext)

	InitEmptyTableFactorContext(&p.TableFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableFactorContext))

	return p
}

func (s *LateralSubqueryFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralSubqueryFactorContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserLATERAL, 0)
}

func (s *LateralSubqueryFactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *LateralSubqueryFactorContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *LateralSubqueryFactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *LateralSubqueryFactorContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *LateralSubqueryFactorContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *LateralSubqueryFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterLateralSubqueryFactor(s)
	}
}

func (s *LateralSubqueryFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitLateralSubqueryFactor(s)
	}
}

func (s *LateralSubqueryFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitLateralSubqueryFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryFactorContext struct {
	TableFactorContext
}

func NewSubqueryFactorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryFactorContext {
	var p = new(SubqueryFactorContext)

	InitEmptyTableFactorContext(&p.TableFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableFactorContext))

	return p
}

func (s *SubqueryFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryFactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *SubqueryFactorContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryFactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *SubqueryFactorContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *SubqueryFactorContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *SubqueryFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSubqueryFactor(s)
	}
}

func (s *SubqueryFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSubqueryFactor(s)
	}
}

func (s *SubqueryFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSubqueryFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableValuedFunctionFactorContext struct {
	TableFactorContext
}

func NewTableValuedFunctionFactorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableValuedFunctionFactorContext {
	var p = new(TableValuedFunctionFactorContext)

	InitEmptyTableFactorContext(&p.TableFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableFactorContext))

	return p
}

func (s *TableValuedFunctionFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableValuedFunctionFactorContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableValuedFunctionFactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *TableValuedFunctionFactorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *TableValuedFunctionFactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *TableValuedFunctionFactorContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *TableValuedFunctionFactorContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *TableValuedFunctionFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableValuedFunctionFactor(s)
	}
}

func (s *TableValuedFunctionFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableValuedFunctionFactor(s)
	}
}

func (s *TableValuedFunctionFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableValuedFunctionFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableNameFactorContext struct {
	TableFactorContext
}

func NewTableNameFactorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameFactorContext {
	var p = new(TableNameFactorContext)

	InitEmptyTableFactorContext(&p.TableFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableFactorContext))

	return p
}

func (s *TableNameFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameFactorContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableNameFactorContext) TemporalJoinClause() ITemporalJoinClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalJoinClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalJoinClauseContext)
}

func (s *TableNameFactorContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *TableNameFactorContext) TableSample() ITableSampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSampleContext)
}

func (s *TableNameFactorContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *TableNameFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableNameFactor(s)
	}
}

func (s *TableNameFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableNameFactor(s)
	}
}

func (s *TableNameFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableNameFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableFactor() (localctx ITableFactorContext) {
	localctx = NewTableFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SQLParserRULE_tableFactor)
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameFactorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(364)
			p.TableName()
		}
		p.SetState(366)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(365)
				p.TemporalJoinClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(372)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			p.SetState(369)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(368)
					p.Match(SQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(371)
				p.Alias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(374)
				p.TableSample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSubqueryFactorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(377)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(378)
			p.SelectStatement()
		}
		{
			p.SetState(379)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(384)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			p.SetState(381)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(380)
					p.Match(SQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(383)
				p.Alias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewLateralSubqueryFactorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(386)
			p.Match(SQLParserLATERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(387)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(388)
			p.SelectStatement()
		}
		{
			p.SetState(389)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(394)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			p.SetState(391)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(390)
					p.Match(SQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(393)
				p.Alias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewUnnestFactorContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(396)
			p.Match(SQLParserUNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(397)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(398)
			p.expression(0)
		}
		{
			p.SetState(399)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(404)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			p.SetState(401)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(400)
					p.Match(SQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(403)
				p.Alias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewTableValuedFunctionFactorContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(406)
			p.TableName()
		}
		{
			p.SetState(407)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(408)
			p.ExpressionList()
		}
		{
			p.SetState(409)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			p.SetState(411)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(410)
					p.Match(SQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(413)
				p.Alias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSampleContext is an interface to support dynamic dispatch.
type ITableSampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESAMPLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	BUCKET() antlr.TerminalNode
	OUT() antlr.TerminalNode
	OF() antlr.TerminalNode

	// IsTableSampleContext differentiates from other interfaces.
	IsTableSampleContext()
}

type TableSampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSampleContext() *TableSampleContext {
	var p = new(TableSampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableSample
	return p
}

func InitEmptyTableSampleContext(p *TableSampleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableSample
}

func (*TableSampleContext) IsTableSampleContext() {}

func NewTableSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSampleContext {
	var p = new(TableSampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableSample

	return p
}

func (s *TableSampleContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSampleContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLESAMPLE, 0)
}

func (s *TableSampleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *TableSampleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *TableSampleContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(SQLParserNUMBER)
}

func (s *TableSampleContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserNUMBER, i)
}

func (s *TableSampleContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SQLParserPERCENT, 0)
}

func (s *TableSampleContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLParserROWS, 0)
}

func (s *TableSampleContext) BUCKET() antlr.TerminalNode {
	return s.GetToken(SQLParserBUCKET, 0)
}

func (s *TableSampleContext) OUT() antlr.TerminalNode {
	return s.GetToken(SQLParserOUT, 0)
}

func (s *TableSampleContext) OF() antlr.TerminalNode {
	return s.GetToken(SQLParserOF, 0)
}

func (s *TableSampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableSample(s)
	}
}

func (s *TableSampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableSample(s)
	}
}

func (s *TableSampleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableSample(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableSample() (localctx ITableSampleContext) {
	localctx = NewTableSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SQLParserRULE_tableSample)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(418)
		p.Match(SQLParserTABLESAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(419)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(420)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(421)
			p.Match(SQLParserPERCENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(422)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(423)
			p.Match(SQLParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(424)
			p.Match(SQLParserBUCKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(425)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(426)
			p.Match(SQLParserOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.Match(SQLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(428)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(431)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinPartContext is an interface to support dynamic dispatch.
type IJoinPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	TableFactor() ITableFactorContext
	JoinType() IJoinTypeContext
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	USING() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsJoinPartContext differentiates from other interfaces.
	IsJoinPartContext()
}

type JoinPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinPartContext() *JoinPartContext {
	var p = new(JoinPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_joinPart
	return p
}

func InitEmptyJoinPartContext(p *JoinPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_joinPart
}

func (*JoinPartContext) IsJoinPartContext() {}

func NewJoinPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinPartContext {
	var p = new(JoinPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_joinPart

	return p
}

func (s *JoinPartContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinPartContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SQLParserJOIN, 0)
}

func (s *JoinPartContext) TableFactor() ITableFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *JoinPartContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinPartContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLParserON, 0)
}

func (s *JoinPartContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinPartContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLParserUSING, 0)
}

func (s *JoinPartContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *JoinPartContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinPartContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinPartContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *JoinPartContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *JoinPartContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *JoinPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterJoinPart(s)
	}
}

func (s *JoinPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitJoinPart(s)
	}
}

func (s *JoinPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitJoinPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) JoinPart() (localctx IJoinPartContext) {
	localctx = NewJoinPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SQLParserRULE_joinPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&121856) != 0 {
		{
			p.SetState(433)
			p.JoinType()
		}

	}
	{
		p.SetState(436)
		p.Match(SQLParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(437)
		p.TableFactor()
	}
	p.SetState(452)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(438)
			p.Match(SQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(439)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(440)
			p.Match(SQLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(441)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)
			p.Identifier()
		}
		p.SetState(447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(443)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(444)
				p.Identifier()
			}

			p.SetState(449)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(450)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalJoinClauseContext is an interface to support dynamic dispatch.
type ITemporalJoinClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	Expression() IExpressionContext
	SYSTEM() antlr.TerminalNode
	TIME() antlr.TerminalNode

	// IsTemporalJoinClauseContext differentiates from other interfaces.
	IsTemporalJoinClauseContext()
}

type TemporalJoinClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalJoinClauseContext() *TemporalJoinClauseContext {
	var p = new(TemporalJoinClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_temporalJoinClause
	return p
}

func InitEmptyTemporalJoinClauseContext(p *TemporalJoinClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_temporalJoinClause
}

func (*TemporalJoinClauseContext) IsTemporalJoinClauseContext() {}

func NewTemporalJoinClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalJoinClauseContext {
	var p = new(TemporalJoinClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_temporalJoinClause

	return p
}

func (s *TemporalJoinClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalJoinClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLParserFOR, 0)
}

func (s *TemporalJoinClauseContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(SQLParserSYSTEM_TIME, 0)
}

func (s *TemporalJoinClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *TemporalJoinClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(SQLParserOF, 0)
}

func (s *TemporalJoinClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TemporalJoinClauseContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SQLParserSYSTEM, 0)
}

func (s *TemporalJoinClauseContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQLParserTIME, 0)
}

func (s *TemporalJoinClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalJoinClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalJoinClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTemporalJoinClause(s)
	}
}

func (s *TemporalJoinClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTemporalJoinClause(s)
	}
}

func (s *TemporalJoinClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTemporalJoinClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TemporalJoinClause() (localctx ITemporalJoinClauseContext) {
	localctx = NewTemporalJoinClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SQLParserRULE_temporalJoinClause)
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(454)
			p.Match(SQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(455)
			p.Match(SQLParserSYSTEM_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(456)
			p.Match(SQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(457)
			p.Match(SQLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(458)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.Match(SQLParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(460)
			p.Match(SQLParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(461)
			p.Match(SQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(462)
			p.Match(SQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(463)
			p.Match(SQLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(464)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	SEMI_JOIN() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(SQLParserINNER, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SQLParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SQLParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SQLParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLParserFULL, 0)
}

func (s *JoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SQLParserCROSS, 0)
}

func (s *JoinTypeContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SQLParserNATURAL, 0)
}

func (s *JoinTypeContext) SEMI_JOIN() antlr.TerminalNode {
	return s.GetToken(SQLParserSEMI_JOIN, 0)
}

func (s *JoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(SQLParserANTI, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (s *JoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SQLParserRULE_joinType)
	var _la int

	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(467)
			p.Match(SQLParserINNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(468)
			p.Match(SQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserOUTER {
			{
				p.SetState(469)
				p.Match(SQLParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(472)
			p.Match(SQLParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserOUTER {
			{
				p.SetState(473)
				p.Match(SQLParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(476)
			p.Match(SQLParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserOUTER {
			{
				p.SetState(477)
				p.Match(SQLParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(480)
			p.Match(SQLParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(481)
			p.Match(SQLParserNATURAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(482)
			p.Match(SQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(483)
			p.Match(SQLParserSEMI_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(484)
			p.Match(SQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(485)
			p.Match(SQLParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLParserWHERE, 0)
}

func (s *WhereClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SQLParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(488)
		p.Match(SQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(489)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupByElements() IGroupByElementsContext

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *GroupByClauseContext) GroupByElements() IGroupByElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByElementsContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SQLParserRULE_groupByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(SQLParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(492)
		p.Match(SQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(493)
		p.GroupByElements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByElementsContext is an interface to support dynamic dispatch.
type IGroupByElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGroupByElement() []IGroupByElementContext
	GroupByElement(i int) IGroupByElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupByElementsContext differentiates from other interfaces.
	IsGroupByElementsContext()
}

type GroupByElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByElementsContext() *GroupByElementsContext {
	var p = new(GroupByElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_groupByElements
	return p
}

func InitEmptyGroupByElementsContext(p *GroupByElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_groupByElements
}

func (*GroupByElementsContext) IsGroupByElementsContext() {}

func NewGroupByElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByElementsContext {
	var p = new(GroupByElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_groupByElements

	return p
}

func (s *GroupByElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByElementsContext) AllGroupByElement() []IGroupByElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByElementContext); ok {
			len++
		}
	}

	tst := make([]IGroupByElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByElementContext); ok {
			tst[i] = t.(IGroupByElementContext)
			i++
		}
	}

	return tst
}

func (s *GroupByElementsContext) GroupByElement(i int) IGroupByElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByElementContext)
}

func (s *GroupByElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *GroupByElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *GroupByElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterGroupByElements(s)
	}
}

func (s *GroupByElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitGroupByElements(s)
	}
}

func (s *GroupByElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitGroupByElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) GroupByElements() (localctx IGroupByElementsContext) {
	localctx = NewGroupByElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SQLParserRULE_groupByElements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.GroupByElement()
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(496)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)
			p.GroupByElement()
		}

		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByElementContext is an interface to support dynamic dispatch.
type IGroupByElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsGroupByElementContext differentiates from other interfaces.
	IsGroupByElementContext()
}

type GroupByElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByElementContext() *GroupByElementContext {
	var p = new(GroupByElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_groupByElement
	return p
}

func InitEmptyGroupByElementContext(p *GroupByElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_groupByElement
}

func (*GroupByElementContext) IsGroupByElementContext() {}

func NewGroupByElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByElementContext {
	var p = new(GroupByElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_groupByElement

	return p
}

func (s *GroupByElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByElementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *GroupByElementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *GroupByElementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *GroupByElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterGroupByElement(s)
	}
}

func (s *GroupByElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitGroupByElement(s)
	}
}

func (s *GroupByElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitGroupByElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) GroupByElement() (localctx IGroupByElementContext) {
	localctx = NewGroupByElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SQLParserRULE_groupByElement)
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(503)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(504)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(505)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(506)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)
			p.ExpressionList()
		}
		{
			p.SetState(508)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQLParserHAVING, 0)
}

func (s *HavingClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SQLParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		p.Match(SQLParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(513)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByElement() []IOrderByElementContext
	OrderByElement(i int) IOrderByElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *OrderByClauseContext) AllOrderByElement() []IOrderByElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByElementContext); ok {
			len++
		}
	}

	tst := make([]IOrderByElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByElementContext); ok {
			tst[i] = t.(IOrderByElementContext)
			i++
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderByElement(i int) IOrderByElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByElementContext)
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SQLParserRULE_orderByClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.Match(SQLParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(516)
		p.Match(SQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(517)
		p.OrderByElement()
	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(518)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(519)
			p.OrderByElement()
		}

		p.SetState(524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByElementContext is an interface to support dynamic dispatch.
type IOrderByElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsOrderByElementContext differentiates from other interfaces.
	IsOrderByElementContext()
}

type OrderByElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByElementContext() *OrderByElementContext {
	var p = new(OrderByElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_orderByElement
	return p
}

func InitEmptyOrderByElementContext(p *OrderByElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_orderByElement
}

func (*OrderByElementContext) IsOrderByElementContext() {}

func NewOrderByElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByElementContext {
	var p = new(OrderByElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_orderByElement

	return p
}

func (s *OrderByElementContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrderByElementContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SQLParserNULLS, 0)
}

func (s *OrderByElementContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLParserASC, 0)
}

func (s *OrderByElementContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLParserDESC, 0)
}

func (s *OrderByElementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLParserFIRST, 0)
}

func (s *OrderByElementContext) LAST() antlr.TerminalNode {
	return s.GetToken(SQLParserLAST, 0)
}

func (s *OrderByElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterOrderByElement(s)
	}
}

func (s *OrderByElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitOrderByElement(s)
	}
}

func (s *OrderByElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitOrderByElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) OrderByElement() (localctx IOrderByElementContext) {
	localctx = NewOrderByElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SQLParserRULE_orderByElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.expression(0)
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserASC || _la == SQLParserDESC {
		{
			p.SetState(526)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserASC || _la == SQLParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserNULLS {
		{
			p.SetState(529)
			p.Match(SQLParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(530)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserFIRST || _la == SQLParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	OFFSET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	FETCH() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	AllROW() []antlr.TerminalNode
	ROW(i int) antlr.TerminalNode
	AllROWS() []antlr.TerminalNode
	ROWS(i int) antlr.TerminalNode
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SQLParserLIMIT, 0)
}

func (s *LimitClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LimitClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SQLParserOFFSET, 0)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, 0)
}

func (s *LimitClauseContext) FETCH() antlr.TerminalNode {
	return s.GetToken(SQLParserFETCH, 0)
}

func (s *LimitClauseContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SQLParserONLY, 0)
}

func (s *LimitClauseContext) AllROW() []antlr.TerminalNode {
	return s.GetTokens(SQLParserROW)
}

func (s *LimitClauseContext) ROW(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserROW, i)
}

func (s *LimitClauseContext) AllROWS() []antlr.TerminalNode {
	return s.GetTokens(SQLParserROWS)
}

func (s *LimitClauseContext) ROWS(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserROWS, i)
}

func (s *LimitClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLParserFIRST, 0)
}

func (s *LimitClauseContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SQLParserNEXT, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SQLParserRULE_limitClause)
	var _la int

	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(533)
			p.Match(SQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(534)
			p.expression(0)
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserOFFSET {
			{
				p.SetState(535)
				p.Match(SQLParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(536)
				p.expression(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(539)
			p.Match(SQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(540)
			p.expression(0)
		}
		{
			p.SetState(541)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(542)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(544)
			p.Match(SQLParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(545)
			p.expression(0)
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserROWS || _la == SQLParserROW {
			{
				p.SetState(546)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLParserROWS || _la == SQLParserROW) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserFETCH {
			{
				p.SetState(549)
				p.Match(SQLParserFETCH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(550)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLParserFIRST || _la == SQLParserNEXT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(551)
				p.expression(0)
			}
			{
				p.SetState(552)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLParserROWS || _la == SQLParserROW) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(553)
				p.Match(SQLParserONLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	TableName() ITableNameContext
	SelectStatement() ISelectStatementContext
	ValuesClause() IValuesClauseContext
	TABLE() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	ColumnList() IColumnListContext
	OnDuplicateKeyUpdate() IOnDuplicateKeyUpdateContext
	INTO() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLParserINSERT, 0)
}

func (s *InsertStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *InsertStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InsertStatementContext) ValuesClause() IValuesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesClauseContext)
}

func (s *InsertStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLE, 0)
}

func (s *InsertStatementContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertStatementContext) ColumnList() IColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnListContext)
}

func (s *InsertStatementContext) OnDuplicateKeyUpdate() IOnDuplicateKeyUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnDuplicateKeyUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnDuplicateKeyUpdateContext)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLParserINTO, 0)
}

func (s *InsertStatementContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SQLParserOVERWRITE, 0)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SQLParserRULE_insertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(SQLParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(560)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserINTO || _la == SQLParserOVERWRITE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(563)
			p.Match(SQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(566)
		p.TableName()
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserPARTITION {
		{
			p.SetState(567)
			p.PartitionSpec()
		}

	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(570)
			p.ColumnList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserSELECT, SQLParserWITH, SQLParserLPAREN:
		{
			p.SetState(573)
			p.SelectStatement()
		}

	case SQLParserVALUES:
		{
			p.SetState(574)
			p.ValuesClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserON {
		{
			p.SetState(577)
			p.OnDuplicateKeyUpdate()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionSpecContext is an interface to support dynamic dispatch.
type IPartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllPartitionElement() []IPartitionElementContext
	PartitionElement(i int) IPartitionElementContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionSpecContext differentiates from other interfaces.
	IsPartitionSpecContext()
}

type PartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSpecContext() *PartitionSpecContext {
	var p = new(PartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_partitionSpec
	return p
}

func InitEmptyPartitionSpecContext(p *PartitionSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_partitionSpec
}

func (*PartitionSpecContext) IsPartitionSpecContext() {}

func NewPartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecContext {
	var p = new(PartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_partitionSpec

	return p
}

func (s *PartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLParserPARTITION, 0)
}

func (s *PartitionSpecContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *PartitionSpecContext) AllPartitionElement() []IPartitionElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionElementContext); ok {
			len++
		}
	}

	tst := make([]IPartitionElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionElementContext); ok {
			tst[i] = t.(IPartitionElementContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSpecContext) PartitionElement(i int) IPartitionElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionElementContext)
}

func (s *PartitionSpecContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *PartitionSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *PartitionSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *PartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitPartitionSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) PartitionSpec() (localctx IPartitionSpecContext) {
	localctx = NewPartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SQLParserRULE_partitionSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Match(SQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(581)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(582)
		p.PartitionElement()
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(583)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(584)
			p.PartitionElement()
		}

		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(590)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionElementContext is an interface to support dynamic dispatch.
type IPartitionElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPartitionElementContext differentiates from other interfaces.
	IsPartitionElementContext()
}

type PartitionElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionElementContext() *PartitionElementContext {
	var p = new(PartitionElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_partitionElement
	return p
}

func InitEmptyPartitionElementContext(p *PartitionElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_partitionElement
}

func (*PartitionElementContext) IsPartitionElementContext() {}

func NewPartitionElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionElementContext {
	var p = new(PartitionElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_partitionElement

	return p
}

func (s *PartitionElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionElementContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLParserEQ, 0)
}

func (s *PartitionElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterPartitionElement(s)
	}
}

func (s *PartitionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitPartitionElement(s)
	}
}

func (s *PartitionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitPartitionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) PartitionElement() (localctx IPartitionElementContext) {
	localctx = NewPartitionElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SQLParserRULE_partitionElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.Identifier()
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserEQ {
		{
			p.SetState(593)
			p.Match(SQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnListContext is an interface to support dynamic dispatch.
type IColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnListContext differentiates from other interfaces.
	IsColumnListContext()
}

type ColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnListContext() *ColumnListContext {
	var p = new(ColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnList
	return p
}

func InitEmptyColumnListContext(p *ColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnList
}

func (*ColumnListContext) IsColumnListContext() {}

func NewColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnListContext {
	var p = new(ColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_columnList

	return p
}

func (s *ColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *ColumnListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *ColumnListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *ColumnListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *ColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterColumnList(s)
	}
}

func (s *ColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitColumnList(s)
	}
}

func (s *ColumnListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitColumnList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ColumnList() (localctx IColumnListContext) {
	localctx = NewColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SQLParserRULE_columnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(598)
		p.Identifier()
	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(599)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(600)
			p.Identifier()
		}

		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(606)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesClauseContext is an interface to support dynamic dispatch.
type IValuesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllValueRow() []IValueRowContext
	ValueRow(i int) IValueRowContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValuesClauseContext differentiates from other interfaces.
	IsValuesClauseContext()
}

type ValuesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesClauseContext() *ValuesClauseContext {
	var p = new(ValuesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_valuesClause
	return p
}

func InitEmptyValuesClauseContext(p *ValuesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_valuesClause
}

func (*ValuesClauseContext) IsValuesClauseContext() {}

func NewValuesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesClauseContext {
	var p = new(ValuesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_valuesClause

	return p
}

func (s *ValuesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesClauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLParserVALUES, 0)
}

func (s *ValuesClauseContext) AllValueRow() []IValueRowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueRowContext); ok {
			len++
		}
	}

	tst := make([]IValueRowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueRowContext); ok {
			tst[i] = t.(IValueRowContext)
			i++
		}
	}

	return tst
}

func (s *ValuesClauseContext) ValueRow(i int) IValueRowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueRowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueRowContext)
}

func (s *ValuesClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *ValuesClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *ValuesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterValuesClause(s)
	}
}

func (s *ValuesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitValuesClause(s)
	}
}

func (s *ValuesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitValuesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ValuesClause() (localctx IValuesClauseContext) {
	localctx = NewValuesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SQLParserRULE_valuesClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(SQLParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(609)
		p.ValueRow()
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(610)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(611)
			p.ValueRow()
		}

		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueRowContext is an interface to support dynamic dispatch.
type IValueRowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RPAREN() antlr.TerminalNode

	// IsValueRowContext differentiates from other interfaces.
	IsValueRowContext()
}

type ValueRowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueRowContext() *ValueRowContext {
	var p = new(ValueRowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_valueRow
	return p
}

func InitEmptyValueRowContext(p *ValueRowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_valueRow
}

func (*ValueRowContext) IsValueRowContext() {}

func NewValueRowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueRowContext {
	var p = new(ValueRowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_valueRow

	return p
}

func (s *ValueRowContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueRowContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *ValueRowContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ValueRowContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *ValueRowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueRowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueRowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterValueRow(s)
	}
}

func (s *ValueRowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitValueRow(s)
	}
}

func (s *ValueRowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitValueRow(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ValueRow() (localctx IValueRowContext) {
	localctx = NewValueRowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SQLParserRULE_valueRow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(618)
		p.ExpressionList()
	}
	{
		p.SetState(619)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnDuplicateKeyUpdateContext is an interface to support dynamic dispatch.
type IOnDuplicateKeyUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllUpdateElement() []IUpdateElementContext
	UpdateElement(i int) IUpdateElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOnDuplicateKeyUpdateContext differentiates from other interfaces.
	IsOnDuplicateKeyUpdateContext()
}

type OnDuplicateKeyUpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnDuplicateKeyUpdateContext() *OnDuplicateKeyUpdateContext {
	var p = new(OnDuplicateKeyUpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_onDuplicateKeyUpdate
	return p
}

func InitEmptyOnDuplicateKeyUpdateContext(p *OnDuplicateKeyUpdateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_onDuplicateKeyUpdate
}

func (*OnDuplicateKeyUpdateContext) IsOnDuplicateKeyUpdateContext() {}

func NewOnDuplicateKeyUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnDuplicateKeyUpdateContext {
	var p = new(OnDuplicateKeyUpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_onDuplicateKeyUpdate

	return p
}

func (s *OnDuplicateKeyUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *OnDuplicateKeyUpdateContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLParserON, 0)
}

func (s *OnDuplicateKeyUpdateContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(SQLParserDUPLICATE, 0)
}

func (s *OnDuplicateKeyUpdateContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLParserKEY, 0)
}

func (s *OnDuplicateKeyUpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLParserUPDATE, 0)
}

func (s *OnDuplicateKeyUpdateContext) AllUpdateElement() []IUpdateElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdateElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateElementContext); ok {
			tst[i] = t.(IUpdateElementContext)
			i++
		}
	}

	return tst
}

func (s *OnDuplicateKeyUpdateContext) UpdateElement(i int) IUpdateElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateElementContext)
}

func (s *OnDuplicateKeyUpdateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *OnDuplicateKeyUpdateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *OnDuplicateKeyUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnDuplicateKeyUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnDuplicateKeyUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterOnDuplicateKeyUpdate(s)
	}
}

func (s *OnDuplicateKeyUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitOnDuplicateKeyUpdate(s)
	}
}

func (s *OnDuplicateKeyUpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitOnDuplicateKeyUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) OnDuplicateKeyUpdate() (localctx IOnDuplicateKeyUpdateContext) {
	localctx = NewOnDuplicateKeyUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SQLParserRULE_onDuplicateKeyUpdate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Match(SQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(622)
		p.Match(SQLParserDUPLICATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(623)
		p.Match(SQLParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(624)
		p.Match(SQLParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(625)
		p.UpdateElement()
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(626)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(627)
			p.UpdateElement()
		}

		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableName() ITableNameContext
	SET() antlr.TerminalNode
	AllUpdateElement() []IUpdateElementContext
	UpdateElement(i int) IUpdateElementContext
	Alias() IAliasContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	FromClause() IFromClauseContext
	WhereClause() IWhereClauseContext
	AS() antlr.TerminalNode

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLParserUPDATE, 0)
}

func (s *UpdateStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *UpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLParserSET, 0)
}

func (s *UpdateStatementContext) AllUpdateElement() []IUpdateElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdateElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateElementContext); ok {
			tst[i] = t.(IUpdateElementContext)
			i++
		}
	}

	return tst
}

func (s *UpdateStatementContext) UpdateElement(i int) IUpdateElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateElementContext)
}

func (s *UpdateStatementContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *UpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *UpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *UpdateStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SQLParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(SQLParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(634)
		p.TableName()
	}
	p.SetState(639)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		p.SetState(636)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(635)
				p.Match(SQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(638)
			p.Alias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(641)
		p.Match(SQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(642)
		p.UpdateElement()
	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(643)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(644)
			p.UpdateElement()
		}

		p.SetState(649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserFROM {
		{
			p.SetState(650)
			p.FromClause()
		}

	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserWHERE {
		{
			p.SetState(653)
			p.WhereClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateElementContext is an interface to support dynamic dispatch.
type IUpdateElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsUpdateElementContext differentiates from other interfaces.
	IsUpdateElementContext()
}

type UpdateElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateElementContext() *UpdateElementContext {
	var p = new(UpdateElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_updateElement
	return p
}

func InitEmptyUpdateElementContext(p *UpdateElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_updateElement
}

func (*UpdateElementContext) IsUpdateElementContext() {}

func NewUpdateElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateElementContext {
	var p = new(UpdateElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_updateElement

	return p
}

func (s *UpdateElementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateElementContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *UpdateElementContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLParserEQ, 0)
}

func (s *UpdateElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterUpdateElement(s)
	}
}

func (s *UpdateElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitUpdateElement(s)
	}
}

func (s *UpdateElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitUpdateElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) UpdateElement() (localctx IUpdateElementContext) {
	localctx = NewUpdateElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SQLParserRULE_updateElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.ColumnRef()
	}
	{
		p.SetState(657)
		p.Match(SQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(658)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TableName() ITableNameContext
	Alias() IAliasContext
	WhereClause() IWhereClauseContext
	AS() antlr.TerminalNode

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLParserDELETE, 0)
}

func (s *DeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLParserFROM, 0)
}

func (s *DeleteStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DeleteStatementContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *DeleteStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SQLParserRULE_deleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(SQLParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(661)
		p.Match(SQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(662)
		p.TableName()
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		p.SetState(664)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(663)
				p.Match(SQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(666)
			p.Alias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserWHERE {
		{
			p.SetState(669)
			p.WhereClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateStatementContext is an interface to support dynamic dispatch.
type ITruncateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TableName() ITableNameContext
	TABLE() antlr.TerminalNode

	// IsTruncateStatementContext differentiates from other interfaces.
	IsTruncateStatementContext()
}

type TruncateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateStatementContext() *TruncateStatementContext {
	var p = new(TruncateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_truncateStatement
	return p
}

func InitEmptyTruncateStatementContext(p *TruncateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_truncateStatement
}

func (*TruncateStatementContext) IsTruncateStatementContext() {}

func NewTruncateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateStatementContext {
	var p = new(TruncateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_truncateStatement

	return p
}

func (s *TruncateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(SQLParserTRUNCATE, 0)
}

func (s *TruncateStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TruncateStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLE, 0)
}

func (s *TruncateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTruncateStatement(s)
	}
}

func (s *TruncateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTruncateStatement(s)
	}
}

func (s *TruncateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTruncateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TruncateStatement() (localctx ITruncateStatementContext) {
	localctx = NewTruncateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SQLParserRULE_truncateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(SQLParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(673)
			p.Match(SQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(676)
		p.TableName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeStatementContext is an interface to support dynamic dispatch.
type IMergeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MERGE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TableName() ITableNameContext
	USING() antlr.TerminalNode
	TableReference() ITableReferenceContext
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	AllAlias() []IAliasContext
	Alias(i int) IAliasContext
	AllMergeClause() []IMergeClauseContext
	MergeClause(i int) IMergeClauseContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode

	// IsMergeStatementContext differentiates from other interfaces.
	IsMergeStatementContext()
}

type MergeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeStatementContext() *MergeStatementContext {
	var p = new(MergeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mergeStatement
	return p
}

func InitEmptyMergeStatementContext(p *MergeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mergeStatement
}

func (*MergeStatementContext) IsMergeStatementContext() {}

func NewMergeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeStatementContext {
	var p = new(MergeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_mergeStatement

	return p
}

func (s *MergeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeStatementContext) MERGE() antlr.TerminalNode {
	return s.GetToken(SQLParserMERGE, 0)
}

func (s *MergeStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLParserINTO, 0)
}

func (s *MergeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MergeStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLParserUSING, 0)
}

func (s *MergeStatementContext) TableReference() ITableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *MergeStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLParserON, 0)
}

func (s *MergeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeStatementContext) AllAlias() []IAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAliasContext); ok {
			len++
		}
	}

	tst := make([]IAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAliasContext); ok {
			tst[i] = t.(IAliasContext)
			i++
		}
	}

	return tst
}

func (s *MergeStatementContext) Alias(i int) IAliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *MergeStatementContext) AllMergeClause() []IMergeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMergeClauseContext); ok {
			len++
		}
	}

	tst := make([]IMergeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMergeClauseContext); ok {
			tst[i] = t.(IMergeClauseContext)
			i++
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeClause(i int) IMergeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeClauseContext)
}

func (s *MergeStatementContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(SQLParserAS)
}

func (s *MergeStatementContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserAS, i)
}

func (s *MergeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterMergeStatement(s)
	}
}

func (s *MergeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitMergeStatement(s)
	}
}

func (s *MergeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitMergeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) MergeStatement() (localctx IMergeStatementContext) {
	localctx = NewMergeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SQLParserRULE_mergeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(SQLParserMERGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(679)
		p.Match(SQLParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(680)
		p.TableName()
	}
	p.SetState(685)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		p.SetState(682)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(681)
				p.Match(SQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(684)
			p.Alias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(687)
		p.Match(SQLParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(688)
		p.TableReference()
	}
	p.SetState(693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		p.SetState(690)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(689)
				p.Match(SQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(692)
			p.Alias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(695)
		p.Match(SQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(696)
		p.expression(0)
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SQLParserWHEN {
		{
			p.SetState(697)
			p.MergeClause()
		}

		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeClauseContext is an interface to support dynamic dispatch.
type IMergeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	MATCHED() antlr.TerminalNode
	THEN() antlr.TerminalNode
	MergeUpdateClause() IMergeUpdateClauseContext
	AND() antlr.TerminalNode
	Expression() IExpressionContext
	DELETE() antlr.TerminalNode
	NOT() antlr.TerminalNode
	MergeInsertClause() IMergeInsertClauseContext

	// IsMergeClauseContext differentiates from other interfaces.
	IsMergeClauseContext()
}

type MergeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeClauseContext() *MergeClauseContext {
	var p = new(MergeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mergeClause
	return p
}

func InitEmptyMergeClauseContext(p *MergeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mergeClause
}

func (*MergeClauseContext) IsMergeClauseContext() {}

func NewMergeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeClauseContext {
	var p = new(MergeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_mergeClause

	return p
}

func (s *MergeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SQLParserWHEN, 0)
}

func (s *MergeClauseContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(SQLParserMATCHED, 0)
}

func (s *MergeClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SQLParserTHEN, 0)
}

func (s *MergeClauseContext) MergeUpdateClause() IMergeUpdateClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeUpdateClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeUpdateClauseContext)
}

func (s *MergeClauseContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLParserAND, 0)
}

func (s *MergeClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MergeClauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLParserDELETE, 0)
}

func (s *MergeClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *MergeClauseContext) MergeInsertClause() IMergeInsertClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeInsertClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeInsertClauseContext)
}

func (s *MergeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterMergeClause(s)
	}
}

func (s *MergeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitMergeClause(s)
	}
}

func (s *MergeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitMergeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) MergeClause() (localctx IMergeClauseContext) {
	localctx = NewMergeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SQLParserRULE_mergeClause)
	var _la int

	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(702)
			p.Match(SQLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(703)
			p.Match(SQLParserMATCHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserAND {
			{
				p.SetState(704)
				p.Match(SQLParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(705)
				p.expression(0)
			}

		}
		{
			p.SetState(708)
			p.Match(SQLParserTHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(709)
			p.MergeUpdateClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(710)
			p.Match(SQLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(711)
			p.Match(SQLParserMATCHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserAND {
			{
				p.SetState(712)
				p.Match(SQLParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(713)
				p.expression(0)
			}

		}
		{
			p.SetState(716)
			p.Match(SQLParserTHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(717)
			p.Match(SQLParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(718)
			p.Match(SQLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(719)
			p.Match(SQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(720)
			p.Match(SQLParserMATCHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserAND {
			{
				p.SetState(721)
				p.Match(SQLParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(722)
				p.expression(0)
			}

		}
		{
			p.SetState(725)
			p.Match(SQLParserTHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.MergeInsertClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeUpdateClauseContext is an interface to support dynamic dispatch.
type IMergeUpdateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllUpdateElement() []IUpdateElementContext
	UpdateElement(i int) IUpdateElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMergeUpdateClauseContext differentiates from other interfaces.
	IsMergeUpdateClauseContext()
}

type MergeUpdateClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeUpdateClauseContext() *MergeUpdateClauseContext {
	var p = new(MergeUpdateClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mergeUpdateClause
	return p
}

func InitEmptyMergeUpdateClauseContext(p *MergeUpdateClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mergeUpdateClause
}

func (*MergeUpdateClauseContext) IsMergeUpdateClauseContext() {}

func NewMergeUpdateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeUpdateClauseContext {
	var p = new(MergeUpdateClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_mergeUpdateClause

	return p
}

func (s *MergeUpdateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeUpdateClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLParserUPDATE, 0)
}

func (s *MergeUpdateClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLParserSET, 0)
}

func (s *MergeUpdateClauseContext) AllUpdateElement() []IUpdateElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdateElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateElementContext); ok {
			tst[i] = t.(IUpdateElementContext)
			i++
		}
	}

	return tst
}

func (s *MergeUpdateClauseContext) UpdateElement(i int) IUpdateElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateElementContext)
}

func (s *MergeUpdateClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *MergeUpdateClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *MergeUpdateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeUpdateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeUpdateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterMergeUpdateClause(s)
	}
}

func (s *MergeUpdateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitMergeUpdateClause(s)
	}
}

func (s *MergeUpdateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitMergeUpdateClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) MergeUpdateClause() (localctx IMergeUpdateClauseContext) {
	localctx = NewMergeUpdateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SQLParserRULE_mergeUpdateClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Match(SQLParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(730)
		p.Match(SQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(731)
		p.UpdateElement()
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(732)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(733)
			p.UpdateElement()
		}

		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeInsertClauseContext is an interface to support dynamic dispatch.
type IMergeInsertClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RPAREN() antlr.TerminalNode
	ColumnList() IColumnListContext

	// IsMergeInsertClauseContext differentiates from other interfaces.
	IsMergeInsertClauseContext()
}

type MergeInsertClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeInsertClauseContext() *MergeInsertClauseContext {
	var p = new(MergeInsertClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mergeInsertClause
	return p
}

func InitEmptyMergeInsertClauseContext(p *MergeInsertClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mergeInsertClause
}

func (*MergeInsertClauseContext) IsMergeInsertClauseContext() {}

func NewMergeInsertClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeInsertClauseContext {
	var p = new(MergeInsertClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_mergeInsertClause

	return p
}

func (s *MergeInsertClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeInsertClauseContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLParserINSERT, 0)
}

func (s *MergeInsertClauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLParserVALUES, 0)
}

func (s *MergeInsertClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *MergeInsertClauseContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *MergeInsertClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *MergeInsertClauseContext) ColumnList() IColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnListContext)
}

func (s *MergeInsertClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeInsertClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeInsertClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterMergeInsertClause(s)
	}
}

func (s *MergeInsertClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitMergeInsertClause(s)
	}
}

func (s *MergeInsertClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitMergeInsertClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) MergeInsertClause() (localctx IMergeInsertClauseContext) {
	localctx = NewMergeInsertClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SQLParserRULE_mergeInsertClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(SQLParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserLPAREN {
		{
			p.SetState(740)
			p.ColumnList()
		}

	}
	{
		p.SetState(743)
		p.Match(SQLParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(744)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(745)
		p.ExpressionList()
	}
	{
		p.SetState(746)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateStatementContext is an interface to support dynamic dispatch.
type ICreateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateTableStatement() ICreateTableStatementContext
	CreateViewStatement() ICreateViewStatementContext
	CreateDatabaseStatement() ICreateDatabaseStatementContext
	CreateIndexStatement() ICreateIndexStatementContext

	// IsCreateStatementContext differentiates from other interfaces.
	IsCreateStatementContext()
}

type CreateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateStatementContext() *CreateStatementContext {
	var p = new(CreateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createStatement
	return p
}

func InitEmptyCreateStatementContext(p *CreateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createStatement
}

func (*CreateStatementContext) IsCreateStatementContext() {}

func NewCreateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStatementContext {
	var p = new(CreateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_createStatement

	return p
}

func (s *CreateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStatementContext) CreateTableStatement() ICreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableStatementContext)
}

func (s *CreateStatementContext) CreateViewStatement() ICreateViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewStatementContext)
}

func (s *CreateStatementContext) CreateDatabaseStatement() ICreateDatabaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseStatementContext)
}

func (s *CreateStatementContext) CreateIndexStatement() ICreateIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexStatementContext)
}

func (s *CreateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCreateStatement(s)
	}
}

func (s *CreateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCreateStatement(s)
	}
}

func (s *CreateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCreateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CreateStatement() (localctx ICreateStatementContext) {
	localctx = NewCreateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SQLParserRULE_createStatement)
	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(748)
			p.CreateTableStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(749)
			p.CreateViewStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(750)
			p.CreateDatabaseStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(751)
			p.CreateIndexStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableStatementContext is an interface to support dynamic dispatch.
type ICreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	IF_P() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TableElementList() ITableElementListContext
	RPAREN() antlr.TerminalNode
	TableInheritsClause() ITableInheritsClauseContext
	PartitionedByClause() IPartitionedByClauseContext
	DistributedByClause() IDistributedByClauseContext
	ClusteredByClause() IClusteredByClauseContext
	SortedByClause() ISortedByClauseContext
	RowFormatClause() IRowFormatClauseContext
	StoredAsClause() IStoredAsClauseContext
	LocationClause() ILocationClauseContext
	EngineClause() IEngineClauseContext
	TablePropertiesClause() ITablePropertiesClauseContext
	WithOptionsClause() IWithOptionsClauseContext
	CharsetClause() ICharsetClauseContext
	CollateClause() ICollateClauseContext
	TablespaceClause() ITablespaceClauseContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	TtlClause() ITtlClauseContext
	LifecycleClause() ILifecycleClauseContext
	AS() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	UNLOGGED() antlr.TerminalNode

	// IsCreateTableStatementContext differentiates from other interfaces.
	IsCreateTableStatementContext()
}

type CreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableStatementContext() *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createTableStatement
	return p
}

func InitEmptyCreateTableStatementContext(p *CreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createTableStatement
}

func (*CreateTableStatementContext) IsCreateTableStatementContext() {}

func NewCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_createTableStatement

	return p
}

func (s *CreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLParserCREATE, 0)
}

func (s *CreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLE, 0)
}

func (s *CreateTableStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTableStatementContext) IF_P() antlr.TerminalNode {
	return s.GetToken(SQLParserIF_P, 0)
}

func (s *CreateTableStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *CreateTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLParserEXISTS, 0)
}

func (s *CreateTableStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *CreateTableStatementContext) TableElementList() ITableElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementListContext)
}

func (s *CreateTableStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *CreateTableStatementContext) TableInheritsClause() ITableInheritsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableInheritsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableInheritsClauseContext)
}

func (s *CreateTableStatementContext) PartitionedByClause() IPartitionedByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionedByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionedByClauseContext)
}

func (s *CreateTableStatementContext) DistributedByClause() IDistributedByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributedByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributedByClauseContext)
}

func (s *CreateTableStatementContext) ClusteredByClause() IClusteredByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteredByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteredByClauseContext)
}

func (s *CreateTableStatementContext) SortedByClause() ISortedByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortedByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortedByClauseContext)
}

func (s *CreateTableStatementContext) RowFormatClause() IRowFormatClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatClauseContext)
}

func (s *CreateTableStatementContext) StoredAsClause() IStoredAsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStoredAsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStoredAsClauseContext)
}

func (s *CreateTableStatementContext) LocationClause() ILocationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationClauseContext)
}

func (s *CreateTableStatementContext) EngineClause() IEngineClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineClauseContext)
}

func (s *CreateTableStatementContext) TablePropertiesClause() ITablePropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesClauseContext)
}

func (s *CreateTableStatementContext) WithOptionsClause() IWithOptionsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithOptionsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithOptionsClauseContext)
}

func (s *CreateTableStatementContext) CharsetClause() ICharsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetClauseContext)
}

func (s *CreateTableStatementContext) CollateClause() ICollateClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateClauseContext)
}

func (s *CreateTableStatementContext) TablespaceClause() ITablespaceClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceClauseContext)
}

func (s *CreateTableStatementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMENT, 0)
}

func (s *CreateTableStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *CreateTableStatementContext) TtlClause() ITtlClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtlClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtlClauseContext)
}

func (s *CreateTableStatementContext) LifecycleClause() ILifecycleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILifecycleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILifecycleClauseContext)
}

func (s *CreateTableStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *CreateTableStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CreateTableStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SQLParserGLOBAL, 0)
}

func (s *CreateTableStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQLParserLOCAL, 0)
}

func (s *CreateTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SQLParserTEMPORARY, 0)
}

func (s *CreateTableStatementContext) TEMP() antlr.TerminalNode {
	return s.GetToken(SQLParserTEMP, 0)
}

func (s *CreateTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLParserEXTERNAL, 0)
}

func (s *CreateTableStatementContext) UNLOGGED() antlr.TerminalNode {
	return s.GetToken(SQLParserUNLOGGED, 0)
}

func (s *CreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CreateTableStatement() (localctx ICreateTableStatementContext) {
	localctx = NewCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SQLParserRULE_createTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Match(SQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserGLOBAL || _la == SQLParserLOCAL {
		{
			p.SetState(755)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserGLOBAL || _la == SQLParserLOCAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&15762598695796736) != 0) || _la == SQLParserUNLOGGED {
		{
			p.SetState(758)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&15762598695796736) != 0) || _la == SQLParserUNLOGGED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(761)
		p.Match(SQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserIF_P {
		{
			p.SetState(762)
			p.Match(SQLParserIF_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(763)
			p.Match(SQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(764)
			p.Match(SQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(767)
		p.TableName()
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserLPAREN {
		{
			p.SetState(768)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(769)
			p.TableElementList()
		}
		{
			p.SetState(770)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserINHERITS {
		{
			p.SetState(774)
			p.TableInheritsClause()
		}

	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserPARTITIONED {
		{
			p.SetState(777)
			p.PartitionedByClause()
		}

	}
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserDISTRIBUTED {
		{
			p.SetState(780)
			p.DistributedByClause()
		}

	}
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserCLUSTERED {
		{
			p.SetState(783)
			p.ClusteredByClause()
		}

	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserORDER {
		{
			p.SetState(786)
			p.SortedByClause()
		}

	}
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserROW_FORMAT {
		{
			p.SetState(789)
			p.RowFormatClause()
		}

	}
	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserSTORED {
		{
			p.SetState(792)
			p.StoredAsClause()
		}

	}
	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserLOCATION {
		{
			p.SetState(795)
			p.LocationClause()
		}

	}
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserENGINE {
		{
			p.SetState(798)
			p.EngineClause()
		}

	}
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserTBLPROPERTIES {
		{
			p.SetState(801)
			p.TablePropertiesClause()
		}

	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserWITH {
		{
			p.SetState(804)
			p.WithOptionsClause()
		}

	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(807)
			p.CharsetClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserDEFAULT || _la == SQLParserCOLLATE {
		{
			p.SetState(810)
			p.CollateClause()
		}

	}
	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserTABLESPACE {
		{
			p.SetState(813)
			p.TablespaceClause()
		}

	}
	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserCOMMENT {
		{
			p.SetState(816)
			p.Match(SQLParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(817)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserTTL {
		{
			p.SetState(820)
			p.TtlClause()
		}

	}
	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserLIFECYCLE {
		{
			p.SetState(823)
			p.LifecycleClause()
		}

	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserAS {
		{
			p.SetState(826)
			p.Match(SQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(827)
			p.SelectStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementListContext is an interface to support dynamic dispatch.
type ITableElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableElement() []ITableElementContext
	TableElement(i int) ITableElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableElementListContext differentiates from other interfaces.
	IsTableElementListContext()
}

type TableElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementListContext() *TableElementListContext {
	var p = new(TableElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableElementList
	return p
}

func InitEmptyTableElementListContext(p *TableElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableElementList
}

func (*TableElementListContext) IsTableElementListContext() {}

func NewTableElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementListContext {
	var p = new(TableElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableElementList

	return p
}

func (s *TableElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementListContext) AllTableElement() []ITableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableElementContext); ok {
			len++
		}
	}

	tst := make([]ITableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableElementContext); ok {
			tst[i] = t.(ITableElementContext)
			i++
		}
	}

	return tst
}

func (s *TableElementListContext) TableElement(i int) ITableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *TableElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *TableElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *TableElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableElementList(s)
	}
}

func (s *TableElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableElementList(s)
	}
}

func (s *TableElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableElementList() (localctx ITableElementListContext) {
	localctx = NewTableElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SQLParserRULE_tableElementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		p.TableElement()
	}
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(831)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(832)
			p.TableElement()
		}

		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WatermarkDefinition() IWatermarkDefinitionContext
	TableConstraint() ITableConstraintContext
	ColumnDefinition() IColumnDefinitionContext

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableElement
	return p
}

func InitEmptyTableElementContext(p *TableElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableElement
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) WatermarkDefinition() IWatermarkDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWatermarkDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWatermarkDefinitionContext)
}

func (s *TableElementContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *TableElementContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (s *TableElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SQLParserRULE_tableElement)
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(838)
			p.WatermarkDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(839)
			p.TableConstraint()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(840)
			p.ColumnDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWatermarkDefinitionContext is an interface to support dynamic dispatch.
type IWatermarkDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WATERMARK() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	AS() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWatermarkDefinitionContext differentiates from other interfaces.
	IsWatermarkDefinitionContext()
}

type WatermarkDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWatermarkDefinitionContext() *WatermarkDefinitionContext {
	var p = new(WatermarkDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_watermarkDefinition
	return p
}

func InitEmptyWatermarkDefinitionContext(p *WatermarkDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_watermarkDefinition
}

func (*WatermarkDefinitionContext) IsWatermarkDefinitionContext() {}

func NewWatermarkDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WatermarkDefinitionContext {
	var p = new(WatermarkDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_watermarkDefinition

	return p
}

func (s *WatermarkDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *WatermarkDefinitionContext) WATERMARK() antlr.TerminalNode {
	return s.GetToken(SQLParserWATERMARK, 0)
}

func (s *WatermarkDefinitionContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLParserFOR, 0)
}

func (s *WatermarkDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WatermarkDefinitionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *WatermarkDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WatermarkDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WatermarkDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WatermarkDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterWatermarkDefinition(s)
	}
}

func (s *WatermarkDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitWatermarkDefinition(s)
	}
}

func (s *WatermarkDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitWatermarkDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) WatermarkDefinition() (localctx IWatermarkDefinitionContext) {
	localctx = NewWatermarkDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SQLParserRULE_watermarkDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(843)
		p.Match(SQLParserWATERMARK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(844)
		p.Match(SQLParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(845)
		p.Identifier()
	}
	{
		p.SetState(846)
		p.Match(SQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(847)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DataType() IDataTypeContext
	AllColumnConstraint() []IColumnConstraintContext
	ColumnConstraint(i int) IColumnConstraintContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) AllColumnConstraint() []IColumnConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnConstraintContext); ok {
			tst[i] = t.(IColumnConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnDefinitionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMENT, 0)
}

func (s *ColumnDefinitionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SQLParserRULE_columnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)
		p.Identifier()
	}
	{
		p.SetState(850)
		p.DataType()
	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&547556790632512) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&26388279067265) != 0) || _la == SQLParserNULL {
		{
			p.SetState(851)
			p.ColumnConstraint()
		}

		p.SetState(856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserCOMMENT {
		{
			p.SetState(857)
			p.Match(SQLParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(858)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveType() IPrimitiveTypeContext
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	GT() antlr.TerminalNode
	MAP() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	AllStructField() []IStructFieldContext
	StructField(i int) IStructFieldContext
	ROW() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *DataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLParserARRAY, 0)
}

func (s *DataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(SQLParserLT, 0)
}

func (s *DataTypeContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *DataTypeContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(SQLParserGT, 0)
}

func (s *DataTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(SQLParserMAP, 0)
}

func (s *DataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *DataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *DataTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRUCT, 0)
}

func (s *DataTypeContext) AllStructField() []IStructFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructFieldContext); ok {
			len++
		}
	}

	tst := make([]IStructFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructFieldContext); ok {
			tst[i] = t.(IStructFieldContext)
			i++
		}
	}

	return tst
}

func (s *DataTypeContext) StructField(i int) IStructFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldContext)
}

func (s *DataTypeContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLParserROW, 0)
}

func (s *DataTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *DataTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (s *DataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SQLParserRULE_dataType)
	var _la int

	p.SetState(898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(861)
			p.PrimitiveType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(862)
			p.Match(SQLParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(863)
			p.Match(SQLParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(864)
			p.DataType()
		}
		{
			p.SetState(865)
			p.Match(SQLParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(867)
			p.Match(SQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(868)
			p.Match(SQLParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(869)
			p.DataType()
		}
		{
			p.SetState(870)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(871)
			p.DataType()
		}
		{
			p.SetState(872)
			p.Match(SQLParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(874)
			p.Match(SQLParserSTRUCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)
			p.Match(SQLParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(876)
			p.StructField()
		}
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(877)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(878)
				p.StructField()
			}

			p.SetState(883)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(884)
			p.Match(SQLParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(886)
			p.Match(SQLParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(887)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(888)
			p.StructField()
		}
		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(889)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(890)
				p.StructField()
			}

			p.SetState(895)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(896)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	REAL() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	BYTES() antlr.TerminalNode
	DATE() antlr.TerminalNode
	AllTIME() []antlr.TerminalNode
	TIME(i int) antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	WITH() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	JSON() antlr.TerminalNode
	XML() antlr.TerminalNode
	RAW() antlr.TerminalNode
	MULTISET() antlr.TerminalNode
	LT() antlr.TerminalNode
	DataType() IDataTypeContext
	GT() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(SQLParserINT, 0)
}

func (s *PrimitiveTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SQLParserINTEGER, 0)
}

func (s *PrimitiveTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(SQLParserTINYINT, 0)
}

func (s *PrimitiveTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SQLParserSMALLINT, 0)
}

func (s *PrimitiveTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(SQLParserBIGINT, 0)
}

func (s *PrimitiveTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SQLParserFLOAT, 0)
}

func (s *PrimitiveTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SQLParserDOUBLE, 0)
}

func (s *PrimitiveTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(SQLParserREAL, 0)
}

func (s *PrimitiveTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SQLParserDECIMAL, 0)
}

func (s *PrimitiveTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(SQLParserNUMERIC, 0)
}

func (s *PrimitiveTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *PrimitiveTypeContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(SQLParserNUMBER)
}

func (s *PrimitiveTypeContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserNUMBER, i)
}

func (s *PrimitiveTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *PrimitiveTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, 0)
}

func (s *PrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(SQLParserBOOLEAN, 0)
}

func (s *PrimitiveTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(SQLParserBOOL, 0)
}

func (s *PrimitiveTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING, 0)
}

func (s *PrimitiveTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(SQLParserVARCHAR, 0)
}

func (s *PrimitiveTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SQLParserCHAR, 0)
}

func (s *PrimitiveTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SQLParserTEXT, 0)
}

func (s *PrimitiveTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(SQLParserBINARY, 0)
}

func (s *PrimitiveTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(SQLParserVARBINARY, 0)
}

func (s *PrimitiveTypeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(SQLParserBLOB, 0)
}

func (s *PrimitiveTypeContext) BYTES() antlr.TerminalNode {
	return s.GetToken(SQLParserBYTES, 0)
}

func (s *PrimitiveTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQLParserDATE, 0)
}

func (s *PrimitiveTypeContext) AllTIME() []antlr.TerminalNode {
	return s.GetTokens(SQLParserTIME)
}

func (s *PrimitiveTypeContext) TIME(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserTIME, i)
}

func (s *PrimitiveTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLParserTIMESTAMP, 0)
}

func (s *PrimitiveTypeContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLParserWITH, 0)
}

func (s *PrimitiveTypeContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SQLParserZONE, 0)
}

func (s *PrimitiveTypeContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SQLParserWITHOUT, 0)
}

func (s *PrimitiveTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(SQLParserJSON, 0)
}

func (s *PrimitiveTypeContext) XML() antlr.TerminalNode {
	return s.GetToken(SQLParserXML, 0)
}

func (s *PrimitiveTypeContext) RAW() antlr.TerminalNode {
	return s.GetToken(SQLParserRAW, 0)
}

func (s *PrimitiveTypeContext) MULTISET() antlr.TerminalNode {
	return s.GetToken(SQLParserMULTISET, 0)
}

func (s *PrimitiveTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(SQLParserLT, 0)
}

func (s *PrimitiveTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *PrimitiveTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(SQLParserGT, 0)
}

func (s *PrimitiveTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SQLParserRULE_primitiveType)
	var _la int

	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(900)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-218)) & ^0x3f) == 0 && ((int64(1)<<(_la-218))&31) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(901)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-223)) & ^0x3f) == 0 && ((int64(1)<<(_la-223))&19) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(902)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserDECIMAL || _la == SQLParserNUMERIC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(910)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(903)
				p.Match(SQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(904)
				p.Match(SQLParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(907)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLParserCOMMA {
				{
					p.SetState(905)
					p.Match(SQLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(906)
					p.Match(SQLParserNUMBER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(909)
				p.Match(SQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(912)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserBOOLEAN || _la == SQLParserBOOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(913)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-230)) & ^0x3f) == 0 && ((int64(1)<<(_la-230))&15) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(914)
				p.Match(SQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(915)
				p.Match(SQLParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(916)
				p.Match(SQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(919)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-234)) & ^0x3f) == 0 && ((int64(1)<<(_la-234))&71) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(920)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-203)) & ^0x3f) == 0 && ((int64(1)<<(_la-203))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(924)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(921)
				p.Match(SQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(922)
				p.Match(SQLParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(923)
				p.Match(SQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(932)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(926)
				p.Match(SQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(927)
				p.Match(SQLParserTIME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(928)
				p.Match(SQLParserZONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(929)
				p.Match(SQLParserWITHOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(930)
				p.Match(SQLParserTIME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(931)
				p.Match(SQLParserZONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(934)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-238)) & ^0x3f) == 0 && ((int64(1)<<(_la-238))&19) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(935)
			p.Match(SQLParserMULTISET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(936)
			p.Match(SQLParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(937)
			p.DataType()
		}
		{
			p.SetState(938)
			p.Match(SQLParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(940)
			p.Identifier()
		}
		p.SetState(948)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(941)
				p.Match(SQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(942)
				p.Match(SQLParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(945)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLParserCOMMA {
				{
					p.SetState(943)
					p.Match(SQLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(944)
					p.Match(SQLParserNUMBER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(947)
				p.Match(SQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldContext is an interface to support dynamic dispatch.
type IStructFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	DataType() IDataTypeContext

	// IsStructFieldContext differentiates from other interfaces.
	IsStructFieldContext()
}

type StructFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructFieldContext() *StructFieldContext {
	var p = new(StructFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_structField
	return p
}

func InitEmptyStructFieldContext(p *StructFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_structField
}

func (*StructFieldContext) IsStructFieldContext() {}

func NewStructFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldContext {
	var p = new(StructFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_structField

	return p
}

func (s *StructFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(SQLParserCOLON, 0)
}

func (s *StructFieldContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *StructFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterStructField(s)
	}
}

func (s *StructFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitStructField(s)
	}
}

func (s *StructFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitStructField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) StructField() (localctx IStructFieldContext) {
	localctx = NewStructFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SQLParserRULE_structField)
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(952)
			p.Identifier()
		}
		{
			p.SetState(953)
			p.Match(SQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(954)
			p.DataType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(956)
			p.Identifier()
		}
		{
			p.SetState(957)
			p.DataType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	NotEnforced() INotEnforcedContext
	UNIQUE() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	IDENTITY() antlr.TerminalNode
	IdentityOptions() IIdentityOptionsContext
	GENERATED() antlr.TerminalNode
	AS() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	BY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	STORED() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	TableName() ITableNameContext
	Identifier() IIdentifierContext
	AllReferentialAction() []IReferentialActionContext
	ReferentialAction(i int) IReferentialActionContext
	CHECK() antlr.TerminalNode
	METADATA() antlr.TerminalNode
	FROM() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode

	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnConstraint
	return p
}

func InitEmptyColumnConstraintContext(p *ColumnConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnConstraint
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLParserNULL, 0)
}

func (s *ColumnConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *ColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLParserDEFAULT, 0)
}

func (s *ColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColumnConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLParserPRIMARY, 0)
}

func (s *ColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLParserKEY, 0)
}

func (s *ColumnConstraintContext) NotEnforced() INotEnforcedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEnforcedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEnforcedContext)
}

func (s *ColumnConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLParserUNIQUE, 0)
}

func (s *ColumnConstraintContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(SQLParserAUTO_INCREMENT, 0)
}

func (s *ColumnConstraintContext) IDENTITY() antlr.TerminalNode {
	return s.GetToken(SQLParserIDENTITY, 0)
}

func (s *ColumnConstraintContext) IdentityOptions() IIdentityOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOptionsContext)
}

func (s *ColumnConstraintContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(SQLParserGENERATED, 0)
}

func (s *ColumnConstraintContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *ColumnConstraintContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SQLParserALWAYS, 0)
}

func (s *ColumnConstraintContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *ColumnConstraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *ColumnConstraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *ColumnConstraintContext) STORED() antlr.TerminalNode {
	return s.GetToken(SQLParserSTORED, 0)
}

func (s *ColumnConstraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQLParserREFERENCES, 0)
}

func (s *ColumnConstraintContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ColumnConstraintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnConstraintContext) AllReferentialAction() []IReferentialActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReferentialActionContext); ok {
			len++
		}
	}

	tst := make([]IReferentialActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReferentialActionContext); ok {
			tst[i] = t.(IReferentialActionContext)
			i++
		}
	}

	return tst
}

func (s *ColumnConstraintContext) ReferentialAction(i int) IReferentialActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialActionContext)
}

func (s *ColumnConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLParserCHECK, 0)
}

func (s *ColumnConstraintContext) METADATA() antlr.TerminalNode {
	return s.GetToken(SQLParserMETADATA, 0)
}

func (s *ColumnConstraintContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLParserFROM, 0)
}

func (s *ColumnConstraintContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *ColumnConstraintContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(SQLParserVIRTUAL, 0)
}

func (s *ColumnConstraintContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLParserCOLLATE, 0)
}

func (s *ColumnConstraintContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SQLParserCHARACTER, 0)
}

func (s *ColumnConstraintContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLParserSET, 0)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterColumnConstraint(s)
	}
}

func (s *ColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitColumnConstraint(s)
	}
}

func (s *ColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SQLParserRULE_columnConstraint)
	var _la int

	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserNOT, SQLParserNULL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserNOT {
			{
				p.SetState(961)
				p.Match(SQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(964)
			p.Match(SQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(965)
			p.Match(SQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(966)
			p.expression(0)
		}

	case SQLParserPRIMARY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(967)
			p.Match(SQLParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(968)
			p.Match(SQLParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(970)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(969)
				p.NotEnforced()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SQLParserUNIQUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(972)
			p.Match(SQLParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserAUTO_INCREMENT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(973)
			p.Match(SQLParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserIDENTITY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(974)
			p.Match(SQLParserIDENTITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserLPAREN {
			{
				p.SetState(975)
				p.IdentityOptions()
			}

		}

	case SQLParserGENERATED:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(978)
			p.Match(SQLParserGENERATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLParserALWAYS:
			{
				p.SetState(979)
				p.Match(SQLParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SQLParserBY:
			{
				p.SetState(980)
				p.Match(SQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(981)
				p.Match(SQLParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(984)
			p.Match(SQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SQLParserIDENTITY:
			{
				p.SetState(985)
				p.Match(SQLParserIDENTITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(987)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLParserLPAREN {
				{
					p.SetState(986)
					p.IdentityOptions()
				}

			}

		case SQLParserLPAREN:
			{
				p.SetState(989)
				p.Match(SQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(990)
				p.expression(0)
			}
			{
				p.SetState(991)
				p.Match(SQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(993)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SQLParserSTORED {
				{
					p.SetState(992)
					p.Match(SQLParserSTORED)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case SQLParserREFERENCES:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(997)
			p.Match(SQLParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(998)
			p.TableName()
		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserLPAREN {
			{
				p.SetState(999)
				p.Match(SQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1000)
				p.Identifier()
			}
			{
				p.SetState(1001)
				p.Match(SQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserON {
			{
				p.SetState(1005)
				p.ReferentialAction()
			}

			p.SetState(1010)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case SQLParserCHECK:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1011)
			p.Match(SQLParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1012)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1013)
			p.expression(0)
		}
		{
			p.SetState(1014)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserMETADATA:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1016)
			p.Match(SQLParserMETADATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserFROM {
			{
				p.SetState(1017)
				p.Match(SQLParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1018)
				p.Match(SQLParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserVIRTUAL {
			{
				p.SetState(1021)
				p.Match(SQLParserVIRTUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SQLParserCOLLATE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1024)
			p.Match(SQLParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1025)
			p.Identifier()
		}

	case SQLParserCHARACTER:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1026)
			p.Match(SQLParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1027)
			p.Match(SQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1028)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOptionsContext is an interface to support dynamic dispatch.
type IIdentityOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	START() antlr.TerminalNode
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	MINVALUE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	CYCLE() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	BY() antlr.TerminalNode

	// IsIdentityOptionsContext differentiates from other interfaces.
	IsIdentityOptionsContext()
}

type IdentityOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentityOptionsContext() *IdentityOptionsContext {
	var p = new(IdentityOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_identityOptions
	return p
}

func InitEmptyIdentityOptionsContext(p *IdentityOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_identityOptions
}

func (*IdentityOptionsContext) IsIdentityOptionsContext() {}

func NewIdentityOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOptionsContext {
	var p = new(IdentityOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_identityOptions

	return p
}

func (s *IdentityOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOptionsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *IdentityOptionsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *IdentityOptionsContext) START() antlr.TerminalNode {
	return s.GetToken(SQLParserSTART, 0)
}

func (s *IdentityOptionsContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(SQLParserNUMBER)
}

func (s *IdentityOptionsContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserNUMBER, i)
}

func (s *IdentityOptionsContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(SQLParserINCREMENT, 0)
}

func (s *IdentityOptionsContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(SQLParserMINVALUE, 0)
}

func (s *IdentityOptionsContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(SQLParserNO)
}

func (s *IdentityOptionsContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserNO, i)
}

func (s *IdentityOptionsContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(SQLParserMAXVALUE, 0)
}

func (s *IdentityOptionsContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(SQLParserCYCLE, 0)
}

func (s *IdentityOptionsContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SQLParserCACHE, 0)
}

func (s *IdentityOptionsContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLParserWITH, 0)
}

func (s *IdentityOptionsContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *IdentityOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterIdentityOptions(s)
	}
}

func (s *IdentityOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitIdentityOptions(s)
	}
}

func (s *IdentityOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitIdentityOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) IdentityOptions() (localctx IIdentityOptionsContext) {
	localctx = NewIdentityOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SQLParserRULE_identityOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserSTART {
		{
			p.SetState(1032)
			p.Match(SQLParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserWITH {
			{
				p.SetState(1033)
				p.Match(SQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1036)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserINCREMENT {
		{
			p.SetState(1039)
			p.Match(SQLParserINCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserBY {
			{
				p.SetState(1040)
				p.Match(SQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1043)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1046)
			p.Match(SQLParserMINVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1047)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1048)
			p.Match(SQLParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1049)
			p.Match(SQLParserMINVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1052)
			p.Match(SQLParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1054)
			p.Match(SQLParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1055)
			p.Match(SQLParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case SQLParserCYCLE:
		{
			p.SetState(1058)
			p.Match(SQLParserCYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserNO:
		{
			p.SetState(1059)
			p.Match(SQLParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1060)
			p.Match(SQLParserCYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserCACHE, SQLParserRPAREN:

	default:
	}
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserCACHE {
		{
			p.SetState(1063)
			p.Match(SQLParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1064)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1067)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferentialActionContext is an interface to support dynamic dispatch.
type IReferentialActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	ReferentialActionType() IReferentialActionTypeContext
	UPDATE() antlr.TerminalNode

	// IsReferentialActionContext differentiates from other interfaces.
	IsReferentialActionContext()
}

type ReferentialActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferentialActionContext() *ReferentialActionContext {
	var p = new(ReferentialActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_referentialAction
	return p
}

func InitEmptyReferentialActionContext(p *ReferentialActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_referentialAction
}

func (*ReferentialActionContext) IsReferentialActionContext() {}

func NewReferentialActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferentialActionContext {
	var p = new(ReferentialActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_referentialAction

	return p
}

func (s *ReferentialActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferentialActionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLParserON, 0)
}

func (s *ReferentialActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLParserDELETE, 0)
}

func (s *ReferentialActionContext) ReferentialActionType() IReferentialActionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialActionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialActionTypeContext)
}

func (s *ReferentialActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLParserUPDATE, 0)
}

func (s *ReferentialActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferentialActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferentialActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterReferentialAction(s)
	}
}

func (s *ReferentialActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitReferentialAction(s)
	}
}

func (s *ReferentialActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitReferentialAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ReferentialAction() (localctx IReferentialActionContext) {
	localctx = NewReferentialActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SQLParserRULE_referentialAction)
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1069)
			p.Match(SQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1070)
			p.Match(SQLParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1071)
			p.ReferentialActionType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1072)
			p.Match(SQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1073)
			p.Match(SQLParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1074)
			p.ReferentialActionType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferentialActionTypeContext is an interface to support dynamic dispatch.
type IReferentialActionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASCADE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode

	// IsReferentialActionTypeContext differentiates from other interfaces.
	IsReferentialActionTypeContext()
}

type ReferentialActionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferentialActionTypeContext() *ReferentialActionTypeContext {
	var p = new(ReferentialActionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_referentialActionType
	return p
}

func InitEmptyReferentialActionTypeContext(p *ReferentialActionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_referentialActionType
}

func (*ReferentialActionTypeContext) IsReferentialActionTypeContext() {}

func NewReferentialActionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferentialActionTypeContext {
	var p = new(ReferentialActionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_referentialActionType

	return p
}

func (s *ReferentialActionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferentialActionTypeContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQLParserCASCADE, 0)
}

func (s *ReferentialActionTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLParserSET, 0)
}

func (s *ReferentialActionTypeContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLParserNULL, 0)
}

func (s *ReferentialActionTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLParserDEFAULT, 0)
}

func (s *ReferentialActionTypeContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SQLParserRESTRICT, 0)
}

func (s *ReferentialActionTypeContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLParserNO, 0)
}

func (s *ReferentialActionTypeContext) ACTION() antlr.TerminalNode {
	return s.GetToken(SQLParserACTION, 0)
}

func (s *ReferentialActionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferentialActionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferentialActionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterReferentialActionType(s)
	}
}

func (s *ReferentialActionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitReferentialActionType(s)
	}
}

func (s *ReferentialActionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitReferentialActionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ReferentialActionType() (localctx IReferentialActionTypeContext) {
	localctx = NewReferentialActionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SQLParserRULE_referentialActionType)
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1077)
			p.Match(SQLParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1078)
			p.Match(SQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1079)
			p.Match(SQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1080)
			p.Match(SQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1081)
			p.Match(SQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1082)
			p.Match(SQLParserRESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1083)
			p.Match(SQLParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1084)
			p.Match(SQLParserACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotEnforcedContext is an interface to support dynamic dispatch.
type INotEnforcedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode

	// IsNotEnforcedContext differentiates from other interfaces.
	IsNotEnforcedContext()
}

type NotEnforcedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotEnforcedContext() *NotEnforcedContext {
	var p = new(NotEnforcedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_notEnforced
	return p
}

func InitEmptyNotEnforcedContext(p *NotEnforcedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_notEnforced
}

func (*NotEnforcedContext) IsNotEnforcedContext() {}

func NewNotEnforcedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotEnforcedContext {
	var p = new(NotEnforcedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_notEnforced

	return p
}

func (s *NotEnforcedContext) GetParser() antlr.Parser { return s.parser }

func (s *NotEnforcedContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *NotEnforcedContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(SQLParserENFORCED, 0)
}

func (s *NotEnforcedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotEnforcedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotEnforcedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterNotEnforced(s)
	}
}

func (s *NotEnforcedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitNotEnforced(s)
	}
}

func (s *NotEnforcedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitNotEnforced(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) NotEnforced() (localctx INotEnforcedContext) {
	localctx = NewNotEnforcedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SQLParserRULE_notEnforced)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1087)
		p.Match(SQLParserNOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1088)
		p.Match(SQLParserENFORCED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	NotEnforced() INotEnforcedContext
	UNIQUE() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	TableName() ITableNameContext
	CHECK() antlr.TerminalNode
	Expression() IExpressionContext
	CONSTRAINT() antlr.TerminalNode
	TableConstraint() ITableConstraintContext

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableConstraint
	return p
}

func InitEmptyTableConstraintContext(p *TableConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableConstraint
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLParserPRIMARY, 0)
}

func (s *TableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLParserKEY, 0)
}

func (s *TableConstraintContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserLPAREN)
}

func (s *TableConstraintContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, i)
}

func (s *TableConstraintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TableConstraintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableConstraintContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserRPAREN)
}

func (s *TableConstraintContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, i)
}

func (s *TableConstraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *TableConstraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *TableConstraintContext) NotEnforced() INotEnforcedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEnforcedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEnforcedContext)
}

func (s *TableConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLParserUNIQUE, 0)
}

func (s *TableConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SQLParserFOREIGN, 0)
}

func (s *TableConstraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQLParserREFERENCES, 0)
}

func (s *TableConstraintContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLParserCHECK, 0)
}

func (s *TableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLParserCONSTRAINT, 0)
}

func (s *TableConstraintContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableConstraint(s)
	}
}

func (s *TableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableConstraint(s)
	}
}

func (s *TableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SQLParserRULE_tableConstraint)
	var _la int

	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1090)
			p.Match(SQLParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1091)
			p.Match(SQLParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1092)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1093)
			p.Identifier()
		}
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1094)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1095)
				p.Identifier()
			}

			p.SetState(1100)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1101)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1103)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserNOT {
			{
				p.SetState(1102)
				p.NotEnforced()
			}

		}

	case SQLParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1105)
			p.Match(SQLParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1106)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1107)
			p.Identifier()
		}
		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1108)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1109)
				p.Identifier()
			}

			p.SetState(1114)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1115)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserNOT {
			{
				p.SetState(1116)
				p.NotEnforced()
			}

		}

	case SQLParserFOREIGN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1119)
			p.Match(SQLParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1120)
			p.Match(SQLParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1121)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1122)
			p.Identifier()
		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1123)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1124)
				p.Identifier()
			}

			p.SetState(1129)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1130)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1131)
			p.Match(SQLParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1132)
			p.TableName()
		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserLPAREN {
			{
				p.SetState(1133)
				p.Match(SQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1134)
				p.Identifier()
			}
			p.SetState(1139)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SQLParserCOMMA {
				{
					p.SetState(1135)
					p.Match(SQLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1136)
					p.Identifier()
				}

				p.SetState(1141)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1142)
				p.Match(SQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserNOT {
			{
				p.SetState(1146)
				p.NotEnforced()
			}

		}

	case SQLParserCHECK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1149)
			p.Match(SQLParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1150)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1151)
			p.expression(0)
		}
		{
			p.SetState(1152)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserCONSTRAINT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1154)
			p.Match(SQLParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1155)
			p.Identifier()
		}
		{
			p.SetState(1156)
			p.TableConstraint()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionedByClauseContext is an interface to support dynamic dispatch.
type IPartitionedByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITIONED() antlr.TerminalNode
	BY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllColumnDefinition() []IColumnDefinitionContext
	ColumnDefinition(i int) IColumnDefinitionContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsPartitionedByClauseContext differentiates from other interfaces.
	IsPartitionedByClauseContext()
}

type PartitionedByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionedByClauseContext() *PartitionedByClauseContext {
	var p = new(PartitionedByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_partitionedByClause
	return p
}

func InitEmptyPartitionedByClauseContext(p *PartitionedByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_partitionedByClause
}

func (*PartitionedByClauseContext) IsPartitionedByClauseContext() {}

func NewPartitionedByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionedByClauseContext {
	var p = new(PartitionedByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_partitionedByClause

	return p
}

func (s *PartitionedByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionedByClauseContext) PARTITIONED() antlr.TerminalNode {
	return s.GetToken(SQLParserPARTITIONED, 0)
}

func (s *PartitionedByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *PartitionedByClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *PartitionedByClauseContext) AllColumnDefinition() []IColumnDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionContext); ok {
			tst[i] = t.(IColumnDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionedByClauseContext) ColumnDefinition(i int) IColumnDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *PartitionedByClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *PartitionedByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *PartitionedByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *PartitionedByClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PartitionedByClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionedByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionedByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionedByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterPartitionedByClause(s)
	}
}

func (s *PartitionedByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitPartitionedByClause(s)
	}
}

func (s *PartitionedByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitPartitionedByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) PartitionedByClause() (localctx IPartitionedByClauseContext) {
	localctx = NewPartitionedByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SQLParserRULE_partitionedByClause)
	var _la int

	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1160)
			p.Match(SQLParserPARTITIONED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1161)
			p.Match(SQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1162)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1163)
			p.ColumnDefinition()
		}
		p.SetState(1168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1164)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1165)
				p.ColumnDefinition()
			}

			p.SetState(1170)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1171)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1173)
			p.Match(SQLParserPARTITIONED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1174)
			p.Match(SQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1175)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1176)
			p.Identifier()
		}
		p.SetState(1181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1177)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1178)
				p.Identifier()
			}

			p.SetState(1183)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1184)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusteredByClauseContext is an interface to support dynamic dispatch.
type IClusteredByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLUSTERED() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	SORTED() antlr.TerminalNode
	AllOrderByElement() []IOrderByElementContext
	OrderByElement(i int) IOrderByElementContext
	INTO() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode

	// IsClusteredByClauseContext differentiates from other interfaces.
	IsClusteredByClauseContext()
}

type ClusteredByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusteredByClauseContext() *ClusteredByClauseContext {
	var p = new(ClusteredByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_clusteredByClause
	return p
}

func InitEmptyClusteredByClauseContext(p *ClusteredByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_clusteredByClause
}

func (*ClusteredByClauseContext) IsClusteredByClauseContext() {}

func NewClusteredByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusteredByClauseContext {
	var p = new(ClusteredByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_clusteredByClause

	return p
}

func (s *ClusteredByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusteredByClauseContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLParserCLUSTERED, 0)
}

func (s *ClusteredByClauseContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SQLParserBY)
}

func (s *ClusteredByClauseContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserBY, i)
}

func (s *ClusteredByClauseContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserLPAREN)
}

func (s *ClusteredByClauseContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, i)
}

func (s *ClusteredByClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClusteredByClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClusteredByClauseContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserRPAREN)
}

func (s *ClusteredByClauseContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, i)
}

func (s *ClusteredByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *ClusteredByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *ClusteredByClauseContext) SORTED() antlr.TerminalNode {
	return s.GetToken(SQLParserSORTED, 0)
}

func (s *ClusteredByClauseContext) AllOrderByElement() []IOrderByElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByElementContext); ok {
			len++
		}
	}

	tst := make([]IOrderByElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByElementContext); ok {
			tst[i] = t.(IOrderByElementContext)
			i++
		}
	}

	return tst
}

func (s *ClusteredByClauseContext) OrderByElement(i int) IOrderByElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByElementContext)
}

func (s *ClusteredByClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLParserINTO, 0)
}

func (s *ClusteredByClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SQLParserNUMBER, 0)
}

func (s *ClusteredByClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(SQLParserBUCKETS, 0)
}

func (s *ClusteredByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusteredByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusteredByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterClusteredByClause(s)
	}
}

func (s *ClusteredByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitClusteredByClause(s)
	}
}

func (s *ClusteredByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitClusteredByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ClusteredByClause() (localctx IClusteredByClauseContext) {
	localctx = NewClusteredByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SQLParserRULE_clusteredByClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1188)
		p.Match(SQLParserCLUSTERED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1189)
		p.Match(SQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1190)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1191)
		p.Identifier()
	}
	p.SetState(1196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(1192)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1193)
			p.Identifier()
		}

		p.SetState(1198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1199)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserSORTED {
		{
			p.SetState(1200)
			p.Match(SQLParserSORTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1201)
			p.Match(SQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1202)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1203)
			p.OrderByElement()
		}
		p.SetState(1208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1204)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1205)
				p.OrderByElement()
			}

			p.SetState(1210)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1211)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserINTO {
		{
			p.SetState(1215)
			p.Match(SQLParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1216)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1217)
			p.Match(SQLParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributedByClauseContext is an interface to support dynamic dispatch.
type IDistributedByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	BROADCAST() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDistributedByClauseContext differentiates from other interfaces.
	IsDistributedByClauseContext()
}

type DistributedByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributedByClauseContext() *DistributedByClauseContext {
	var p = new(DistributedByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_distributedByClause
	return p
}

func InitEmptyDistributedByClauseContext(p *DistributedByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_distributedByClause
}

func (*DistributedByClauseContext) IsDistributedByClauseContext() {}

func NewDistributedByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributedByClauseContext {
	var p = new(DistributedByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_distributedByClause

	return p
}

func (s *DistributedByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributedByClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SQLParserDISTRIBUTED, 0)
}

func (s *DistributedByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *DistributedByClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLParserHASH, 0)
}

func (s *DistributedByClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *DistributedByClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DistributedByClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DistributedByClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *DistributedByClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(SQLParserRANDOM, 0)
}

func (s *DistributedByClauseContext) BROADCAST() antlr.TerminalNode {
	return s.GetToken(SQLParserBROADCAST, 0)
}

func (s *DistributedByClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(SQLParserBUCKETS, 0)
}

func (s *DistributedByClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SQLParserNUMBER, 0)
}

func (s *DistributedByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *DistributedByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *DistributedByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributedByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributedByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterDistributedByClause(s)
	}
}

func (s *DistributedByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitDistributedByClause(s)
	}
}

func (s *DistributedByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitDistributedByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) DistributedByClause() (localctx IDistributedByClauseContext) {
	localctx = NewDistributedByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SQLParserRULE_distributedByClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Match(SQLParserDISTRIBUTED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1221)
		p.Match(SQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserHASH:
		{
			p.SetState(1222)
			p.Match(SQLParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1223)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1224)
			p.Identifier()
		}
		p.SetState(1229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1225)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1226)
				p.Identifier()
			}

			p.SetState(1231)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1232)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserRANDOM:
		{
			p.SetState(1234)
			p.Match(SQLParserRANDOM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserBROADCAST:
		{
			p.SetState(1235)
			p.Match(SQLParserBROADCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserBUCKETS {
		{
			p.SetState(1238)
			p.Match(SQLParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1239)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortedByClauseContext is an interface to support dynamic dispatch.
type ISortedByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSortedByClauseContext differentiates from other interfaces.
	IsSortedByClauseContext()
}

type SortedByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortedByClauseContext() *SortedByClauseContext {
	var p = new(SortedByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_sortedByClause
	return p
}

func InitEmptySortedByClauseContext(p *SortedByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_sortedByClause
}

func (*SortedByClauseContext) IsSortedByClauseContext() {}

func NewSortedByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortedByClauseContext {
	var p = new(SortedByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_sortedByClause

	return p
}

func (s *SortedByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortedByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLParserORDER, 0)
}

func (s *SortedByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *SortedByClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *SortedByClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *SortedByClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SortedByClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *SortedByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *SortedByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *SortedByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortedByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortedByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSortedByClause(s)
	}
}

func (s *SortedByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSortedByClause(s)
	}
}

func (s *SortedByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSortedByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) SortedByClause() (localctx ISortedByClauseContext) {
	localctx = NewSortedByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SQLParserRULE_sortedByClause)
	var _la int

	p.SetState(1258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1242)
			p.Match(SQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1243)
			p.Match(SQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1244)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1245)
			p.Identifier()
		}
		p.SetState(1250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1246)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1247)
				p.Identifier()
			}

			p.SetState(1252)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1253)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1255)
			p.Match(SQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1256)
			p.Match(SQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1257)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableInheritsClauseContext is an interface to support dynamic dispatch.
type ITableInheritsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableInheritsClauseContext differentiates from other interfaces.
	IsTableInheritsClauseContext()
}

type TableInheritsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableInheritsClauseContext() *TableInheritsClauseContext {
	var p = new(TableInheritsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableInheritsClause
	return p
}

func InitEmptyTableInheritsClauseContext(p *TableInheritsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableInheritsClause
}

func (*TableInheritsClauseContext) IsTableInheritsClauseContext() {}

func NewTableInheritsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableInheritsClauseContext {
	var p = new(TableInheritsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableInheritsClause

	return p
}

func (s *TableInheritsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableInheritsClauseContext) INHERITS() antlr.TerminalNode {
	return s.GetToken(SQLParserINHERITS, 0)
}

func (s *TableInheritsClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *TableInheritsClauseContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TableInheritsClauseContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableInheritsClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *TableInheritsClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *TableInheritsClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *TableInheritsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableInheritsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableInheritsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableInheritsClause(s)
	}
}

func (s *TableInheritsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableInheritsClause(s)
	}
}

func (s *TableInheritsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableInheritsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableInheritsClause() (localctx ITableInheritsClauseContext) {
	localctx = NewTableInheritsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SQLParserRULE_tableInheritsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1260)
		p.Match(SQLParserINHERITS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1261)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1262)
		p.TableName()
	}
	p.SetState(1267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(1263)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1264)
			p.TableName()
		}

		p.SetState(1269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1270)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineClauseContext is an interface to support dynamic dispatch.
type IEngineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINE() antlr.TerminalNode
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsEngineClauseContext differentiates from other interfaces.
	IsEngineClauseContext()
}

type EngineClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineClauseContext() *EngineClauseContext {
	var p = new(EngineClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_engineClause
	return p
}

func InitEmptyEngineClauseContext(p *EngineClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_engineClause
}

func (*EngineClauseContext) IsEngineClauseContext() {}

func NewEngineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineClauseContext {
	var p = new(EngineClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_engineClause

	return p
}

func (s *EngineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineClauseContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(SQLParserENGINE, 0)
}

func (s *EngineClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EngineClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLParserEQ, 0)
}

func (s *EngineClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *EngineClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *EngineClauseContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *EngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterEngineClause(s)
	}
}

func (s *EngineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitEngineClause(s)
	}
}

func (s *EngineClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitEngineClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) EngineClause() (localctx IEngineClauseContext) {
	localctx = NewEngineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SQLParserRULE_engineClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1272)
		p.Match(SQLParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserEQ {
		{
			p.SetState(1273)
			p.Match(SQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1276)
		p.Identifier()
	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserLPAREN {
		{
			p.SetState(1277)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&575053377419476990) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-8070454380539068449) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-35184372088865) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&108649341010313215) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&268304513) != 0) {
			{
				p.SetState(1278)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1281)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetClauseContext is an interface to support dynamic dispatch.
type ICharsetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCharsetClauseContext differentiates from other interfaces.
	IsCharsetClauseContext()
}

type CharsetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetClauseContext() *CharsetClauseContext {
	var p = new(CharsetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_charsetClause
	return p
}

func InitEmptyCharsetClauseContext(p *CharsetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_charsetClause
}

func (*CharsetClauseContext) IsCharsetClauseContext() {}

func NewCharsetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetClauseContext {
	var p = new(CharsetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_charsetClause

	return p
}

func (s *CharsetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CharsetClauseContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(SQLParserCHARSET, 0)
}

func (s *CharsetClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SQLParserCHARACTER, 0)
}

func (s *CharsetClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLParserSET, 0)
}

func (s *CharsetClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLParserDEFAULT, 0)
}

func (s *CharsetClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLParserEQ, 0)
}

func (s *CharsetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCharsetClause(s)
	}
}

func (s *CharsetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCharsetClause(s)
	}
}

func (s *CharsetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCharsetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CharsetClause() (localctx ICharsetClauseContext) {
	localctx = NewCharsetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SQLParserRULE_charsetClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserDEFAULT {
		{
			p.SetState(1284)
			p.Match(SQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserCHARSET:
		{
			p.SetState(1287)
			p.Match(SQLParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserCHARACTER:
		{
			p.SetState(1288)
			p.Match(SQLParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1289)
			p.Match(SQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserEQ {
		{
			p.SetState(1292)
			p.Match(SQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1295)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollateClauseContext is an interface to support dynamic dispatch.
type ICollateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCollateClauseContext differentiates from other interfaces.
	IsCollateClauseContext()
}

type CollateClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollateClauseContext() *CollateClauseContext {
	var p = new(CollateClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_collateClause
	return p
}

func InitEmptyCollateClauseContext(p *CollateClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_collateClause
}

func (*CollateClauseContext) IsCollateClauseContext() {}

func NewCollateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateClauseContext {
	var p = new(CollateClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_collateClause

	return p
}

func (s *CollateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateClauseContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLParserCOLLATE, 0)
}

func (s *CollateClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLParserDEFAULT, 0)
}

func (s *CollateClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLParserEQ, 0)
}

func (s *CollateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCollateClause(s)
	}
}

func (s *CollateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCollateClause(s)
	}
}

func (s *CollateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCollateClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CollateClause() (localctx ICollateClauseContext) {
	localctx = NewCollateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SQLParserRULE_collateClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserDEFAULT {
		{
			p.SetState(1297)
			p.Match(SQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1300)
		p.Match(SQLParserCOLLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserEQ {
		{
			p.SetState(1301)
			p.Match(SQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1304)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceClauseContext is an interface to support dynamic dispatch.
type ITablespaceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESPACE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTablespaceClauseContext differentiates from other interfaces.
	IsTablespaceClauseContext()
}

type TablespaceClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceClauseContext() *TablespaceClauseContext {
	var p = new(TablespaceClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tablespaceClause
	return p
}

func InitEmptyTablespaceClauseContext(p *TablespaceClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tablespaceClause
}

func (*TablespaceClauseContext) IsTablespaceClauseContext() {}

func NewTablespaceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceClauseContext {
	var p = new(TablespaceClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tablespaceClause

	return p
}

func (s *TablespaceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceClauseContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLESPACE, 0)
}

func (s *TablespaceClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablespaceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTablespaceClause(s)
	}
}

func (s *TablespaceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTablespaceClause(s)
	}
}

func (s *TablespaceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTablespaceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TablespaceClause() (localctx ITablespaceClauseContext) {
	localctx = NewTablespaceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SQLParserRULE_tablespaceClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1306)
		p.Match(SQLParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1307)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITtlClauseContext is an interface to support dynamic dispatch.
type ITtlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TTL() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTtlClauseContext differentiates from other interfaces.
	IsTtlClauseContext()
}

type TtlClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtlClauseContext() *TtlClauseContext {
	var p = new(TtlClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_ttlClause
	return p
}

func InitEmptyTtlClauseContext(p *TtlClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_ttlClause
}

func (*TtlClauseContext) IsTtlClauseContext() {}

func NewTtlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtlClauseContext {
	var p = new(TtlClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_ttlClause

	return p
}

func (s *TtlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TtlClauseContext) TTL() antlr.TerminalNode {
	return s.GetToken(SQLParserTTL, 0)
}

func (s *TtlClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TtlClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TtlClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *TtlClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *TtlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTtlClause(s)
	}
}

func (s *TtlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTtlClause(s)
	}
}

func (s *TtlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTtlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TtlClause() (localctx ITtlClauseContext) {
	localctx = NewTtlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SQLParserRULE_ttlClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		p.Match(SQLParserTTL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1310)
		p.expression(0)
	}
	p.SetState(1315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(1311)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1312)
			p.expression(0)
		}

		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILifecycleClauseContext is an interface to support dynamic dispatch.
type ILifecycleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIFECYCLE() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsLifecycleClauseContext differentiates from other interfaces.
	IsLifecycleClauseContext()
}

type LifecycleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLifecycleClauseContext() *LifecycleClauseContext {
	var p = new(LifecycleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_lifecycleClause
	return p
}

func InitEmptyLifecycleClauseContext(p *LifecycleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_lifecycleClause
}

func (*LifecycleClauseContext) IsLifecycleClauseContext() {}

func NewLifecycleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LifecycleClauseContext {
	var p = new(LifecycleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_lifecycleClause

	return p
}

func (s *LifecycleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LifecycleClauseContext) LIFECYCLE() antlr.TerminalNode {
	return s.GetToken(SQLParserLIFECYCLE, 0)
}

func (s *LifecycleClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SQLParserNUMBER, 0)
}

func (s *LifecycleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LifecycleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LifecycleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterLifecycleClause(s)
	}
}

func (s *LifecycleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitLifecycleClause(s)
	}
}

func (s *LifecycleClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitLifecycleClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) LifecycleClause() (localctx ILifecycleClauseContext) {
	localctx = NewLifecycleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SQLParserRULE_lifecycleClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1318)
		p.Match(SQLParserLIFECYCLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1319)
		p.Match(SQLParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowFormatClauseContext is an interface to support dynamic dispatch.
type IRowFormatClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROW_FORMAT() antlr.TerminalNode
	SERDE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	SERDEPROPERTIES() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	PropertyList() IPropertyListContext
	RPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsRowFormatClauseContext differentiates from other interfaces.
	IsRowFormatClauseContext()
}

type RowFormatClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowFormatClauseContext() *RowFormatClauseContext {
	var p = new(RowFormatClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_rowFormatClause
	return p
}

func InitEmptyRowFormatClauseContext(p *RowFormatClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_rowFormatClause
}

func (*RowFormatClauseContext) IsRowFormatClauseContext() {}

func NewRowFormatClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowFormatClauseContext {
	var p = new(RowFormatClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_rowFormatClause

	return p
}

func (s *RowFormatClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RowFormatClauseContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(SQLParserROW_FORMAT, 0)
}

func (s *RowFormatClauseContext) SERDE() antlr.TerminalNode {
	return s.GetToken(SQLParserSERDE, 0)
}

func (s *RowFormatClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *RowFormatClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLParserWITH, 0)
}

func (s *RowFormatClauseContext) SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SQLParserSERDEPROPERTIES, 0)
}

func (s *RowFormatClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *RowFormatClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *RowFormatClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *RowFormatClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RowFormatClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowFormatClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterRowFormatClause(s)
	}
}

func (s *RowFormatClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitRowFormatClause(s)
	}
}

func (s *RowFormatClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitRowFormatClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) RowFormatClause() (localctx IRowFormatClauseContext) {
	localctx = NewRowFormatClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SQLParserRULE_rowFormatClause)
	p.SetState(1334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1321)
			p.Match(SQLParserROW_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1322)
			p.Match(SQLParserSERDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1323)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1330)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1324)
				p.Match(SQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1325)
				p.Match(SQLParserSERDEPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1326)
				p.Match(SQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1327)
				p.PropertyList()
			}
			{
				p.SetState(1328)
				p.Match(SQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1332)
			p.Match(SQLParserROW_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStoredAsClauseContext is an interface to support dynamic dispatch.
type IStoredAsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORED() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsStoredAsClauseContext differentiates from other interfaces.
	IsStoredAsClauseContext()
}

type StoredAsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStoredAsClauseContext() *StoredAsClauseContext {
	var p = new(StoredAsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_storedAsClause
	return p
}

func InitEmptyStoredAsClauseContext(p *StoredAsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_storedAsClause
}

func (*StoredAsClauseContext) IsStoredAsClauseContext() {}

func NewStoredAsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StoredAsClauseContext {
	var p = new(StoredAsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_storedAsClause

	return p
}

func (s *StoredAsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *StoredAsClauseContext) STORED() antlr.TerminalNode {
	return s.GetToken(SQLParserSTORED, 0)
}

func (s *StoredAsClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *StoredAsClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *StoredAsClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StoredAsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StoredAsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StoredAsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterStoredAsClause(s)
	}
}

func (s *StoredAsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitStoredAsClause(s)
	}
}

func (s *StoredAsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitStoredAsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) StoredAsClause() (localctx IStoredAsClauseContext) {
	localctx = NewStoredAsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SQLParserRULE_storedAsClause)
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1336)
			p.Match(SQLParserSTORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.Match(SQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1338)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1339)
			p.Match(SQLParserSTORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1340)
			p.Match(SQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.Identifier()
		}
		{
			p.SetState(1342)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocationClauseContext is an interface to support dynamic dispatch.
type ILocationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCATION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsLocationClauseContext differentiates from other interfaces.
	IsLocationClauseContext()
}

type LocationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocationClauseContext() *LocationClauseContext {
	var p = new(LocationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_locationClause
	return p
}

func InitEmptyLocationClauseContext(p *LocationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_locationClause
}

func (*LocationClauseContext) IsLocationClauseContext() {}

func NewLocationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocationClauseContext {
	var p = new(LocationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_locationClause

	return p
}

func (s *LocationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LocationClauseContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(SQLParserLOCATION, 0)
}

func (s *LocationClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *LocationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterLocationClause(s)
	}
}

func (s *LocationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitLocationClause(s)
	}
}

func (s *LocationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitLocationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) LocationClause() (localctx ILocationClauseContext) {
	localctx = NewLocationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SQLParserRULE_locationClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1346)
		p.Match(SQLParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1347)
		p.Match(SQLParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePropertiesClauseContext is an interface to support dynamic dispatch.
type ITablePropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TBLPROPERTIES() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	PropertyList() IPropertyListContext
	RPAREN() antlr.TerminalNode

	// IsTablePropertiesClauseContext differentiates from other interfaces.
	IsTablePropertiesClauseContext()
}

type TablePropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesClauseContext() *TablePropertiesClauseContext {
	var p = new(TablePropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tablePropertiesClause
	return p
}

func InitEmptyTablePropertiesClauseContext(p *TablePropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tablePropertiesClause
}

func (*TablePropertiesClauseContext) IsTablePropertiesClauseContext() {}

func NewTablePropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesClauseContext {
	var p = new(TablePropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tablePropertiesClause

	return p
}

func (s *TablePropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesClauseContext) TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SQLParserTBLPROPERTIES, 0)
}

func (s *TablePropertiesClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *TablePropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *TablePropertiesClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *TablePropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTablePropertiesClause(s)
	}
}

func (s *TablePropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTablePropertiesClause(s)
	}
}

func (s *TablePropertiesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTablePropertiesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TablePropertiesClause() (localctx ITablePropertiesClauseContext) {
	localctx = NewTablePropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SQLParserRULE_tablePropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Match(SQLParserTBLPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1350)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1351)
		p.PropertyList()
	}
	{
		p.SetState(1352)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithOptionsClauseContext is an interface to support dynamic dispatch.
type IWithOptionsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	PropertyList() IPropertyListContext
	RPAREN() antlr.TerminalNode

	// IsWithOptionsClauseContext differentiates from other interfaces.
	IsWithOptionsClauseContext()
}

type WithOptionsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithOptionsClauseContext() *WithOptionsClauseContext {
	var p = new(WithOptionsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_withOptionsClause
	return p
}

func InitEmptyWithOptionsClauseContext(p *WithOptionsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_withOptionsClause
}

func (*WithOptionsClauseContext) IsWithOptionsClauseContext() {}

func NewWithOptionsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithOptionsClauseContext {
	var p = new(WithOptionsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_withOptionsClause

	return p
}

func (s *WithOptionsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithOptionsClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLParserWITH, 0)
}

func (s *WithOptionsClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *WithOptionsClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *WithOptionsClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *WithOptionsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithOptionsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithOptionsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterWithOptionsClause(s)
	}
}

func (s *WithOptionsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitWithOptionsClause(s)
	}
}

func (s *WithOptionsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitWithOptionsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) WithOptionsClause() (localctx IWithOptionsClauseContext) {
	localctx = NewWithOptionsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SQLParserRULE_withOptionsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1354)
		p.Match(SQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1355)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1356)
		p.PropertyList()
	}
	{
		p.SetState(1357)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyListContext is an interface to support dynamic dispatch.
type IPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyListContext differentiates from other interfaces.
	IsPropertyListContext()
}

type PropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyListContext() *PropertyListContext {
	var p = new(PropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_propertyList
	return p
}

func InitEmptyPropertyListContext(p *PropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_propertyList
}

func (*PropertyListContext) IsPropertyListContext() {}

func NewPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyListContext {
	var p = new(PropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_propertyList

	return p
}

func (s *PropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *PropertyListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *PropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterPropertyList(s)
	}
}

func (s *PropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitPropertyList(s)
	}
}

func (s *PropertyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitPropertyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) PropertyList() (localctx IPropertyListContext) {
	localctx = NewPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SQLParserRULE_propertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.Property()
	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(1360)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1361)
			p.Property()
		}

		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(SQLParserSTRING_LITERAL)
}

func (s *PropertyContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, i)
}

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLParserEQ, 0)
}

func (s *PropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (s *PropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SQLParserRULE_property)
	p.SetState(1374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1367)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1368)
			p.Match(SQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1369)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserSELECT, SQLParserFROM, SQLParserWHERE, SQLParserAND, SQLParserOR, SQLParserNOT, SQLParserAS, SQLParserON, SQLParserJOIN, SQLParserINNER, SQLParserLEFT, SQLParserRIGHT, SQLParserOUTER, SQLParserCROSS, SQLParserFULL, SQLParserNATURAL, SQLParserINSERT, SQLParserINTO, SQLParserVALUES, SQLParserUPDATE, SQLParserSET, SQLParserDELETE, SQLParserTRUNCATE, SQLParserCREATE, SQLParserTABLE, SQLParserVIEW, SQLParserDATABASE, SQLParserSCHEMA, SQLParserDROP, SQLParserALTER, SQLParserINDEX, SQLParserADD, SQLParserCOLUMN, SQLParserRENAME, SQLParserTO, SQLParserMODIFY, SQLParserCHANGE, SQLParserCONSTRAINT, SQLParserPRIMARY, SQLParserKEY, SQLParserFOREIGN, SQLParserREFERENCES, SQLParserUNIQUE, SQLParserCHECK, SQLParserDEFAULT, SQLParserCOMMENT, SQLParserTEMPORARY, SQLParserTEMP, SQLParserEXTERNAL, SQLParserLOCATION, SQLParserSTORED, SQLParserFORMAT, SQLParserTBLPROPERTIES, SQLParserROW_FORMAT, SQLParserSERDE, SQLParserSERDEPROPERTIES, SQLParserCLUSTERED, SQLParserSORTED, SQLParserBUCKETS, SQLParserPARTITIONED, SQLParserWATERMARK, SQLParserFOR, SQLParserSYSTEM_TIME, SQLParserSYSTEM, SQLParserENFORCED, SQLParserMETADATA, SQLParserVIRTUAL, SQLParserWITHOUT, SQLParserGENERATED, SQLParserALWAYS, SQLParserIDENTITY, SQLParserSTART, SQLParserINCREMENT, SQLParserMINVALUE, SQLParserMAXVALUE, SQLParserCYCLE, SQLParserCACHE, SQLParserMERGE, SQLParserUSING, SQLParserMATCHED, SQLParserUPSERT, SQLParserOVERWRITE, SQLParserREPLACE, SQLParserIGNORE, SQLParserDUPLICATE, SQLParserLATERAL, SQLParserUNNEST, SQLParserEXPLODE, SQLParserTABLESAMPLE, SQLParserPERCENT, SQLParserBUCKET, SQLParserOUT, SQLParserOF, SQLParserDISTRIBUTED, SQLParserHASH, SQLParserRANDOM, SQLParserBROADCAST, SQLParserREPLICATED, SQLParserPROPERTIES, SQLParserENGINE, SQLParserCHARSET, SQLParserCHARACTER, SQLParserCOLLATE, SQLParserTABLESPACE, SQLParserINHERITS, SQLParserFILEGROUP, SQLParserGLOBAL, SQLParserLOCAL, SQLParserUNLOGGED, SQLParserTTL, SQLParserLIFECYCLE, SQLParserAUTO, SQLParserRESTRICT, SQLParserCASCADE, SQLParserACTION, SQLParserOVER, SQLParserPARTITION, SQLParserROWS, SQLParserRANGE, SQLParserGROUPS, SQLParserUNBOUNDED, SQLParserPRECEDING, SQLParserFOLLOWING, SQLParserCURRENT, SQLParserROW, SQLParserFIRST, SQLParserLAST, SQLParserNULLS, SQLParserEXCLUDE, SQLParserTIES, SQLParserNO, SQLParserOTHERS, SQLParserGROUP, SQLParserBY, SQLParserORDER, SQLParserASC, SQLParserDESC, SQLParserHAVING, SQLParserLIMIT, SQLParserOFFSET, SQLParserFETCH, SQLParserNEXT, SQLParserONLY, SQLParserTOP, SQLParserUNION, SQLParserINTERSECT, SQLParserEXCEPT, SQLParserMINUS_SET, SQLParserALL, SQLParserDISTINCT, SQLParserWITH, SQLParserRECURSIVE, SQLParserCASE, SQLParserWHEN, SQLParserTHEN, SQLParserELSE, SQLParserEND, SQLParserNULL, SQLParserIS, SQLParserIN, SQLParserBETWEEN, SQLParserLIKE, SQLParserILIKE, SQLParserRLIKE, SQLParserREGEXP, SQLParserSIMILAR, SQLParserESCAPE, SQLParserEXISTS, SQLParserTRUE, SQLParserFALSE, SQLParserUNKNOWN, SQLParserCAST, SQLParserCONVERT, SQLParserTRY_CAST, SQLParserEXTRACT, SQLParserINTERVAL, SQLParserAT, SQLParserZONE, SQLParserTIME, SQLParserTIMESTAMP, SQLParserDATE, SQLParserYEAR, SQLParserMONTH, SQLParserDAY, SQLParserHOUR, SQLParserMINUTE, SQLParserSECOND, SQLParserSOME, SQLParserANY, SQLParserARRAY, SQLParserMAP, SQLParserSTRUCT, SQLParserNAMED_STRUCT, SQLParserINT, SQLParserINTEGER, SQLParserTINYINT, SQLParserSMALLINT, SQLParserBIGINT, SQLParserFLOAT, SQLParserDOUBLE, SQLParserDECIMAL, SQLParserNUMERIC, SQLParserREAL, SQLParserBOOLEAN, SQLParserBOOL, SQLParserSTRING, SQLParserVARCHAR, SQLParserCHAR, SQLParserTEXT, SQLParserBINARY, SQLParserVARBINARY, SQLParserBLOB, SQLParserCLOB, SQLParserJSON, SQLParserXML, SQLParserBYTES, SQLParserMULTISET, SQLParserRAW, SQLParserDOUBLE_QUOTED_STRING, SQLParserIDENTIFIER, SQLParserBACKTICK_IDENTIFIER, SQLParserBRACKET_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1370)
			p.Identifier()
		}
		{
			p.SetState(1371)
			p.Match(SQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1372)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewStatementContext is an interface to support dynamic dispatch.
type ICreateViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	TableName() ITableNameContext
	AS() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF_P() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateViewStatementContext differentiates from other interfaces.
	IsCreateViewStatementContext()
}

type CreateViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateViewStatementContext() *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createViewStatement
	return p
}

func InitEmptyCreateViewStatementContext(p *CreateViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createViewStatement
}

func (*CreateViewStatementContext) IsCreateViewStatementContext() {}

func NewCreateViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_createViewStatement

	return p
}

func (s *CreateViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLParserCREATE, 0)
}

func (s *CreateViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLParserVIEW, 0)
}

func (s *CreateViewStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *CreateViewStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CreateViewStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLParserOR, 0)
}

func (s *CreateViewStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLParserREPLACE, 0)
}

func (s *CreateViewStatementContext) IF_P() antlr.TerminalNode {
	return s.GetToken(SQLParserIF_P, 0)
}

func (s *CreateViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *CreateViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLParserEXISTS, 0)
}

func (s *CreateViewStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *CreateViewStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateViewStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *CreateViewStatementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMENT, 0)
}

func (s *CreateViewStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *CreateViewStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SQLParserTEMPORARY, 0)
}

func (s *CreateViewStatementContext) TEMP() antlr.TerminalNode {
	return s.GetToken(SQLParserTEMP, 0)
}

func (s *CreateViewStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *CreateViewStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *CreateViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCreateViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CreateViewStatement() (localctx ICreateViewStatementContext) {
	localctx = NewCreateViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SQLParserRULE_createViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1376)
		p.Match(SQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserOR {
		{
			p.SetState(1377)
			p.Match(SQLParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1378)
			p.Match(SQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserTEMPORARY || _la == SQLParserTEMP {
		{
			p.SetState(1381)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserTEMPORARY || _la == SQLParserTEMP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1384)
		p.Match(SQLParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserIF_P {
		{
			p.SetState(1385)
			p.Match(SQLParserIF_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1386)
			p.Match(SQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1387)
			p.Match(SQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1390)
		p.TableName()
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserLPAREN {
		{
			p.SetState(1391)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1392)
			p.Identifier()
		}
		p.SetState(1397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1393)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1394)
				p.Identifier()
			}

			p.SetState(1399)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1400)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserCOMMENT {
		{
			p.SetState(1404)
			p.Match(SQLParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1405)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1408)
		p.Match(SQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1409)
		p.SelectStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDatabaseStatementContext is an interface to support dynamic dispatch.
type ICreateDatabaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IF_P() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	LocationClause() ILocationClauseContext
	WITH() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsCreateDatabaseStatementContext differentiates from other interfaces.
	IsCreateDatabaseStatementContext()
}

type CreateDatabaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseStatementContext() *CreateDatabaseStatementContext {
	var p = new(CreateDatabaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createDatabaseStatement
	return p
}

func InitEmptyCreateDatabaseStatementContext(p *CreateDatabaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createDatabaseStatement
}

func (*CreateDatabaseStatementContext) IsCreateDatabaseStatementContext() {}

func NewCreateDatabaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseStatementContext {
	var p = new(CreateDatabaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_createDatabaseStatement

	return p
}

func (s *CreateDatabaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLParserCREATE, 0)
}

func (s *CreateDatabaseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateDatabaseStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLParserDATABASE, 0)
}

func (s *CreateDatabaseStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLParserSCHEMA, 0)
}

func (s *CreateDatabaseStatementContext) IF_P() antlr.TerminalNode {
	return s.GetToken(SQLParserIF_P, 0)
}

func (s *CreateDatabaseStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *CreateDatabaseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLParserEXISTS, 0)
}

func (s *CreateDatabaseStatementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMENT, 0)
}

func (s *CreateDatabaseStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *CreateDatabaseStatementContext) LocationClause() ILocationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationClauseContext)
}

func (s *CreateDatabaseStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLParserWITH, 0)
}

func (s *CreateDatabaseStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateDatabaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCreateDatabaseStatement(s)
	}
}

func (s *CreateDatabaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCreateDatabaseStatement(s)
	}
}

func (s *CreateDatabaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCreateDatabaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CreateDatabaseStatement() (localctx ICreateDatabaseStatementContext) {
	localctx = NewCreateDatabaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SQLParserRULE_createDatabaseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1411)
		p.Match(SQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1412)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLParserDATABASE || _la == SQLParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserIF_P {
		{
			p.SetState(1413)
			p.Match(SQLParserIF_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1414)
			p.Match(SQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1415)
			p.Match(SQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1418)
		p.Identifier()
	}
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserCOMMENT {
		{
			p.SetState(1419)
			p.Match(SQLParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1420)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserLOCATION {
		{
			p.SetState(1423)
			p.LocationClause()
		}

	}
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserWITH {
		{
			p.SetState(1426)
			p.Match(SQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexStatementContext is an interface to support dynamic dispatch.
type ICreateIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	LPAREN() antlr.TerminalNode
	AllIndexColumn() []IIndexColumnContext
	IndexColumn(i int) IIndexColumnContext
	RPAREN() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	IF_P() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateIndexStatementContext differentiates from other interfaces.
	IsCreateIndexStatementContext()
}

type CreateIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateIndexStatementContext() *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createIndexStatement
	return p
}

func InitEmptyCreateIndexStatementContext(p *CreateIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_createIndexStatement
}

func (*CreateIndexStatementContext) IsCreateIndexStatementContext() {}

func NewCreateIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_createIndexStatement

	return p
}

func (s *CreateIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLParserCREATE, 0)
}

func (s *CreateIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLParserINDEX, 0)
}

func (s *CreateIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLParserON, 0)
}

func (s *CreateIndexStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateIndexStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *CreateIndexStatementContext) AllIndexColumn() []IIndexColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexColumnContext); ok {
			len++
		}
	}

	tst := make([]IIndexColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexColumnContext); ok {
			tst[i] = t.(IIndexColumnContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexStatementContext) IndexColumn(i int) IIndexColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnContext)
}

func (s *CreateIndexStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *CreateIndexStatementContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLParserUNIQUE, 0)
}

func (s *CreateIndexStatementContext) IF_P() antlr.TerminalNode {
	return s.GetToken(SQLParserIF_P, 0)
}

func (s *CreateIndexStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *CreateIndexStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLParserEXISTS, 0)
}

func (s *CreateIndexStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *CreateIndexStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *CreateIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCreateIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CreateIndexStatement() (localctx ICreateIndexStatementContext) {
	localctx = NewCreateIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SQLParserRULE_createIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1430)
		p.Match(SQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserUNIQUE {
		{
			p.SetState(1431)
			p.Match(SQLParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1434)
		p.Match(SQLParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserIF_P {
		{
			p.SetState(1435)
			p.Match(SQLParserIF_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1436)
			p.Match(SQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1437)
			p.Match(SQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1440)
		p.Identifier()
	}
	{
		p.SetState(1441)
		p.Match(SQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1442)
		p.TableName()
	}
	{
		p.SetState(1443)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1444)
		p.IndexColumn()
	}
	p.SetState(1449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(1445)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1446)
			p.IndexColumn()
		}

		p.SetState(1451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1452)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnContext is an interface to support dynamic dispatch.
type IIndexColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsIndexColumnContext differentiates from other interfaces.
	IsIndexColumnContext()
}

type IndexColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnContext() *IndexColumnContext {
	var p = new(IndexColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_indexColumn
	return p
}

func InitEmptyIndexColumnContext(p *IndexColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_indexColumn
}

func (*IndexColumnContext) IsIndexColumnContext() {}

func NewIndexColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnContext {
	var p = new(IndexColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_indexColumn

	return p
}

func (s *IndexColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexColumnContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLParserASC, 0)
}

func (s *IndexColumnContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLParserDESC, 0)
}

func (s *IndexColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterIndexColumn(s)
	}
}

func (s *IndexColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitIndexColumn(s)
	}
}

func (s *IndexColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitIndexColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) IndexColumn() (localctx IIndexColumnContext) {
	localctx = NewIndexColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SQLParserRULE_indexColumn)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		p.Identifier()
	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserASC || _la == SQLParserDESC {
		{
			p.SetState(1455)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserASC || _la == SQLParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStatementContext is an interface to support dynamic dispatch.
type IDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	IF_P() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode

	// IsDropStatementContext differentiates from other interfaces.
	IsDropStatementContext()
}

type DropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropStatementContext() *DropStatementContext {
	var p = new(DropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_dropStatement
	return p
}

func InitEmptyDropStatementContext(p *DropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_dropStatement
}

func (*DropStatementContext) IsDropStatementContext() {}

func NewDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStatementContext {
	var p = new(DropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_dropStatement

	return p
}

func (s *DropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLParserDROP, 0)
}

func (s *DropStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLE, 0)
}

func (s *DropStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DropStatementContext) IF_P() antlr.TerminalNode {
	return s.GetToken(SQLParserIF_P, 0)
}

func (s *DropStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLParserEXISTS, 0)
}

func (s *DropStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLParserVIEW, 0)
}

func (s *DropStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLParserDATABASE, 0)
}

func (s *DropStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLParserSCHEMA, 0)
}

func (s *DropStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLParserINDEX, 0)
}

func (s *DropStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLParserON, 0)
}

func (s *DropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterDropStatement(s)
	}
}

func (s *DropStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitDropStatement(s)
	}
}

func (s *DropStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitDropStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) DropStatement() (localctx IDropStatementContext) {
	localctx = NewDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SQLParserRULE_dropStatement)
	var _la int

	p.SetState(1490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1458)
			p.Match(SQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1459)
			p.Match(SQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserIF_P {
			{
				p.SetState(1460)
				p.Match(SQLParserIF_P)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1461)
				p.Match(SQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1464)
			p.TableName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1465)
			p.Match(SQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1466)
			p.Match(SQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserIF_P {
			{
				p.SetState(1467)
				p.Match(SQLParserIF_P)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1468)
				p.Match(SQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1471)
			p.TableName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1472)
			p.Match(SQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1473)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserDATABASE || _la == SQLParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserIF_P {
			{
				p.SetState(1474)
				p.Match(SQLParserIF_P)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1475)
				p.Match(SQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1478)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1479)
			p.Match(SQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1480)
			p.Match(SQLParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserIF_P {
			{
				p.SetState(1481)
				p.Match(SQLParserIF_P)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1482)
				p.Match(SQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1485)
			p.Identifier()
		}
		p.SetState(1488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserON {
			{
				p.SetState(1486)
				p.Match(SQLParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1487)
				p.TableName()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStatementContext is an interface to support dynamic dispatch.
type IAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AllAlterTableAction() []IAlterTableActionContext
	AlterTableAction(i int) IAlterTableActionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AS() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	Identifier() IIdentifierContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsAlterStatementContext differentiates from other interfaces.
	IsAlterStatementContext()
}

type AlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementContext() *AlterStatementContext {
	var p = new(AlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_alterStatement
	return p
}

func InitEmptyAlterStatementContext(p *AlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_alterStatement
}

func (*AlterStatementContext) IsAlterStatementContext() {}

func NewAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementContext {
	var p = new(AlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_alterStatement

	return p
}

func (s *AlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLParserALTER, 0)
}

func (s *AlterStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLE, 0)
}

func (s *AlterStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterStatementContext) AllAlterTableAction() []IAlterTableActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTableActionContext); ok {
			len++
		}
	}

	tst := make([]IAlterTableActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTableActionContext); ok {
			tst[i] = t.(IAlterTableActionContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementContext) AlterTableAction(i int) IAlterTableActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableActionContext)
}

func (s *AlterStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *AlterStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *AlterStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLParserVIEW, 0)
}

func (s *AlterStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *AlterStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *AlterStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLParserSET, 0)
}

func (s *AlterStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLParserDATABASE, 0)
}

func (s *AlterStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLParserSCHEMA, 0)
}

func (s *AlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterAlterStatement(s)
	}
}

func (s *AlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitAlterStatement(s)
	}
}

func (s *AlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) AlterStatement() (localctx IAlterStatementContext) {
	localctx = NewAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SQLParserRULE_alterStatement)
	var _la int

	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1492)
			p.Match(SQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1493)
			p.Match(SQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1494)
			p.TableName()
		}
		{
			p.SetState(1495)
			p.AlterTableAction()
		}
		p.SetState(1500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1496)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1497)
				p.AlterTableAction()
			}

			p.SetState(1502)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1503)
			p.Match(SQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1504)
			p.Match(SQLParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1505)
			p.TableName()
		}
		{
			p.SetState(1506)
			p.Match(SQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1507)
			p.SelectStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1509)
			p.Match(SQLParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1510)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserDATABASE || _la == SQLParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1511)
			p.Identifier()
		}
		{
			p.SetState(1512)
			p.Match(SQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1513)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableActionContext is an interface to support dynamic dispatch.
type IAlterTableActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	ColumnDefinition() IColumnDefinitionContext
	COLUMN() antlr.TerminalNode
	DROP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	TableName() ITableNameContext
	MODIFY() antlr.TerminalNode
	CHANGE() antlr.TerminalNode
	TableConstraint() ITableConstraintContext
	CONSTRAINT() antlr.TerminalNode
	SET() antlr.TerminalNode
	TBLPROPERTIES() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	PropertyList() IPropertyListContext
	RPAREN() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	LocationClause() ILocationClauseContext

	// IsAlterTableActionContext differentiates from other interfaces.
	IsAlterTableActionContext()
}

type AlterTableActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableActionContext() *AlterTableActionContext {
	var p = new(AlterTableActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_alterTableAction
	return p
}

func InitEmptyAlterTableActionContext(p *AlterTableActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_alterTableAction
}

func (*AlterTableActionContext) IsAlterTableActionContext() {}

func NewAlterTableActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableActionContext {
	var p = new(AlterTableActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_alterTableAction

	return p
}

func (s *AlterTableActionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableActionContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLParserADD, 0)
}

func (s *AlterTableActionContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterTableActionContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLParserCOLUMN, 0)
}

func (s *AlterTableActionContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLParserDROP, 0)
}

func (s *AlterTableActionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableActionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterTableActionContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLParserRENAME, 0)
}

func (s *AlterTableActionContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLParserTO, 0)
}

func (s *AlterTableActionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterTableActionContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SQLParserMODIFY, 0)
}

func (s *AlterTableActionContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SQLParserCHANGE, 0)
}

func (s *AlterTableActionContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *AlterTableActionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLParserCONSTRAINT, 0)
}

func (s *AlterTableActionContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLParserSET, 0)
}

func (s *AlterTableActionContext) TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SQLParserTBLPROPERTIES, 0)
}

func (s *AlterTableActionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *AlterTableActionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterTableActionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *AlterTableActionContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterTableActionContext) LocationClause() ILocationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationClauseContext)
}

func (s *AlterTableActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterAlterTableAction(s)
	}
}

func (s *AlterTableActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitAlterTableAction(s)
	}
}

func (s *AlterTableActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitAlterTableAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) AlterTableAction() (localctx IAlterTableActionContext) {
	localctx = NewAlterTableActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SQLParserRULE_alterTableAction)
	var _la int

	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1517)
			p.Match(SQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1518)
				p.Match(SQLParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1521)
			p.ColumnDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1522)
			p.Match(SQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1524)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1523)
				p.Match(SQLParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1526)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1527)
			p.Match(SQLParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1528)
				p.Match(SQLParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1531)
			p.Identifier()
		}
		{
			p.SetState(1532)
			p.Match(SQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1533)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1535)
			p.Match(SQLParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1536)
			p.Match(SQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1537)
			p.TableName()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1538)
			p.Match(SQLParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1540)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1539)
				p.Match(SQLParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1542)
			p.ColumnDefinition()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1543)
			p.Match(SQLParserCHANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1545)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1544)
				p.Match(SQLParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1547)
			p.Identifier()
		}
		{
			p.SetState(1548)
			p.ColumnDefinition()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1550)
			p.Match(SQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1551)
			p.TableConstraint()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1552)
			p.Match(SQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1553)
			p.Match(SQLParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1554)
			p.Identifier()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1555)
			p.Match(SQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1556)
			p.Match(SQLParserTBLPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1557)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1558)
			p.PropertyList()
		}
		{
			p.SetState(1559)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1561)
			p.Match(SQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1562)
			p.PartitionSpec()
		}
		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserLOCATION {
			{
				p.SetState(1563)
				p.LocationClause()
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1566)
			p.Match(SQLParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1567)
			p.PartitionSpec()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CastExprContext struct {
	ExpressionContext
}

func NewCastExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExprContext {
	var p = new(CastExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CastExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *CastExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCastExpr(s)
	}
}

func (s *CastExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCastExpr(s)
	}
}

func (s *CastExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCastExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractExprContext struct {
	ExpressionContext
}

func NewExtractExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractExprContext {
	var p = new(ExtractExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExtractExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractExprContext) ExtractExpression() IExtractExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtractExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtractExpressionContext)
}

func (s *ExtractExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterExtractExpr(s)
	}
}

func (s *ExtractExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitExtractExpr(s)
	}
}

func (s *ExtractExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitExtractExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeCastExprContext struct {
	ExpressionContext
}

func NewTypeCastExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeCastExprContext {
	var p = new(TypeCastExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *TypeCastExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCastExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeCastExprContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(SQLParserDOUBLE_COLON, 0)
}

func (s *TypeCastExprContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeCastExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTypeCastExpr(s)
	}
}

func (s *TypeCastExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTypeCastExpr(s)
	}
}

func (s *TypeCastExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTypeCastExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsExprContext struct {
	ExpressionContext
}

func NewExistsExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsExprContext {
	var p = new(ExistsExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExistsExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsExprContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLParserEXISTS, 0)
}

func (s *ExistsExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *ExistsExprContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ExistsExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *ExistsExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterExistsExpr(s)
	}
}

func (s *ExistsExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitExistsExpr(s)
	}
}

func (s *ExistsExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitExistsExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseNotExprContext struct {
	ExpressionContext
}

func NewBitwiseNotExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseNotExprContext {
	var p = new(BitwiseNotExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseNotExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseNotExprContext) TILDE() antlr.TerminalNode {
	return s.GetToken(SQLParserTILDE, 0)
}

func (s *BitwiseNotExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseNotExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterBitwiseNotExpr(s)
	}
}

func (s *BitwiseNotExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitBitwiseNotExpr(s)
	}
}

func (s *BitwiseNotExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitBitwiseNotExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenExprContext struct {
	ExpressionContext
}

func NewParenExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenExprContext {
	var p = new(ParenExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ParenExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *ParenExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *ParenExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterParenExpr(s)
	}
}

func (s *ParenExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitParenExpr(s)
	}
}

func (s *ParenExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitParenExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConcatExprContext struct {
	ExpressionContext
}

func NewConcatExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatExprContext {
	var p = new(ConcatExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ConcatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConcatExprContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SQLParserCONCAT, 0)
}

func (s *ConcatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterConcatExpr(s)
	}
}

func (s *ConcatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitConcatExpr(s)
	}
}

func (s *ConcatExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitConcatExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenExprContext struct {
	ExpressionContext
}

func NewBetweenExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenExprContext {
	var p = new(BetweenExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BetweenExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BetweenExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BetweenExprContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLParserBETWEEN, 0)
}

func (s *BetweenExprContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLParserAND, 0)
}

func (s *BetweenExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *BetweenExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterBetweenExpr(s)
	}
}

func (s *BetweenExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitBetweenExpr(s)
	}
}

func (s *BetweenExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitBetweenExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprContext struct {
	ExpressionContext
}

func NewColumnExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprContext {
	var p = new(ColumnExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ColumnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *ColumnExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterColumnExpr(s)
	}
}

func (s *ColumnExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitColumnExpr(s)
	}
}

func (s *ColumnExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitColumnExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type VariableExprContext struct {
	ExpressionContext
}

func NewVariableExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableExprContext {
	var p = new(VariableExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *VariableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableExprContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(SQLParserVARIABLE, 0)
}

func (s *VariableExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterVariableExpr(s)
	}
}

func (s *VariableExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitVariableExpr(s)
	}
}

func (s *VariableExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitVariableExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayAccessExprContext struct {
	ExpressionContext
}

func NewArrayAccessExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayAccessExprContext {
	var p = new(ArrayAccessExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayAccessExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayAccessExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayAccessExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayAccessExprContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(SQLParserLBRACKET, 0)
}

func (s *ArrayAccessExprContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(SQLParserRBRACKET, 0)
}

func (s *ArrayAccessExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterArrayAccessExpr(s)
	}
}

func (s *ArrayAccessExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitArrayAccessExpr(s)
	}
}

func (s *ArrayAccessExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitArrayAccessExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryMinusExprContext struct {
	ExpressionContext
}

func NewUnaryMinusExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryMinusExprContext {
	var p = new(UnaryMinusExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryMinusExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryMinusExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SQLParserMINUS, 0)
}

func (s *UnaryMinusExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryMinusExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterUnaryMinusExpr(s)
	}
}

func (s *UnaryMinusExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitUnaryMinusExpr(s)
	}
}

func (s *UnaryMinusExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitUnaryMinusExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralExprContext struct {
	ExpressionContext
}

func NewLiteralExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExprContext {
	var p = new(LiteralExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LiteralExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterLiteralExpr(s)
	}
}

func (s *LiteralExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitLiteralExpr(s)
	}
}

func (s *LiteralExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitLiteralExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type StructExprContext struct {
	ExpressionContext
}

func NewStructExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructExprContext {
	var p = new(StructExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *StructExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructExprContext) StructConstructor() IStructConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructConstructorContext)
}

func (s *StructExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterStructExpr(s)
	}
}

func (s *StructExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitStructExpr(s)
	}
}

func (s *StructExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitStructExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LikeExprContext struct {
	ExpressionContext
}

func NewLikeExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeExprContext {
	var p = new(LikeExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LikeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LikeExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LikeExprContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLParserLIKE, 0)
}

func (s *LikeExprContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(SQLParserILIKE, 0)
}

func (s *LikeExprContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(SQLParserRLIKE, 0)
}

func (s *LikeExprContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(SQLParserREGEXP, 0)
}

func (s *LikeExprContext) SIMILAR() antlr.TerminalNode {
	return s.GetToken(SQLParserSIMILAR, 0)
}

func (s *LikeExprContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLParserTO, 0)
}

func (s *LikeExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *LikeExprContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SQLParserESCAPE, 0)
}

func (s *LikeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterLikeExpr(s)
	}
}

func (s *LikeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitLikeExpr(s)
	}
}

func (s *LikeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitLikeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarSubqueryExprContext struct {
	ExpressionContext
}

func NewScalarSubqueryExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarSubqueryExprContext {
	var p = new(ScalarSubqueryExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ScalarSubqueryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarSubqueryExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *ScalarSubqueryExprContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ScalarSubqueryExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *ScalarSubqueryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterScalarSubqueryExpr(s)
	}
}

func (s *ScalarSubqueryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitScalarSubqueryExpr(s)
	}
}

func (s *ScalarSubqueryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitScalarSubqueryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type FuncExprContext struct {
	ExpressionContext
}

func NewFuncExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FuncExprContext {
	var p = new(FuncExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *FuncExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncExprContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FuncExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterFuncExpr(s)
	}
}

func (s *FuncExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitFuncExpr(s)
	}
}

func (s *FuncExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitFuncExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddSubExprContext struct {
	ExpressionContext
	op antlr.Token
}

func NewAddSubExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddSubExprContext {
	var p = new(AddSubExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AddSubExprContext) GetOp() antlr.Token { return s.op }

func (s *AddSubExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AddSubExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSubExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AddSubExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AddSubExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SQLParserPLUS, 0)
}

func (s *AddSubExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SQLParserMINUS, 0)
}

func (s *AddSubExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterAddSubExpr(s)
	}
}

func (s *AddSubExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitAddSubExpr(s)
	}
}

func (s *AddSubExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitAddSubExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayExprContext struct {
	ExpressionContext
}

func NewArrayExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayExprContext {
	var p = new(ArrayExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayExprContext) ArrayConstructor() IArrayConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayConstructorContext)
}

func (s *ArrayExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterArrayExpr(s)
	}
}

func (s *ArrayExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitArrayExpr(s)
	}
}

func (s *ArrayExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitArrayExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParameterExprContext struct {
	ExpressionContext
}

func NewParameterExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterExprContext {
	var p = new(ParameterExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ParameterExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterExprContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(SQLParserQUESTION, 0)
}

func (s *ParameterExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterParameterExpr(s)
	}
}

func (s *ParameterExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitParameterExpr(s)
	}
}

func (s *ParameterExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitParameterExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type InExprContext struct {
	ExpressionContext
}

func NewInExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InExprContext {
	var p = new(InExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *InExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InExprContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLParserIN, 0)
}

func (s *InExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *InExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *InExprContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *InExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterInExpr(s)
	}
}

func (s *InExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitInExpr(s)
	}
}

func (s *InExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitInExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberExprContext struct {
	ExpressionContext
}

func NewMemberExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberExprContext {
	var p = new(MemberExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MemberExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MemberExprContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLParserDOT, 0)
}

func (s *MemberExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MemberExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterMemberExpr(s)
	}
}

func (s *MemberExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitMemberExpr(s)
	}
}

func (s *MemberExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitMemberExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuantifiedComparisonExprContext struct {
	ExpressionContext
	op antlr.Token
}

func NewQuantifiedComparisonExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedComparisonExprContext {
	var p = new(QuantifiedComparisonExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *QuantifiedComparisonExprContext) GetOp() antlr.Token { return s.op }

func (s *QuantifiedComparisonExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *QuantifiedComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedComparisonExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QuantifiedComparisonExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *QuantifiedComparisonExprContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *QuantifiedComparisonExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *QuantifiedComparisonExprContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLParserALL, 0)
}

func (s *QuantifiedComparisonExprContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLParserANY, 0)
}

func (s *QuantifiedComparisonExprContext) SOME() antlr.TerminalNode {
	return s.GetToken(SQLParserSOME, 0)
}

func (s *QuantifiedComparisonExprContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLParserEQ, 0)
}

func (s *QuantifiedComparisonExprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SQLParserNEQ, 0)
}

func (s *QuantifiedComparisonExprContext) LT() antlr.TerminalNode {
	return s.GetToken(SQLParserLT, 0)
}

func (s *QuantifiedComparisonExprContext) LTE() antlr.TerminalNode {
	return s.GetToken(SQLParserLTE, 0)
}

func (s *QuantifiedComparisonExprContext) GT() antlr.TerminalNode {
	return s.GetToken(SQLParserGT, 0)
}

func (s *QuantifiedComparisonExprContext) GTE() antlr.TerminalNode {
	return s.GetToken(SQLParserGTE, 0)
}

func (s *QuantifiedComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterQuantifiedComparisonExpr(s)
	}
}

func (s *QuantifiedComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitQuantifiedComparisonExpr(s)
	}
}

func (s *QuantifiedComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitQuantifiedComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type MapExprContext struct {
	ExpressionContext
}

func NewMapExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapExprContext {
	var p = new(MapExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MapExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExprContext) MapConstructor() IMapConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapConstructorContext)
}

func (s *MapExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterMapExpr(s)
	}
}

func (s *MapExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitMapExpr(s)
	}
}

func (s *MapExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitMapExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type OrExprContext struct {
	ExpressionContext
}

func NewOrExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OrExprContext {
	var p = new(OrExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *OrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrExprContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLParserOR, 0)
}

func (s *OrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterOrExpr(s)
	}
}

func (s *OrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitOrExpr(s)
	}
}

func (s *OrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComparisonExprContext struct {
	ExpressionContext
	op antlr.Token
}

func NewComparisonExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ComparisonExprContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ComparisonExprContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLParserEQ, 0)
}

func (s *ComparisonExprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SQLParserNEQ, 0)
}

func (s *ComparisonExprContext) LT() antlr.TerminalNode {
	return s.GetToken(SQLParserLT, 0)
}

func (s *ComparisonExprContext) LTE() antlr.TerminalNode {
	return s.GetToken(SQLParserLTE, 0)
}

func (s *ComparisonExprContext) GT() antlr.TerminalNode {
	return s.GetToken(SQLParserGT, 0)
}

func (s *ComparisonExprContext) GTE() antlr.TerminalNode {
	return s.GetToken(SQLParserGTE, 0)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseExprContext struct {
	ExpressionContext
	op antlr.Token
}

func NewBitwiseExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseExprContext {
	var p = new(BitwiseExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseExprContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(SQLParserAMPERSAND, 0)
}

func (s *BitwiseExprContext) PIPE() antlr.TerminalNode {
	return s.GetToken(SQLParserPIPE, 0)
}

func (s *BitwiseExprContext) CARET() antlr.TerminalNode {
	return s.GetToken(SQLParserCARET, 0)
}

func (s *BitwiseExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterBitwiseExpr(s)
	}
}

func (s *BitwiseExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitBitwiseExpr(s)
	}
}

func (s *BitwiseExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitBitwiseExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExprContext struct {
	ExpressionContext
}

func NewNotExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExprContext {
	var p = new(NotExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NotExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *NotExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterNotExpr(s)
	}
}

func (s *NotExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitNotExpr(s)
	}
}

func (s *NotExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitNotExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsNullExprContext struct {
	ExpressionContext
}

func NewIsNullExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullExprContext {
	var p = new(IsNullExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IsNullExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IsNullExprContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLParserIS, 0)
}

func (s *IsNullExprContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLParserNULL, 0)
}

func (s *IsNullExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *IsNullExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterIsNullExpr(s)
	}
}

func (s *IsNullExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitIsNullExpr(s)
	}
}

func (s *IsNullExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitIsNullExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryPlusExprContext struct {
	ExpressionContext
}

func NewUnaryPlusExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPlusExprContext {
	var p = new(UnaryPlusExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryPlusExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SQLParserPLUS, 0)
}

func (s *UnaryPlusExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryPlusExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterUnaryPlusExpr(s)
	}
}

func (s *UnaryPlusExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitUnaryPlusExpr(s)
	}
}

func (s *UnaryPlusExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitUnaryPlusExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type CaseExprContext struct {
	ExpressionContext
}

func NewCaseExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseExprContext {
	var p = new(CaseExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CaseExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExprContext) CaseExpression() ICaseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *CaseExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCaseExpr(s)
	}
}

func (s *CaseExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCaseExpr(s)
	}
}

func (s *CaseExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCaseExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type SystemVariableExprContext struct {
	ExpressionContext
}

func NewSystemVariableExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableExprContext {
	var p = new(SystemVariableExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *SystemVariableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableExprContext) SYSTEM_VARIABLE() antlr.TerminalNode {
	return s.GetToken(SQLParserSYSTEM_VARIABLE, 0)
}

func (s *SystemVariableExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterSystemVariableExpr(s)
	}
}

func (s *SystemVariableExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitSystemVariableExpr(s)
	}
}

func (s *SystemVariableExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitSystemVariableExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalExprContext struct {
	ExpressionContext
}

func NewIntervalExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalExprContext {
	var p = new(IntervalExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IntervalExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExprContext) IntervalExpression() IIntervalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExpressionContext)
}

func (s *IntervalExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterIntervalExpr(s)
	}
}

func (s *IntervalExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitIntervalExpr(s)
	}
}

func (s *IntervalExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitIntervalExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type MulDivExprContext struct {
	ExpressionContext
	op antlr.Token
}

func NewMulDivExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MulDivExprContext {
	var p = new(MulDivExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MulDivExprContext) GetOp() antlr.Token { return s.op }

func (s *MulDivExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *MulDivExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MulDivExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MulDivExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MulDivExprContext) STAR() antlr.TerminalNode {
	return s.GetToken(SQLParserSTAR, 0)
}

func (s *MulDivExprContext) DIV() antlr.TerminalNode {
	return s.GetToken(SQLParserDIV, 0)
}

func (s *MulDivExprContext) MOD() antlr.TerminalNode {
	return s.GetToken(SQLParserMOD, 0)
}

func (s *MulDivExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterMulDivExpr(s)
	}
}

func (s *MulDivExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitMulDivExpr(s)
	}
}

func (s *MulDivExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitMulDivExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsBooleanExprContext struct {
	ExpressionContext
}

func NewIsBooleanExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsBooleanExprContext {
	var p = new(IsBooleanExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IsBooleanExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsBooleanExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IsBooleanExprContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLParserIS, 0)
}

func (s *IsBooleanExprContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLParserTRUE, 0)
}

func (s *IsBooleanExprContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLParserFALSE, 0)
}

func (s *IsBooleanExprContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SQLParserUNKNOWN, 0)
}

func (s *IsBooleanExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *IsBooleanExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterIsBooleanExpr(s)
	}
}

func (s *IsBooleanExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitIsBooleanExpr(s)
	}
}

func (s *IsBooleanExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitIsBooleanExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type AndExprContext struct {
	ExpressionContext
}

func NewAndExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AndExprContext {
	var p = new(AndExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExprContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AndExprContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLParserAND, 0)
}

func (s *AndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterAndExpr(s)
	}
}

func (s *AndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitAndExpr(s)
	}
}

func (s *AndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *SQLParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, SQLParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1571)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1572)
			p.expression(0)
		}
		{
			p.SetState(1573)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewScalarSubqueryExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1575)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1576)
			p.SelectStatement()
		}
		{
			p.SetState(1577)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewFuncExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1579)
			p.FunctionCall()
		}

	case 4:
		localctx = NewCastExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1580)
			p.CastExpression()
		}

	case 5:
		localctx = NewExtractExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1581)
			p.ExtractExpression()
		}

	case 6:
		localctx = NewIntervalExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1582)
			p.IntervalExpression()
		}

	case 7:
		localctx = NewUnaryMinusExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1583)
			p.Match(SQLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1584)
			p.expression(27)
		}

	case 8:
		localctx = NewUnaryPlusExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1585)
			p.Match(SQLParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1586)
			p.expression(26)
		}

	case 9:
		localctx = NewBitwiseNotExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1587)
			p.Match(SQLParserTILDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1588)
			p.expression(25)
		}

	case 10:
		localctx = NewNotExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1589)
			p.Match(SQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1590)
			p.expression(13)
		}

	case 11:
		localctx = NewExistsExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1591)
			p.Match(SQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1592)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1593)
			p.SelectStatement()
		}
		{
			p.SetState(1594)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewCaseExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1596)
			p.CaseExpression()
		}

	case 13:
		localctx = NewArrayExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1597)
			p.ArrayConstructor()
		}

	case 14:
		localctx = NewMapExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1598)
			p.MapConstructor()
		}

	case 15:
		localctx = NewStructExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1599)
			p.StructConstructor()
		}

	case 16:
		localctx = NewColumnExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1600)
			p.ColumnRef()
		}

	case 17:
		localctx = NewLiteralExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1601)
			p.Literal()
		}

	case 18:
		localctx = NewVariableExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1602)
			p.Match(SQLParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewSystemVariableExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1603)
			p.Match(SQLParserSYSTEM_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewParameterExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1604)
			p.Match(SQLParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1696)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) {
			case 1:
				localctx = NewMulDivExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1607)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(1608)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*MulDivExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-251)) & ^0x3f) == 0 && ((int64(1)<<(_la-251))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*MulDivExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1609)
					p.expression(25)
				}

			case 2:
				localctx = NewAddSubExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1610)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(1611)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AddSubExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SQLParserPLUS || _la == SQLParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AddSubExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1612)
					p.expression(24)
				}

			case 3:
				localctx = NewConcatExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1613)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(1614)
					p.Match(SQLParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1615)
					p.expression(23)
				}

			case 4:
				localctx = NewBitwiseExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1616)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(1617)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitwiseExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-255)) & ^0x3f) == 0 && ((int64(1)<<(_la-255))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitwiseExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1618)
					p.expression(22)
				}

			case 5:
				localctx = NewComparisonExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1619)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(1620)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-243)) & ^0x3f) == 0 && ((int64(1)<<(_la-243))&63) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1621)
					p.expression(21)
				}

			case 6:
				localctx = NewBetweenExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1622)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				p.SetState(1624)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SQLParserNOT {
					{
						p.SetState(1623)
						p.Match(SQLParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1626)
					p.Match(SQLParserBETWEEN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1627)
					p.expression(0)
				}
				{
					p.SetState(1628)
					p.Match(SQLParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1629)
					p.expression(16)
				}

			case 7:
				localctx = NewAndExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1631)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(1632)
					p.Match(SQLParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1633)
					p.expression(13)
				}

			case 8:
				localctx = NewOrExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1634)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(1635)
					p.Match(SQLParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1636)
					p.expression(12)
				}

			case 9:
				localctx = NewArrayAccessExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1637)

				if !(p.Precpred(p.GetParserRuleContext(), 34)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 34)", ""))
					goto errorExit
				}
				{
					p.SetState(1638)
					p.Match(SQLParserLBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1639)
					p.expression(0)
				}
				{
					p.SetState(1640)
					p.Match(SQLParserRBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 10:
				localctx = NewMemberExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1642)

				if !(p.Precpred(p.GetParserRuleContext(), 33)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 33)", ""))
					goto errorExit
				}
				{
					p.SetState(1643)
					p.Match(SQLParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1644)
					p.Identifier()
				}

			case 11:
				localctx = NewTypeCastExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1645)

				if !(p.Precpred(p.GetParserRuleContext(), 28)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 28)", ""))
					goto errorExit
				}
				{
					p.SetState(1646)
					p.Match(SQLParserDOUBLE_COLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1647)
					p.DataType()
				}

			case 12:
				localctx = NewQuantifiedComparisonExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1648)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(1649)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*QuantifiedComparisonExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-243)) & ^0x3f) == 0 && ((int64(1)<<(_la-243))&63) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*QuantifiedComparisonExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1650)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-172)) & ^0x3f) == 0 && ((int64(1)<<(_la-172))&3298534883329) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1651)
					p.Match(SQLParserLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1652)
					p.SelectStatement()
				}
				{
					p.SetState(1653)
					p.Match(SQLParserRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 13:
				localctx = NewIsNullExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1655)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(1656)
					p.Match(SQLParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1658)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SQLParserNOT {
					{
						p.SetState(1657)
						p.Match(SQLParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1660)
					p.Match(SQLParserNULL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 14:
				localctx = NewIsBooleanExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1661)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(1662)
					p.Match(SQLParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1664)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SQLParserNOT {
					{
						p.SetState(1663)
						p.Match(SQLParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1666)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&7) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 15:
				localctx = NewInExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1667)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				p.SetState(1669)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SQLParserNOT {
					{
						p.SetState(1668)
						p.Match(SQLParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1671)
					p.Match(SQLParserIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1672)
					p.Match(SQLParserLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1675)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1673)
						p.SelectStatement()
					}

				case 2:
					{
						p.SetState(1674)
						p.ExpressionList()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(1677)
					p.Match(SQLParserRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 16:
				localctx = NewLikeExprContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLParserRULE_expression)
				p.SetState(1679)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				p.SetState(1681)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SQLParserNOT {
					{
						p.SetState(1680)
						p.Match(SQLParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(1689)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case SQLParserLIKE:
					{
						p.SetState(1683)
						p.Match(SQLParserLIKE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case SQLParserILIKE:
					{
						p.SetState(1684)
						p.Match(SQLParserILIKE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case SQLParserRLIKE:
					{
						p.SetState(1685)
						p.Match(SQLParserRLIKE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case SQLParserREGEXP:
					{
						p.SetState(1686)
						p.Match(SQLParserREGEXP)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case SQLParserSIMILAR:
					{
						p.SetState(1687)
						p.Match(SQLParserSIMILAR)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1688)
						p.Match(SQLParserTO)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(1691)
					p.expression(0)
				}
				p.SetState(1694)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1692)
						p.Match(SQLParserESCAPE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1693)
						p.expression(0)
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	DataType() IDataTypeContext
	RPAREN() antlr.TerminalNode
	CAST() antlr.TerminalNode
	TRY_CAST() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_castExpression
	return p
}

func InitEmptyCastExpressionContext(p *CastExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_castExpression
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *CastExpressionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *CastExpressionContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQLParserCAST, 0)
}

func (s *CastExpressionContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SQLParserTRY_CAST, 0)
}

func (s *CastExpressionContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(SQLParserCONVERT, 0)
}

func (s *CastExpressionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, 0)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CastExpression() (localctx ICastExpressionContext) {
	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SQLParserRULE_castExpression)
	var _la int

	p.SetState(1715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserCAST, SQLParserTRY_CAST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1701)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLParserCAST || _la == SQLParserTRY_CAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1702)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1703)
			p.expression(0)
		}
		{
			p.SetState(1704)
			p.Match(SQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1705)
			p.DataType()
		}
		{
			p.SetState(1706)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserCONVERT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1708)
			p.Match(SQLParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1709)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1710)
			p.expression(0)
		}
		{
			p.SetState(1711)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1712)
			p.DataType()
		}
		{
			p.SetState(1713)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtractExpressionContext is an interface to support dynamic dispatch.
type IExtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTRACT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsExtractExpressionContext differentiates from other interfaces.
	IsExtractExpressionContext()
}

type ExtractExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtractExpressionContext() *ExtractExpressionContext {
	var p = new(ExtractExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_extractExpression
	return p
}

func InitEmptyExtractExpressionContext(p *ExtractExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_extractExpression
}

func (*ExtractExpressionContext) IsExtractExpressionContext() {}

func NewExtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtractExpressionContext {
	var p = new(ExtractExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_extractExpression

	return p
}

func (s *ExtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtractExpressionContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SQLParserEXTRACT, 0)
}

func (s *ExtractExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *ExtractExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractExpressionContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLParserFROM, 0)
}

func (s *ExtractExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExtractExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *ExtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterExtractExpression(s)
	}
}

func (s *ExtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitExtractExpression(s)
	}
}

func (s *ExtractExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitExtractExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ExtractExpression() (localctx IExtractExpressionContext) {
	localctx = NewExtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SQLParserRULE_extractExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		p.Match(SQLParserEXTRACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1718)
		p.Match(SQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1719)
		p.Identifier()
	}
	{
		p.SetState(1720)
		p.Match(SQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1721)
		p.expression(0)
	}
	{
		p.SetState(1722)
		p.Match(SQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalExpressionContext is an interface to support dynamic dispatch.
type IIntervalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode

	// IsIntervalExpressionContext differentiates from other interfaces.
	IsIntervalExpressionContext()
}

type IntervalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalExpressionContext() *IntervalExpressionContext {
	var p = new(IntervalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_intervalExpression
	return p
}

func InitEmptyIntervalExpressionContext(p *IntervalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_intervalExpression
}

func (*IntervalExpressionContext) IsIntervalExpressionContext() {}

func NewIntervalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalExpressionContext {
	var p = new(IntervalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_intervalExpression

	return p
}

func (s *IntervalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalExpressionContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQLParserINTERVAL, 0)
}

func (s *IntervalExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IntervalExpressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *IntervalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterIntervalExpression(s)
	}
}

func (s *IntervalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitIntervalExpression(s)
	}
}

func (s *IntervalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitIntervalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) IntervalExpression() (localctx IIntervalExpressionContext) {
	localctx = NewIntervalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SQLParserRULE_intervalExpression)
	p.SetState(1730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1724)
			p.Match(SQLParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1725)
			p.expression(0)
		}
		{
			p.SetState(1726)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1728)
			p.Match(SQLParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1729)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	END() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllWHEN() []antlr.TerminalNode
	WHEN(i int) antlr.TerminalNode
	AllTHEN() []antlr.TerminalNode
	THEN(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_caseExpression
	return p
}

func InitEmptyCaseExpressionContext(p *CaseExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_caseExpression
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(SQLParserCASE, 0)
}

func (s *CaseExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(SQLParserEND, 0)
}

func (s *CaseExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserWHEN)
}

func (s *CaseExpressionContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserWHEN, i)
}

func (s *CaseExpressionContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserTHEN)
}

func (s *CaseExpressionContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserTHEN, i)
}

func (s *CaseExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLParserELSE, 0)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (s *CaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitCaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) CaseExpression() (localctx ICaseExpressionContext) {
	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SQLParserRULE_caseExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1732)
		p.Match(SQLParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1734)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1733)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SQLParserWHEN {
		{
			p.SetState(1736)
			p.Match(SQLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1737)
			p.expression(0)
		}
		{
			p.SetState(1738)
			p.Match(SQLParserTHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1739)
			p.expression(0)
		}

		p.SetState(1743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SQLParserELSE {
		{
			p.SetState(1745)
			p.Match(SQLParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)
			p.expression(0)
		}

	}
	{
		p.SetState(1749)
		p.Match(SQLParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayConstructorContext is an interface to support dynamic dispatch.
type IArrayConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	LPAREN() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	RPAREN() antlr.TerminalNode

	// IsArrayConstructorContext differentiates from other interfaces.
	IsArrayConstructorContext()
}

type ArrayConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayConstructorContext() *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_arrayConstructor
	return p
}

func InitEmptyArrayConstructorContext(p *ArrayConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_arrayConstructor
}

func (*ArrayConstructorContext) IsArrayConstructorContext() {}

func NewArrayConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_arrayConstructor

	return p
}

func (s *ArrayConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLParserARRAY, 0)
}

func (s *ArrayConstructorContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(SQLParserLBRACKET, 0)
}

func (s *ArrayConstructorContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(SQLParserRBRACKET, 0)
}

func (s *ArrayConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayConstructorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *ArrayConstructorContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ArrayConstructorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitArrayConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ArrayConstructor() (localctx IArrayConstructorContext) {
	localctx = NewArrayConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SQLParserRULE_arrayConstructor)
	var _la int

	p.SetState(1762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1751)
			p.Match(SQLParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1752)
			p.Match(SQLParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&575053377419476990) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-8070454380539068449) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-35184372088865) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&108649341010313215) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&268304513) != 0) {
			{
				p.SetState(1753)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1756)
			p.Match(SQLParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1757)
			p.Match(SQLParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1758)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1759)
			p.SelectStatement()
		}
		{
			p.SetState(1760)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapConstructorContext is an interface to support dynamic dispatch.
type IMapConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAP() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapConstructorContext differentiates from other interfaces.
	IsMapConstructorContext()
}

type MapConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapConstructorContext() *MapConstructorContext {
	var p = new(MapConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mapConstructor
	return p
}

func InitEmptyMapConstructorContext(p *MapConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_mapConstructor
}

func (*MapConstructorContext) IsMapConstructorContext() {}

func NewMapConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapConstructorContext {
	var p = new(MapConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_mapConstructor

	return p
}

func (s *MapConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(SQLParserMAP, 0)
}

func (s *MapConstructorContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(SQLParserLBRACKET, 0)
}

func (s *MapConstructorContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(SQLParserRBRACKET, 0)
}

func (s *MapConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapConstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *MapConstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

func (s *MapConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitMapConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) MapConstructor() (localctx IMapConstructorContext) {
	localctx = NewMapConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SQLParserRULE_mapConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.Match(SQLParserMAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1765)
		p.Match(SQLParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&575053377419476990) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-8070454380539068449) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-35184372088865) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&108649341010313215) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&268304513) != 0) {
		{
			p.SetState(1766)
			p.expression(0)
		}
		{
			p.SetState(1767)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1768)
			p.expression(0)
		}
		p.SetState(1776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SQLParserCOMMA {
			{
				p.SetState(1769)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1770)
				p.expression(0)
			}
			{
				p.SetState(1771)
				p.Match(SQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1772)
				p.expression(0)
			}

			p.SetState(1778)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1781)
		p.Match(SQLParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructConstructorContext is an interface to support dynamic dispatch.
type IStructConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RPAREN() antlr.TerminalNode
	NAMED_STRUCT() antlr.TerminalNode
	ROW() antlr.TerminalNode

	// IsStructConstructorContext differentiates from other interfaces.
	IsStructConstructorContext()
}

type StructConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructConstructorContext() *StructConstructorContext {
	var p = new(StructConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_structConstructor
	return p
}

func InitEmptyStructConstructorContext(p *StructConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_structConstructor
}

func (*StructConstructorContext) IsStructConstructorContext() {}

func NewStructConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructConstructorContext {
	var p = new(StructConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_structConstructor

	return p
}

func (s *StructConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *StructConstructorContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRUCT, 0)
}

func (s *StructConstructorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *StructConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *StructConstructorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *StructConstructorContext) NAMED_STRUCT() antlr.TerminalNode {
	return s.GetToken(SQLParserNAMED_STRUCT, 0)
}

func (s *StructConstructorContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLParserROW, 0)
}

func (s *StructConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterStructConstructor(s)
	}
}

func (s *StructConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitStructConstructor(s)
	}
}

func (s *StructConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitStructConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) StructConstructor() (localctx IStructConstructorContext) {
	localctx = NewStructConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SQLParserRULE_structConstructor)
	p.SetState(1798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserSTRUCT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1783)
			p.Match(SQLParserSTRUCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1784)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1785)
			p.ExpressionList()
		}
		{
			p.SetState(1786)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserNAMED_STRUCT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1788)
			p.Match(SQLParserNAMED_STRUCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1789)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1790)
			p.ExpressionList()
		}
		{
			p.SetState(1791)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserROW:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1793)
			p.Match(SQLParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1794)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1795)
			p.ExpressionList()
		}
		{
			p.SetState(1796)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionName() IFunctionNameContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	ExpressionList() IExpressionListContext
	STAR() antlr.TerminalNode
	OverClause() IOverClauseContext
	DISTINCT() antlr.TerminalNode
	WITHIN() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	OrderByClause() IOrderByClauseContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionCallContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserLPAREN)
}

func (s *FunctionCallContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, i)
}

func (s *FunctionCallContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(SQLParserRPAREN)
}

func (s *FunctionCallContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, i)
}

func (s *FunctionCallContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *FunctionCallContext) STAR() antlr.TerminalNode {
	return s.GetToken(SQLParserSTAR, 0)
}

func (s *FunctionCallContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *FunctionCallContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLParserDISTINCT, 0)
}

func (s *FunctionCallContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(SQLParserWITHIN, 0)
}

func (s *FunctionCallContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLParserGROUP, 0)
}

func (s *FunctionCallContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SQLParserRULE_functionCall)
	p.SetState(1823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 239, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1800)
			p.FunctionName()
		}
		{
			p.SetState(1801)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case SQLParserSELECT, SQLParserFROM, SQLParserWHERE, SQLParserAND, SQLParserOR, SQLParserNOT, SQLParserAS, SQLParserON, SQLParserJOIN, SQLParserINNER, SQLParserLEFT, SQLParserRIGHT, SQLParserOUTER, SQLParserCROSS, SQLParserFULL, SQLParserNATURAL, SQLParserINSERT, SQLParserINTO, SQLParserVALUES, SQLParserUPDATE, SQLParserSET, SQLParserDELETE, SQLParserTRUNCATE, SQLParserCREATE, SQLParserTABLE, SQLParserVIEW, SQLParserDATABASE, SQLParserSCHEMA, SQLParserDROP, SQLParserALTER, SQLParserINDEX, SQLParserADD, SQLParserCOLUMN, SQLParserRENAME, SQLParserTO, SQLParserMODIFY, SQLParserCHANGE, SQLParserCONSTRAINT, SQLParserPRIMARY, SQLParserKEY, SQLParserFOREIGN, SQLParserREFERENCES, SQLParserUNIQUE, SQLParserCHECK, SQLParserDEFAULT, SQLParserCOMMENT, SQLParserTEMPORARY, SQLParserTEMP, SQLParserEXTERNAL, SQLParserLOCATION, SQLParserSTORED, SQLParserFORMAT, SQLParserTBLPROPERTIES, SQLParserROW_FORMAT, SQLParserSERDE, SQLParserSERDEPROPERTIES, SQLParserCLUSTERED, SQLParserSORTED, SQLParserBUCKETS, SQLParserPARTITIONED, SQLParserWATERMARK, SQLParserFOR, SQLParserSYSTEM_TIME, SQLParserSYSTEM, SQLParserENFORCED, SQLParserMETADATA, SQLParserVIRTUAL, SQLParserWITHOUT, SQLParserGENERATED, SQLParserALWAYS, SQLParserIDENTITY, SQLParserSTART, SQLParserINCREMENT, SQLParserMINVALUE, SQLParserMAXVALUE, SQLParserCYCLE, SQLParserCACHE, SQLParserMERGE, SQLParserUSING, SQLParserMATCHED, SQLParserUPSERT, SQLParserOVERWRITE, SQLParserREPLACE, SQLParserIGNORE, SQLParserDUPLICATE, SQLParserLATERAL, SQLParserUNNEST, SQLParserEXPLODE, SQLParserTABLESAMPLE, SQLParserPERCENT, SQLParserBUCKET, SQLParserOUT, SQLParserOF, SQLParserDISTRIBUTED, SQLParserHASH, SQLParserRANDOM, SQLParserBROADCAST, SQLParserREPLICATED, SQLParserPROPERTIES, SQLParserENGINE, SQLParserCHARSET, SQLParserCHARACTER, SQLParserCOLLATE, SQLParserTABLESPACE, SQLParserINHERITS, SQLParserFILEGROUP, SQLParserGLOBAL, SQLParserLOCAL, SQLParserUNLOGGED, SQLParserTTL, SQLParserLIFECYCLE, SQLParserAUTO, SQLParserRESTRICT, SQLParserCASCADE, SQLParserACTION, SQLParserOVER, SQLParserPARTITION, SQLParserROWS, SQLParserRANGE, SQLParserGROUPS, SQLParserUNBOUNDED, SQLParserPRECEDING, SQLParserFOLLOWING, SQLParserCURRENT, SQLParserROW, SQLParserFIRST, SQLParserLAST, SQLParserNULLS, SQLParserEXCLUDE, SQLParserTIES, SQLParserNO, SQLParserOTHERS, SQLParserGROUP, SQLParserBY, SQLParserORDER, SQLParserASC, SQLParserDESC, SQLParserHAVING, SQLParserLIMIT, SQLParserOFFSET, SQLParserFETCH, SQLParserNEXT, SQLParserONLY, SQLParserTOP, SQLParserUNION, SQLParserINTERSECT, SQLParserEXCEPT, SQLParserMINUS_SET, SQLParserALL, SQLParserDISTINCT, SQLParserWITH, SQLParserRECURSIVE, SQLParserCASE, SQLParserWHEN, SQLParserTHEN, SQLParserELSE, SQLParserEND, SQLParserNULL, SQLParserIS, SQLParserIN, SQLParserBETWEEN, SQLParserLIKE, SQLParserILIKE, SQLParserRLIKE, SQLParserREGEXP, SQLParserSIMILAR, SQLParserESCAPE, SQLParserEXISTS, SQLParserTRUE, SQLParserFALSE, SQLParserUNKNOWN, SQLParserCAST, SQLParserCONVERT, SQLParserTRY_CAST, SQLParserEXTRACT, SQLParserINTERVAL, SQLParserAT, SQLParserZONE, SQLParserTIME, SQLParserTIMESTAMP, SQLParserDATE, SQLParserYEAR, SQLParserMONTH, SQLParserDAY, SQLParserHOUR, SQLParserMINUTE, SQLParserSECOND, SQLParserSOME, SQLParserANY, SQLParserARRAY, SQLParserMAP, SQLParserSTRUCT, SQLParserNAMED_STRUCT, SQLParserINT, SQLParserINTEGER, SQLParserTINYINT, SQLParserSMALLINT, SQLParserBIGINT, SQLParserFLOAT, SQLParserDOUBLE, SQLParserDECIMAL, SQLParserNUMERIC, SQLParserREAL, SQLParserBOOLEAN, SQLParserBOOL, SQLParserSTRING, SQLParserVARCHAR, SQLParserCHAR, SQLParserTEXT, SQLParserBINARY, SQLParserVARBINARY, SQLParserBLOB, SQLParserCLOB, SQLParserJSON, SQLParserXML, SQLParserBYTES, SQLParserMULTISET, SQLParserRAW, SQLParserPLUS, SQLParserMINUS, SQLParserTILDE, SQLParserLPAREN, SQLParserQUESTION, SQLParserSTRING_LITERAL, SQLParserDOUBLE_QUOTED_STRING, SQLParserNUMBER, SQLParserHEX_NUMBER, SQLParserBIT_STRING, SQLParserIDENTIFIER, SQLParserBACKTICK_IDENTIFIER, SQLParserBRACKET_IDENTIFIER, SQLParserVARIABLE, SQLParserSYSTEM_VARIABLE:
			p.SetState(1803)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1802)
					p.Match(SQLParserDISTINCT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1805)
				p.ExpressionList()
			}

		case SQLParserSTAR:
			{
				p.SetState(1806)
				p.Match(SQLParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SQLParserRPAREN:

		default:
		}
		{
			p.SetState(1809)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1811)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1810)
				p.OverClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1813)
			p.FunctionName()
		}
		{
			p.SetState(1814)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1815)
			p.ExpressionList()
		}
		{
			p.SetState(1816)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1817)
			p.Match(SQLParserWITHIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1818)
			p.Match(SQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1819)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1820)
			p.OrderByClause()
		}
		{
			p.SetState(1821)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverClauseContext is an interface to support dynamic dispatch.
type IOverClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	PartitionByClause() IPartitionByClauseContext
	OrderByClause() IOrderByClauseContext
	WindowFrame() IWindowFrameContext
	Identifier() IIdentifierContext

	// IsOverClauseContext differentiates from other interfaces.
	IsOverClauseContext()
}

type OverClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverClauseContext() *OverClauseContext {
	var p = new(OverClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_overClause
	return p
}

func InitEmptyOverClauseContext(p *OverClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_overClause
}

func (*OverClauseContext) IsOverClauseContext() {}

func NewOverClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverClauseContext {
	var p = new(OverClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_overClause

	return p
}

func (s *OverClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OverClauseContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLParserOVER, 0)
}

func (s *OverClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserLPAREN, 0)
}

func (s *OverClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(SQLParserRPAREN, 0)
}

func (s *OverClauseContext) PartitionByClause() IPartitionByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionByClauseContext)
}

func (s *OverClauseContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *OverClauseContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterOverClause(s)
	}
}

func (s *OverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitOverClause(s)
	}
}

func (s *OverClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitOverClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) OverClause() (localctx IOverClauseContext) {
	localctx = NewOverClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SQLParserRULE_overClause)
	var _la int

	p.SetState(1839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1825)
			p.Match(SQLParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1826)
			p.Match(SQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserPARTITION {
			{
				p.SetState(1827)
				p.PartitionByClause()
			}

		}
		p.SetState(1831)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SQLParserORDER {
			{
				p.SetState(1830)
				p.OrderByClause()
			}

		}
		p.SetState(1834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&7) != 0 {
			{
				p.SetState(1833)
				p.WindowFrame()
			}

		}
		{
			p.SetState(1836)
			p.Match(SQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1837)
			p.Match(SQLParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1838)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionByClauseContext is an interface to support dynamic dispatch.
type IPartitionByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsPartitionByClauseContext differentiates from other interfaces.
	IsPartitionByClauseContext()
}

type PartitionByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByClauseContext() *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_partitionByClause
	return p
}

func InitEmptyPartitionByClauseContext(p *PartitionByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_partitionByClause
}

func (*PartitionByClauseContext) IsPartitionByClauseContext() {}

func NewPartitionByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_partitionByClause

	return p
}

func (s *PartitionByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLParserPARTITION, 0)
}

func (s *PartitionByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *PartitionByClauseContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *PartitionByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitPartitionByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) PartitionByClause() (localctx IPartitionByClauseContext) {
	localctx = NewPartitionByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SQLParserRULE_partitionByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1841)
		p.Match(SQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1842)
		p.Match(SQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1843)
		p.ExpressionList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWindowFrameBound() []IWindowFrameBoundContext
	WindowFrameBound(i int) IWindowFrameBoundContext
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) AllWindowFrameBound() []IWindowFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IWindowFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowFrameBoundContext); ok {
			tst[i] = t.(IWindowFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) WindowFrameBound(i int) IWindowFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLParserROWS, 0)
}

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLParserRANGE, 0)
}

func (s *WindowFrameContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(SQLParserGROUPS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (s *WindowFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitWindowFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SQLParserRULE_windowFrame)
	var _la int

	p.SetState(1853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1845)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1846)
			p.WindowFrameBound()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1847)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1848)
			p.Match(SQLParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1849)
			p.WindowFrameBound()
		}
		{
			p.SetState(1850)
			p.Match(SQLParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1851)
			p.WindowFrameBound()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameBoundContext is an interface to support dynamic dispatch.
type IWindowFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWindowFrameBoundContext differentiates from other interfaces.
	IsWindowFrameBoundContext()
}

type WindowFrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameBoundContext() *WindowFrameBoundContext {
	var p = new(WindowFrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_windowFrameBound
	return p
}

func InitEmptyWindowFrameBoundContext(p *WindowFrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_windowFrameBound
}

func (*WindowFrameBoundContext) IsWindowFrameBoundContext() {}

func NewWindowFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameBoundContext {
	var p = new(WindowFrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_windowFrameBound

	return p
}

func (s *WindowFrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameBoundContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SQLParserUNBOUNDED, 0)
}

func (s *WindowFrameBoundContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLParserPRECEDING, 0)
}

func (s *WindowFrameBoundContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLParserFOLLOWING, 0)
}

func (s *WindowFrameBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLParserCURRENT, 0)
}

func (s *WindowFrameBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLParserROW, 0)
}

func (s *WindowFrameBoundContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WindowFrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterWindowFrameBound(s)
	}
}

func (s *WindowFrameBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitWindowFrameBound(s)
	}
}

func (s *WindowFrameBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitWindowFrameBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) WindowFrameBound() (localctx IWindowFrameBoundContext) {
	localctx = NewWindowFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SQLParserRULE_windowFrameBound)
	p.SetState(1867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1855)
			p.Match(SQLParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1856)
			p.Match(SQLParserPRECEDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1857)
			p.Match(SQLParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1858)
			p.Match(SQLParserFOLLOWING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1859)
			p.Match(SQLParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1860)
			p.Match(SQLParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1861)
			p.expression(0)
		}
		{
			p.SetState(1862)
			p.Match(SQLParserPRECEDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1864)
			p.expression(0)
		}
		{
			p.SetState(1865)
			p.Match(SQLParserFOLLOWING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnRefContext is an interface to support dynamic dispatch.
type IColumnRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnName() IColumnNameContext
	TableName() ITableNameContext
	DOT() antlr.TerminalNode

	// IsColumnRefContext differentiates from other interfaces.
	IsColumnRefContext()
}

type ColumnRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnRefContext() *ColumnRefContext {
	var p = new(ColumnRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnRef
	return p
}

func InitEmptyColumnRefContext(p *ColumnRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnRef
}

func (*ColumnRefContext) IsColumnRefContext() {}

func NewColumnRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRefContext {
	var p = new(ColumnRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_columnRef

	return p
}

func (s *ColumnRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRefContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnRefContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ColumnRefContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLParserDOT, 0)
}

func (s *ColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterColumnRef(s)
	}
}

func (s *ColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitColumnRef(s)
	}
}

func (s *ColumnRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitColumnRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ColumnRef() (localctx IColumnRefContext) {
	localctx = NewColumnRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SQLParserRULE_columnRef)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1872)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1869)
			p.TableName()
		}
		{
			p.SetState(1870)
			p.Match(SQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1874)
		p.ColumnName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SQLParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SQLParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1876)
		p.expression(0)
	}
	p.SetState(1881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SQLParserCOMMA {
		{
			p.SetState(1877)
			p.Match(SQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1878)
			p.expression(0)
		}

		p.SetState(1883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DatabaseName() IDatabaseNameContext
	DOT() antlr.TerminalNode

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableNameContext) DatabaseName() IDatabaseNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseNameContext)
}

func (s *TableNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(SQLParserDOT, 0)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SQLParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1887)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 248, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1884)
			p.DatabaseName()
		}
		{
			p.SetState(1885)
			p.Match(SQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1889)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabaseNameContext is an interface to support dynamic dispatch.
type IDatabaseNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDatabaseNameContext differentiates from other interfaces.
	IsDatabaseNameContext()
}

type DatabaseNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseNameContext() *DatabaseNameContext {
	var p = new(DatabaseNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_databaseName
	return p
}

func InitEmptyDatabaseNameContext(p *DatabaseNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_databaseName
}

func (*DatabaseNameContext) IsDatabaseNameContext() {}

func NewDatabaseNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseNameContext {
	var p = new(DatabaseNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_databaseName

	return p
}

func (s *DatabaseNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatabaseNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterDatabaseName(s)
	}
}

func (s *DatabaseNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitDatabaseName(s)
	}
}

func (s *DatabaseNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitDatabaseName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) DatabaseName() (localctx IDatabaseNameContext) {
	localctx = NewDatabaseNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SQLParserRULE_databaseName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1891)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameContext is an interface to support dynamic dispatch.
type IColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsColumnNameContext differentiates from other interfaces.
	IsColumnNameContext()
}

type ColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameContext() *ColumnNameContext {
	var p = new(ColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnName
	return p
}

func InitEmptyColumnNameContext(p *ColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_columnName
}

func (*ColumnNameContext) IsColumnNameContext() {}

func NewColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameContext {
	var p = new(ColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_columnName

	return p
}

func (s *ColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterColumnName(s)
	}
}

func (s *ColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitColumnName(s)
	}
}

func (s *ColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) ColumnName() (localctx IColumnNameContext) {
	localctx = NewColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SQLParserRULE_columnName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1893)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_functionName
	return p
}

func InitEmptyFunctionNameContext(p *FunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_functionName
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SQLParserRULE_functionName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1895)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_alias
	return p
}

func InitEmptyAliasContext(p *AliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_alias
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (s *AliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SQLParserRULE_alias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1897)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	BACKTICK_IDENTIFIER() antlr.TerminalNode
	BRACKET_IDENTIFIER() antlr.TerminalNode
	DOUBLE_QUOTED_STRING() antlr.TerminalNode
	NonReservedKeyword() INonReservedKeywordContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLParserIDENTIFIER, 0)
}

func (s *IdentifierContext) BACKTICK_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLParserBACKTICK_IDENTIFIER, 0)
}

func (s *IdentifierContext) BRACKET_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLParserBRACKET_IDENTIFIER, 0)
}

func (s *IdentifierContext) DOUBLE_QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(SQLParserDOUBLE_QUOTED_STRING, 0)
}

func (s *IdentifierContext) NonReservedKeyword() INonReservedKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedKeywordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SQLParserRULE_identifier)
	p.SetState(1904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1899)
			p.Match(SQLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserBACKTICK_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1900)
			p.Match(SQLParserBACKTICK_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserBRACKET_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1901)
			p.Match(SQLParserBRACKET_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserDOUBLE_QUOTED_STRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1902)
			p.Match(SQLParserDOUBLE_QUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserSELECT, SQLParserFROM, SQLParserWHERE, SQLParserAND, SQLParserOR, SQLParserNOT, SQLParserAS, SQLParserON, SQLParserJOIN, SQLParserINNER, SQLParserLEFT, SQLParserRIGHT, SQLParserOUTER, SQLParserCROSS, SQLParserFULL, SQLParserNATURAL, SQLParserINSERT, SQLParserINTO, SQLParserVALUES, SQLParserUPDATE, SQLParserSET, SQLParserDELETE, SQLParserTRUNCATE, SQLParserCREATE, SQLParserTABLE, SQLParserVIEW, SQLParserDATABASE, SQLParserSCHEMA, SQLParserDROP, SQLParserALTER, SQLParserINDEX, SQLParserADD, SQLParserCOLUMN, SQLParserRENAME, SQLParserTO, SQLParserMODIFY, SQLParserCHANGE, SQLParserCONSTRAINT, SQLParserPRIMARY, SQLParserKEY, SQLParserFOREIGN, SQLParserREFERENCES, SQLParserUNIQUE, SQLParserCHECK, SQLParserDEFAULT, SQLParserCOMMENT, SQLParserTEMPORARY, SQLParserTEMP, SQLParserEXTERNAL, SQLParserLOCATION, SQLParserSTORED, SQLParserFORMAT, SQLParserTBLPROPERTIES, SQLParserROW_FORMAT, SQLParserSERDE, SQLParserSERDEPROPERTIES, SQLParserCLUSTERED, SQLParserSORTED, SQLParserBUCKETS, SQLParserPARTITIONED, SQLParserWATERMARK, SQLParserFOR, SQLParserSYSTEM_TIME, SQLParserSYSTEM, SQLParserENFORCED, SQLParserMETADATA, SQLParserVIRTUAL, SQLParserWITHOUT, SQLParserGENERATED, SQLParserALWAYS, SQLParserIDENTITY, SQLParserSTART, SQLParserINCREMENT, SQLParserMINVALUE, SQLParserMAXVALUE, SQLParserCYCLE, SQLParserCACHE, SQLParserMERGE, SQLParserUSING, SQLParserMATCHED, SQLParserUPSERT, SQLParserOVERWRITE, SQLParserREPLACE, SQLParserIGNORE, SQLParserDUPLICATE, SQLParserLATERAL, SQLParserUNNEST, SQLParserEXPLODE, SQLParserTABLESAMPLE, SQLParserPERCENT, SQLParserBUCKET, SQLParserOUT, SQLParserOF, SQLParserDISTRIBUTED, SQLParserHASH, SQLParserRANDOM, SQLParserBROADCAST, SQLParserREPLICATED, SQLParserPROPERTIES, SQLParserENGINE, SQLParserCHARSET, SQLParserCHARACTER, SQLParserCOLLATE, SQLParserTABLESPACE, SQLParserINHERITS, SQLParserFILEGROUP, SQLParserGLOBAL, SQLParserLOCAL, SQLParserUNLOGGED, SQLParserTTL, SQLParserLIFECYCLE, SQLParserAUTO, SQLParserRESTRICT, SQLParserCASCADE, SQLParserACTION, SQLParserOVER, SQLParserPARTITION, SQLParserROWS, SQLParserRANGE, SQLParserGROUPS, SQLParserUNBOUNDED, SQLParserPRECEDING, SQLParserFOLLOWING, SQLParserCURRENT, SQLParserROW, SQLParserFIRST, SQLParserLAST, SQLParserNULLS, SQLParserEXCLUDE, SQLParserTIES, SQLParserNO, SQLParserOTHERS, SQLParserGROUP, SQLParserBY, SQLParserORDER, SQLParserASC, SQLParserDESC, SQLParserHAVING, SQLParserLIMIT, SQLParserOFFSET, SQLParserFETCH, SQLParserNEXT, SQLParserONLY, SQLParserTOP, SQLParserUNION, SQLParserINTERSECT, SQLParserEXCEPT, SQLParserMINUS_SET, SQLParserALL, SQLParserDISTINCT, SQLParserWITH, SQLParserRECURSIVE, SQLParserCASE, SQLParserWHEN, SQLParserTHEN, SQLParserELSE, SQLParserEND, SQLParserNULL, SQLParserIS, SQLParserIN, SQLParserBETWEEN, SQLParserLIKE, SQLParserILIKE, SQLParserRLIKE, SQLParserREGEXP, SQLParserSIMILAR, SQLParserESCAPE, SQLParserEXISTS, SQLParserTRUE, SQLParserFALSE, SQLParserUNKNOWN, SQLParserCAST, SQLParserCONVERT, SQLParserTRY_CAST, SQLParserEXTRACT, SQLParserINTERVAL, SQLParserAT, SQLParserZONE, SQLParserTIME, SQLParserTIMESTAMP, SQLParserDATE, SQLParserYEAR, SQLParserMONTH, SQLParserDAY, SQLParserHOUR, SQLParserMINUTE, SQLParserSECOND, SQLParserSOME, SQLParserANY, SQLParserARRAY, SQLParserMAP, SQLParserSTRUCT, SQLParserNAMED_STRUCT, SQLParserINT, SQLParserINTEGER, SQLParserTINYINT, SQLParserSMALLINT, SQLParserBIGINT, SQLParserFLOAT, SQLParserDOUBLE, SQLParserDECIMAL, SQLParserNUMERIC, SQLParserREAL, SQLParserBOOLEAN, SQLParserBOOL, SQLParserSTRING, SQLParserVARCHAR, SQLParserCHAR, SQLParserTEXT, SQLParserBINARY, SQLParserVARBINARY, SQLParserBLOB, SQLParserCLOB, SQLParserJSON, SQLParserXML, SQLParserBYTES, SQLParserMULTISET, SQLParserRAW:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1903)
			p.NonReservedKeyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedKeywordContext is an interface to support dynamic dispatch.
type INonReservedKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AS() antlr.TerminalNode
	ON() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	SET() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	DROP() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	CHANGE() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	FETCH() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	TOP() antlr.TerminalNode
	UNION() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	MINUS_SET() antlr.TerminalNode
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	CASE() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	END() antlr.TerminalNode
	NULL() antlr.TerminalNode
	IS() antlr.TerminalNode
	IN() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	SIMILAR() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	WITH() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	USING() antlr.TerminalNode
	MATCHED() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	UNNEST() antlr.TerminalNode
	EXPLODE() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	BUCKET() antlr.TerminalNode
	OUT() antlr.TerminalNode
	OF() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	TRY_CAST() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	AT() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	DATE() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SOME() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	MAP() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	NAMED_STRUCT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	REAL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	CLOB() antlr.TerminalNode
	JSON() antlr.TerminalNode
	XML() antlr.TerminalNode
	BYTES() antlr.TerminalNode
	RAW() antlr.TerminalNode
	MULTISET() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMP() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	STORED() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TBLPROPERTIES() antlr.TerminalNode
	PARTITIONED() antlr.TerminalNode
	CLUSTERED() antlr.TerminalNode
	SORTED() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	SERDE() antlr.TerminalNode
	SERDEPROPERTIES() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	TIES() antlr.TerminalNode
	NO() antlr.TerminalNode
	OTHERS() antlr.TerminalNode
	WATERMARK() antlr.TerminalNode
	FOR() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode
	METADATA() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	IDENTITY() antlr.TerminalNode
	START() antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	MINVALUE() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	CYCLE() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	HASH() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	BROADCAST() antlr.TerminalNode
	REPLICATED() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	INHERITS() antlr.TerminalNode
	FILEGROUP() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	UNLOGGED() antlr.TerminalNode
	TTL() antlr.TerminalNode
	LIFECYCLE() antlr.TerminalNode
	AUTO() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	ACTION() antlr.TerminalNode

	// IsNonReservedKeywordContext differentiates from other interfaces.
	IsNonReservedKeywordContext()
}

type NonReservedKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedKeywordContext() *NonReservedKeywordContext {
	var p = new(NonReservedKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_nonReservedKeyword
	return p
}

func InitEmptyNonReservedKeywordContext(p *NonReservedKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_nonReservedKeyword
}

func (*NonReservedKeywordContext) IsNonReservedKeywordContext() {}

func NewNonReservedKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedKeywordContext {
	var p = new(NonReservedKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_nonReservedKeyword

	return p
}

func (s *NonReservedKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedKeywordContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLParserSELECT, 0)
}

func (s *NonReservedKeywordContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLParserFROM, 0)
}

func (s *NonReservedKeywordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLParserWHERE, 0)
}

func (s *NonReservedKeywordContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLParserAND, 0)
}

func (s *NonReservedKeywordContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLParserOR, 0)
}

func (s *NonReservedKeywordContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLParserNOT, 0)
}

func (s *NonReservedKeywordContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLParserAS, 0)
}

func (s *NonReservedKeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLParserON, 0)
}

func (s *NonReservedKeywordContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SQLParserJOIN, 0)
}

func (s *NonReservedKeywordContext) INNER() antlr.TerminalNode {
	return s.GetToken(SQLParserINNER, 0)
}

func (s *NonReservedKeywordContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SQLParserLEFT, 0)
}

func (s *NonReservedKeywordContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SQLParserRIGHT, 0)
}

func (s *NonReservedKeywordContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SQLParserOUTER, 0)
}

func (s *NonReservedKeywordContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SQLParserCROSS, 0)
}

func (s *NonReservedKeywordContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLParserFULL, 0)
}

func (s *NonReservedKeywordContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SQLParserNATURAL, 0)
}

func (s *NonReservedKeywordContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLParserINSERT, 0)
}

func (s *NonReservedKeywordContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLParserINTO, 0)
}

func (s *NonReservedKeywordContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLParserVALUES, 0)
}

func (s *NonReservedKeywordContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLParserUPDATE, 0)
}

func (s *NonReservedKeywordContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLParserSET, 0)
}

func (s *NonReservedKeywordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLParserDELETE, 0)
}

func (s *NonReservedKeywordContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(SQLParserTRUNCATE, 0)
}

func (s *NonReservedKeywordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLParserCREATE, 0)
}

func (s *NonReservedKeywordContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLE, 0)
}

func (s *NonReservedKeywordContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLParserVIEW, 0)
}

func (s *NonReservedKeywordContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLParserDATABASE, 0)
}

func (s *NonReservedKeywordContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLParserSCHEMA, 0)
}

func (s *NonReservedKeywordContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLParserDROP, 0)
}

func (s *NonReservedKeywordContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLParserALTER, 0)
}

func (s *NonReservedKeywordContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLParserINDEX, 0)
}

func (s *NonReservedKeywordContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLParserADD, 0)
}

func (s *NonReservedKeywordContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLParserCOLUMN, 0)
}

func (s *NonReservedKeywordContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLParserRENAME, 0)
}

func (s *NonReservedKeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLParserTO, 0)
}

func (s *NonReservedKeywordContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SQLParserMODIFY, 0)
}

func (s *NonReservedKeywordContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SQLParserCHANGE, 0)
}

func (s *NonReservedKeywordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLParserCONSTRAINT, 0)
}

func (s *NonReservedKeywordContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLParserPRIMARY, 0)
}

func (s *NonReservedKeywordContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLParserKEY, 0)
}

func (s *NonReservedKeywordContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SQLParserFOREIGN, 0)
}

func (s *NonReservedKeywordContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQLParserREFERENCES, 0)
}

func (s *NonReservedKeywordContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLParserUNIQUE, 0)
}

func (s *NonReservedKeywordContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLParserCHECK, 0)
}

func (s *NonReservedKeywordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLParserDEFAULT, 0)
}

func (s *NonReservedKeywordContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLParserGROUP, 0)
}

func (s *NonReservedKeywordContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLParserBY, 0)
}

func (s *NonReservedKeywordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLParserORDER, 0)
}

func (s *NonReservedKeywordContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLParserASC, 0)
}

func (s *NonReservedKeywordContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLParserDESC, 0)
}

func (s *NonReservedKeywordContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQLParserHAVING, 0)
}

func (s *NonReservedKeywordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SQLParserLIMIT, 0)
}

func (s *NonReservedKeywordContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SQLParserOFFSET, 0)
}

func (s *NonReservedKeywordContext) FETCH() antlr.TerminalNode {
	return s.GetToken(SQLParserFETCH, 0)
}

func (s *NonReservedKeywordContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SQLParserNEXT, 0)
}

func (s *NonReservedKeywordContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SQLParserONLY, 0)
}

func (s *NonReservedKeywordContext) TOP() antlr.TerminalNode {
	return s.GetToken(SQLParserTOP, 0)
}

func (s *NonReservedKeywordContext) UNION() antlr.TerminalNode {
	return s.GetToken(SQLParserUNION, 0)
}

func (s *NonReservedKeywordContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SQLParserINTERSECT, 0)
}

func (s *NonReservedKeywordContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SQLParserEXCEPT, 0)
}

func (s *NonReservedKeywordContext) MINUS_SET() antlr.TerminalNode {
	return s.GetToken(SQLParserMINUS_SET, 0)
}

func (s *NonReservedKeywordContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLParserALL, 0)
}

func (s *NonReservedKeywordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLParserDISTINCT, 0)
}

func (s *NonReservedKeywordContext) CASE() antlr.TerminalNode {
	return s.GetToken(SQLParserCASE, 0)
}

func (s *NonReservedKeywordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SQLParserWHEN, 0)
}

func (s *NonReservedKeywordContext) THEN() antlr.TerminalNode {
	return s.GetToken(SQLParserTHEN, 0)
}

func (s *NonReservedKeywordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLParserELSE, 0)
}

func (s *NonReservedKeywordContext) END() antlr.TerminalNode {
	return s.GetToken(SQLParserEND, 0)
}

func (s *NonReservedKeywordContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLParserNULL, 0)
}

func (s *NonReservedKeywordContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLParserIS, 0)
}

func (s *NonReservedKeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLParserIN, 0)
}

func (s *NonReservedKeywordContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLParserBETWEEN, 0)
}

func (s *NonReservedKeywordContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLParserLIKE, 0)
}

func (s *NonReservedKeywordContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(SQLParserILIKE, 0)
}

func (s *NonReservedKeywordContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(SQLParserRLIKE, 0)
}

func (s *NonReservedKeywordContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(SQLParserREGEXP, 0)
}

func (s *NonReservedKeywordContext) SIMILAR() antlr.TerminalNode {
	return s.GetToken(SQLParserSIMILAR, 0)
}

func (s *NonReservedKeywordContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SQLParserESCAPE, 0)
}

func (s *NonReservedKeywordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLParserEXISTS, 0)
}

func (s *NonReservedKeywordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLParserTRUE, 0)
}

func (s *NonReservedKeywordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLParserFALSE, 0)
}

func (s *NonReservedKeywordContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SQLParserUNKNOWN, 0)
}

func (s *NonReservedKeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLParserWITH, 0)
}

func (s *NonReservedKeywordContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SQLParserRECURSIVE, 0)
}

func (s *NonReservedKeywordContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLParserOVER, 0)
}

func (s *NonReservedKeywordContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLParserPARTITION, 0)
}

func (s *NonReservedKeywordContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLParserROWS, 0)
}

func (s *NonReservedKeywordContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLParserRANGE, 0)
}

func (s *NonReservedKeywordContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(SQLParserGROUPS, 0)
}

func (s *NonReservedKeywordContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SQLParserUNBOUNDED, 0)
}

func (s *NonReservedKeywordContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLParserPRECEDING, 0)
}

func (s *NonReservedKeywordContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLParserFOLLOWING, 0)
}

func (s *NonReservedKeywordContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLParserCURRENT, 0)
}

func (s *NonReservedKeywordContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLParserROW, 0)
}

func (s *NonReservedKeywordContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLParserFIRST, 0)
}

func (s *NonReservedKeywordContext) LAST() antlr.TerminalNode {
	return s.GetToken(SQLParserLAST, 0)
}

func (s *NonReservedKeywordContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SQLParserNULLS, 0)
}

func (s *NonReservedKeywordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(SQLParserMERGE, 0)
}

func (s *NonReservedKeywordContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLParserUSING, 0)
}

func (s *NonReservedKeywordContext) MATCHED() antlr.TerminalNode {
	return s.GetToken(SQLParserMATCHED, 0)
}

func (s *NonReservedKeywordContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(SQLParserUPSERT, 0)
}

func (s *NonReservedKeywordContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SQLParserOVERWRITE, 0)
}

func (s *NonReservedKeywordContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLParserREPLACE, 0)
}

func (s *NonReservedKeywordContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SQLParserIGNORE, 0)
}

func (s *NonReservedKeywordContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(SQLParserDUPLICATE, 0)
}

func (s *NonReservedKeywordContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserLATERAL, 0)
}

func (s *NonReservedKeywordContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(SQLParserUNNEST, 0)
}

func (s *NonReservedKeywordContext) EXPLODE() antlr.TerminalNode {
	return s.GetToken(SQLParserEXPLODE, 0)
}

func (s *NonReservedKeywordContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLESAMPLE, 0)
}

func (s *NonReservedKeywordContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SQLParserPERCENT, 0)
}

func (s *NonReservedKeywordContext) BUCKET() antlr.TerminalNode {
	return s.GetToken(SQLParserBUCKET, 0)
}

func (s *NonReservedKeywordContext) OUT() antlr.TerminalNode {
	return s.GetToken(SQLParserOUT, 0)
}

func (s *NonReservedKeywordContext) OF() antlr.TerminalNode {
	return s.GetToken(SQLParserOF, 0)
}

func (s *NonReservedKeywordContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQLParserCAST, 0)
}

func (s *NonReservedKeywordContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(SQLParserCONVERT, 0)
}

func (s *NonReservedKeywordContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SQLParserTRY_CAST, 0)
}

func (s *NonReservedKeywordContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SQLParserEXTRACT, 0)
}

func (s *NonReservedKeywordContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQLParserINTERVAL, 0)
}

func (s *NonReservedKeywordContext) AT() antlr.TerminalNode {
	return s.GetToken(SQLParserAT, 0)
}

func (s *NonReservedKeywordContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SQLParserZONE, 0)
}

func (s *NonReservedKeywordContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQLParserTIME, 0)
}

func (s *NonReservedKeywordContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLParserTIMESTAMP, 0)
}

func (s *NonReservedKeywordContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQLParserDATE, 0)
}

func (s *NonReservedKeywordContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SQLParserYEAR, 0)
}

func (s *NonReservedKeywordContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SQLParserMONTH, 0)
}

func (s *NonReservedKeywordContext) DAY() antlr.TerminalNode {
	return s.GetToken(SQLParserDAY, 0)
}

func (s *NonReservedKeywordContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SQLParserHOUR, 0)
}

func (s *NonReservedKeywordContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SQLParserMINUTE, 0)
}

func (s *NonReservedKeywordContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SQLParserSECOND, 0)
}

func (s *NonReservedKeywordContext) SOME() antlr.TerminalNode {
	return s.GetToken(SQLParserSOME, 0)
}

func (s *NonReservedKeywordContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLParserANY, 0)
}

func (s *NonReservedKeywordContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLParserARRAY, 0)
}

func (s *NonReservedKeywordContext) MAP() antlr.TerminalNode {
	return s.GetToken(SQLParserMAP, 0)
}

func (s *NonReservedKeywordContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRUCT, 0)
}

func (s *NonReservedKeywordContext) NAMED_STRUCT() antlr.TerminalNode {
	return s.GetToken(SQLParserNAMED_STRUCT, 0)
}

func (s *NonReservedKeywordContext) INT() antlr.TerminalNode {
	return s.GetToken(SQLParserINT, 0)
}

func (s *NonReservedKeywordContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SQLParserINTEGER, 0)
}

func (s *NonReservedKeywordContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(SQLParserTINYINT, 0)
}

func (s *NonReservedKeywordContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SQLParserSMALLINT, 0)
}

func (s *NonReservedKeywordContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(SQLParserBIGINT, 0)
}

func (s *NonReservedKeywordContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SQLParserFLOAT, 0)
}

func (s *NonReservedKeywordContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SQLParserDOUBLE, 0)
}

func (s *NonReservedKeywordContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SQLParserDECIMAL, 0)
}

func (s *NonReservedKeywordContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(SQLParserNUMERIC, 0)
}

func (s *NonReservedKeywordContext) REAL() antlr.TerminalNode {
	return s.GetToken(SQLParserREAL, 0)
}

func (s *NonReservedKeywordContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(SQLParserBOOLEAN, 0)
}

func (s *NonReservedKeywordContext) BOOL() antlr.TerminalNode {
	return s.GetToken(SQLParserBOOL, 0)
}

func (s *NonReservedKeywordContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING, 0)
}

func (s *NonReservedKeywordContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(SQLParserVARCHAR, 0)
}

func (s *NonReservedKeywordContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SQLParserCHAR, 0)
}

func (s *NonReservedKeywordContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SQLParserTEXT, 0)
}

func (s *NonReservedKeywordContext) BINARY() antlr.TerminalNode {
	return s.GetToken(SQLParserBINARY, 0)
}

func (s *NonReservedKeywordContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(SQLParserVARBINARY, 0)
}

func (s *NonReservedKeywordContext) BLOB() antlr.TerminalNode {
	return s.GetToken(SQLParserBLOB, 0)
}

func (s *NonReservedKeywordContext) CLOB() antlr.TerminalNode {
	return s.GetToken(SQLParserCLOB, 0)
}

func (s *NonReservedKeywordContext) JSON() antlr.TerminalNode {
	return s.GetToken(SQLParserJSON, 0)
}

func (s *NonReservedKeywordContext) XML() antlr.TerminalNode {
	return s.GetToken(SQLParserXML, 0)
}

func (s *NonReservedKeywordContext) BYTES() antlr.TerminalNode {
	return s.GetToken(SQLParserBYTES, 0)
}

func (s *NonReservedKeywordContext) RAW() antlr.TerminalNode {
	return s.GetToken(SQLParserRAW, 0)
}

func (s *NonReservedKeywordContext) MULTISET() antlr.TerminalNode {
	return s.GetToken(SQLParserMULTISET, 0)
}

func (s *NonReservedKeywordContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SQLParserCOMMENT, 0)
}

func (s *NonReservedKeywordContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SQLParserTEMPORARY, 0)
}

func (s *NonReservedKeywordContext) TEMP() antlr.TerminalNode {
	return s.GetToken(SQLParserTEMP, 0)
}

func (s *NonReservedKeywordContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLParserEXTERNAL, 0)
}

func (s *NonReservedKeywordContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(SQLParserLOCATION, 0)
}

func (s *NonReservedKeywordContext) STORED() antlr.TerminalNode {
	return s.GetToken(SQLParserSTORED, 0)
}

func (s *NonReservedKeywordContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SQLParserFORMAT, 0)
}

func (s *NonReservedKeywordContext) TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SQLParserTBLPROPERTIES, 0)
}

func (s *NonReservedKeywordContext) PARTITIONED() antlr.TerminalNode {
	return s.GetToken(SQLParserPARTITIONED, 0)
}

func (s *NonReservedKeywordContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLParserCLUSTERED, 0)
}

func (s *NonReservedKeywordContext) SORTED() antlr.TerminalNode {
	return s.GetToken(SQLParserSORTED, 0)
}

func (s *NonReservedKeywordContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(SQLParserBUCKETS, 0)
}

func (s *NonReservedKeywordContext) SERDE() antlr.TerminalNode {
	return s.GetToken(SQLParserSERDE, 0)
}

func (s *NonReservedKeywordContext) SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(SQLParserSERDEPROPERTIES, 0)
}

func (s *NonReservedKeywordContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(SQLParserROW_FORMAT, 0)
}

func (s *NonReservedKeywordContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(SQLParserEXCLUDE, 0)
}

func (s *NonReservedKeywordContext) TIES() antlr.TerminalNode {
	return s.GetToken(SQLParserTIES, 0)
}

func (s *NonReservedKeywordContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLParserNO, 0)
}

func (s *NonReservedKeywordContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(SQLParserOTHERS, 0)
}

func (s *NonReservedKeywordContext) WATERMARK() antlr.TerminalNode {
	return s.GetToken(SQLParserWATERMARK, 0)
}

func (s *NonReservedKeywordContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLParserFOR, 0)
}

func (s *NonReservedKeywordContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(SQLParserSYSTEM_TIME, 0)
}

func (s *NonReservedKeywordContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SQLParserSYSTEM, 0)
}

func (s *NonReservedKeywordContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(SQLParserENFORCED, 0)
}

func (s *NonReservedKeywordContext) METADATA() antlr.TerminalNode {
	return s.GetToken(SQLParserMETADATA, 0)
}

func (s *NonReservedKeywordContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(SQLParserVIRTUAL, 0)
}

func (s *NonReservedKeywordContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(SQLParserWITHOUT, 0)
}

func (s *NonReservedKeywordContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(SQLParserGENERATED, 0)
}

func (s *NonReservedKeywordContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SQLParserALWAYS, 0)
}

func (s *NonReservedKeywordContext) IDENTITY() antlr.TerminalNode {
	return s.GetToken(SQLParserIDENTITY, 0)
}

func (s *NonReservedKeywordContext) START() antlr.TerminalNode {
	return s.GetToken(SQLParserSTART, 0)
}

func (s *NonReservedKeywordContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(SQLParserINCREMENT, 0)
}

func (s *NonReservedKeywordContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(SQLParserMINVALUE, 0)
}

func (s *NonReservedKeywordContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(SQLParserMAXVALUE, 0)
}

func (s *NonReservedKeywordContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(SQLParserCYCLE, 0)
}

func (s *NonReservedKeywordContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SQLParserCACHE, 0)
}

func (s *NonReservedKeywordContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SQLParserDISTRIBUTED, 0)
}

func (s *NonReservedKeywordContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLParserHASH, 0)
}

func (s *NonReservedKeywordContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(SQLParserRANDOM, 0)
}

func (s *NonReservedKeywordContext) BROADCAST() antlr.TerminalNode {
	return s.GetToken(SQLParserBROADCAST, 0)
}

func (s *NonReservedKeywordContext) REPLICATED() antlr.TerminalNode {
	return s.GetToken(SQLParserREPLICATED, 0)
}

func (s *NonReservedKeywordContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SQLParserPROPERTIES, 0)
}

func (s *NonReservedKeywordContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(SQLParserENGINE, 0)
}

func (s *NonReservedKeywordContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(SQLParserCHARSET, 0)
}

func (s *NonReservedKeywordContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SQLParserCHARACTER, 0)
}

func (s *NonReservedKeywordContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLParserCOLLATE, 0)
}

func (s *NonReservedKeywordContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(SQLParserTABLESPACE, 0)
}

func (s *NonReservedKeywordContext) INHERITS() antlr.TerminalNode {
	return s.GetToken(SQLParserINHERITS, 0)
}

func (s *NonReservedKeywordContext) FILEGROUP() antlr.TerminalNode {
	return s.GetToken(SQLParserFILEGROUP, 0)
}

func (s *NonReservedKeywordContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SQLParserGLOBAL, 0)
}

func (s *NonReservedKeywordContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQLParserLOCAL, 0)
}

func (s *NonReservedKeywordContext) UNLOGGED() antlr.TerminalNode {
	return s.GetToken(SQLParserUNLOGGED, 0)
}

func (s *NonReservedKeywordContext) TTL() antlr.TerminalNode {
	return s.GetToken(SQLParserTTL, 0)
}

func (s *NonReservedKeywordContext) LIFECYCLE() antlr.TerminalNode {
	return s.GetToken(SQLParserLIFECYCLE, 0)
}

func (s *NonReservedKeywordContext) AUTO() antlr.TerminalNode {
	return s.GetToken(SQLParserAUTO, 0)
}

func (s *NonReservedKeywordContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SQLParserRESTRICT, 0)
}

func (s *NonReservedKeywordContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQLParserCASCADE, 0)
}

func (s *NonReservedKeywordContext) ACTION() antlr.TerminalNode {
	return s.GetToken(SQLParserACTION, 0)
}

func (s *NonReservedKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterNonReservedKeyword(s)
	}
}

func (s *NonReservedKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitNonReservedKeyword(s)
	}
}

func (s *NonReservedKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitNonReservedKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) NonReservedKeyword() (localctx INonReservedKeywordContext) {
	localctx = NewNonReservedKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SQLParserRULE_nonReservedKeyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1906)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&575053377419476990) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-8070454380539068449) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-35184372088865) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&562949953421311) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	NULL() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SQLParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SQLParserNUMBER, 0)
}

func (s *LiteralContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(SQLParserHEX_NUMBER, 0)
}

func (s *LiteralContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(SQLParserBIT_STRING, 0)
}

func (s *LiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLParserTRUE, 0)
}

func (s *LiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLParserFALSE, 0)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLParserNULL, 0)
}

func (s *LiteralContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQLParserINTERVAL, 0)
}

func (s *LiteralContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SQLParserRULE_literal)
	p.SetState(1920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1908)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserNUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1909)
			p.Match(SQLParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserHEX_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1910)
			p.Match(SQLParserHEX_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserBIT_STRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1911)
			p.Match(SQLParserBIT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserTRUE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1912)
			p.Match(SQLParserTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserFALSE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1913)
			p.Match(SQLParserFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserNULL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1914)
			p.Match(SQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SQLParserINTERVAL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1915)
			p.Match(SQLParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1916)
			p.Match(SQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1918)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1917)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *SQLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 83:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SQLParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 34)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 33)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 28)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 14)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
